// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: regen/ecocredit/v1alpha2/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MsgCreateClass is the Msg/CreateClass request type.
struct Regen_Ecocredit_V1alpha2_MsgCreateClass {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// admin is the address of the account that created the credit class.
  var admin: String = String()

  /// issuers are the account addresses of the approved issuers.
  var issuers: [String] = []

  /// metadata is any arbitrary metadata to attached to the credit class.
  var metadata: Data = Data()

  /// credit_type_name describes the type of credit (e.g. "carbon", "biodiversity").
  var creditTypeName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCreateClassResponse is the Msg/CreateClass response type.
struct Regen_Ecocredit_V1alpha2_MsgCreateClassResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// class_id is the unique ID of the newly created credit class.
  var classID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCreateProjectResponse is the Msg/CreateProject request type.
struct Regen_Ecocredit_V1alpha2_MsgCreateProject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// issuer is the address of an approved issuer for the credit class through
  /// which batches will be issued. It is not required, however, that this same
  /// issuer issue all batches for a project.
  var issuer: String = String()

  /// class_id is the unique ID of the class within which the project is created.
  var classID: String = String()

  /// metadata is any arbitrary metadata attached to the project.
  var metadata: Data = Data()

  /// project_location is the location of the project backing the credits in this
  /// batch. It is a string of the form
  /// <country-code>[-<sub-national-code>[ <postal-code>]], with the first two
  /// fields conforming to ISO 3166-2, and postal-code being up to 64
  /// alphanumeric characters. country-code is required, while sub-national-code
  /// and postal-code can be added for increasing precision.
  var projectLocation: String = String()

  /// project_id is an optional user-specified project ID which can be used
  /// instead of an auto-generated ID. If project_id is provided, it must be
  /// unique within the credit class and match the regex [A-Za-z0-9]{2,16}
  /// or else the operation will fail. If project_id is omitted an ID will
  /// automatically be generated.
  var projectID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCreateProjectResponse is the Msg/CreateProject response type.
struct Regen_Ecocredit_V1alpha2_MsgCreateProjectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// project_id is the ID of the newly created project.
  var projectID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCreateBatch is the Msg/CreateBatch request type.
struct Regen_Ecocredit_V1alpha2_MsgCreateBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// issuer is the address of the batch issuer.
  var issuer: String = String()

  /// project_id is the unique ID of the project this batch belongs to.
  var projectID: String = String()

  /// issuance are the credits issued in the batch.
  var issuance: [Regen_Ecocredit_V1alpha2_MsgCreateBatch.BatchIssuance] = []

  /// metadata is any arbitrary metadata attached to the credit batch.
  var metadata: Data = Data()

  /// start_date is the beginning of the period during which this credit batch
  /// was quantified and verified.
  var startDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startDate = newValue}
  }
  /// Returns true if `startDate` has been explicitly set.
  var hasStartDate: Bool {return self._startDate != nil}
  /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
  mutating func clearStartDate() {self._startDate = nil}

  /// end_date is the end of the period during which this credit batch was
  /// quantified and verified.
  var endDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endDate = newValue}
  }
  /// Returns true if `endDate` has been explicitly set.
  var hasEndDate: Bool {return self._endDate != nil}
  /// Clears the value of `endDate`. Subsequent reads from it will return its default value.
  mutating func clearEndDate() {self._endDate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// BatchIssuance represents the issuance of some credits in a batch to a
  /// single recipient.
  struct BatchIssuance {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// recipient is the account of the recipient.
    var recipient: String = String()

    /// tradable_amount is the number of credits in this issuance that can be
    /// traded by this recipient. Decimal values are acceptable.
    var tradableAmount: String = String()

    /// retired_amount is the number of credits in this issuance that are
    /// effectively retired by the issuer on receipt. Decimal values are
    /// acceptable.
    var retiredAmount: String = String()

    /// retirement_location is the location of the beneficiary or buyer of the
    /// retired credits. This must be provided if retired_amount is positive. It
    /// is a string of the form
    /// <country-code>[-<sub-national-code>[ <postal-code>]], with the first two
    /// fields conforming to ISO 3166-2, and postal-code being up to 64
    /// alphanumeric characters.
    var retirementLocation: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _startDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// MsgCreateBatchResponse is the Msg/CreateBatch response type.
struct Regen_Ecocredit_V1alpha2_MsgCreateBatchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// batch_denom is the unique denomination ID of the newly created batch.
  var batchDenom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgSend is the Msg/Send request type.
struct Regen_Ecocredit_V1alpha2_MsgSend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// sender is the address of the account sending credits.
  var sender: String = String()

  /// sender is the address of the account receiving credits.
  var recipient: String = String()

  /// credits are the credits being sent.
  var credits: [Regen_Ecocredit_V1alpha2_MsgSend.SendCredits] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// SendCredits specifies a batch and the number of credits being transferred.
  /// This is split into tradable credits, which will remain tradable on receipt,
  /// and retired credits, which will be retired on receipt.
  struct SendCredits {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// batch_denom is the unique ID of the credit batch.
    var batchDenom: String = String()

    /// tradable_amount is the number of credits in this transfer that can be
    /// traded by the recipient. Decimal values are acceptable within the
    /// precision returned by Query/Precision.
    var tradableAmount: String = String()

    /// retired_amount is the number of credits in this transfer that are
    /// effectively retired by the issuer on receipt. Decimal values are
    /// acceptable within the precision returned by Query/Precision.
    var retiredAmount: String = String()

    /// retirement_location is the location of the beneficiary or buyer of the
    /// retired credits. This must be provided if retired_amount is positive. It
    /// is a string of the form
    /// <country-code>[-<sub-national-code>[ <postal-code>]], with the first two
    /// fields conforming to ISO 3166-2, and postal-code being up to 64
    /// alphanumeric characters.
    var retirementLocation: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// MsgSendResponse is the Msg/Send response type.
struct Regen_Ecocredit_V1alpha2_MsgSendResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRetire is the Msg/Retire request type.
struct Regen_Ecocredit_V1alpha2_MsgRetire {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// holder is the credit holder address.
  var holder: String = String()

  /// credits are the credits being retired.
  var credits: [Regen_Ecocredit_V1alpha2_MsgRetire.RetireCredits] = []

  /// location is the location of the beneficiary or buyer of the retired
  /// credits. It is a string of the form
  /// <country-code>[-<sub-national-code>[ <postal-code>]], with the first two
  /// fields conforming to ISO 3166-2, and postal-code being up to 64
  /// alphanumeric characters.
  var location: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// RetireCredits specifies a batch and the number of credits being retired.
  struct RetireCredits {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// batch_denom is the unique ID of the credit batch.
    var batchDenom: String = String()

    /// amount is the number of credits being retired.
    /// Decimal values are acceptable within the precision returned by
    /// Query/Precision.
    var amount: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// MsgRetire is the Msg/Retire response type.
struct Regen_Ecocredit_V1alpha2_MsgRetireResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCancel is the Msg/Cancel request type.
struct Regen_Ecocredit_V1alpha2_MsgCancel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// holder is the credit holder address.
  var holder: String = String()

  /// credits are the credits being cancelled.
  var credits: [Regen_Ecocredit_V1alpha2_MsgCancel.CancelCredits] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// CancelCredits specifies a batch and the number of credits being cancelled.
  struct CancelCredits {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// batch_denom is the unique ID of the credit batch.
    var batchDenom: String = String()

    /// amount is the number of credits being cancelled.
    /// Decimal values are acceptable within the precision returned by
    /// Query/Precision.
    var amount: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// MsgCancelResponse is the Msg/Cancel response type.
struct Regen_Ecocredit_V1alpha2_MsgCancelResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateClassAdmin is the Msg/UpdateClassAdmin request type.
struct Regen_Ecocredit_V1alpha2_MsgUpdateClassAdmin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// admin is the address of the account that is the admin of the credit class.
  var admin: String = String()

  /// class_id is the unique ID of the credit class.
  var classID: String = String()

  /// new_admin is the address of the new admin of the credit class.
  var newAdmin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateClassAdminResponse is the MsgUpdateClassAdmin response type.
struct Regen_Ecocredit_V1alpha2_MsgUpdateClassAdminResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateClassIssuers is the Msg/UpdateClassIssuers request type.
struct Regen_Ecocredit_V1alpha2_MsgUpdateClassIssuers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// admin is the address of the account that is the admin of the credit class.
  var admin: String = String()

  /// class_id is the unique ID of the credit class.
  var classID: String = String()

  /// issuers are the updated account addresses of the approved issuers.
  var issuers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateClassIssuersResponse is the MsgUpdateClassIssuers response type.
struct Regen_Ecocredit_V1alpha2_MsgUpdateClassIssuersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateClassMetadata is the Msg/UpdateClassMetadata request type.
struct Regen_Ecocredit_V1alpha2_MsgUpdateClassMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// admin is the address of the account that is the admin of the credit class.
  var admin: String = String()

  /// class_id is the unique ID of the credit class.
  var classID: String = String()

  /// metadata is the updated arbitrary metadata to be attached to the credit class.
  var metadata: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateClassMetadataResponse is the MsgUpdateClassMetadata response type.
struct Regen_Ecocredit_V1alpha2_MsgUpdateClassMetadataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgSell is the Msg/Sell request type.
struct Regen_Ecocredit_V1alpha2_MsgSell {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// owner is the address of the owner of the credits being sold.
  var owner: String = String()

  /// orders are the sell orders being created.
  var orders: [Regen_Ecocredit_V1alpha2_MsgSell.Order] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Order is the content of a new sell order.
  struct Order {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// batch_denom is the credit batch being sold.
    var batchDenom: String = String()

    /// quantity is the quantity of credits being sold from this batch. If it is
    /// less then the balance of credits the owner has available at the time this
    /// sell order is matched, the quantity will be adjusted downwards to the
    /// owner's balance. However, if the balance of credits is less than this
    /// quantity at the time the sell order is created, the operation will fail.
    var quantity: String = String()

    /// ask_price is the price the seller is asking for each unit of the
    /// batch_denom. Each credit unit of the batch will be sold for at least the
    /// ask_price or more.
    var askPrice: Cosmos_Base_V1beta1_Coin {
      get {return _askPrice ?? Cosmos_Base_V1beta1_Coin()}
      set {_askPrice = newValue}
    }
    /// Returns true if `askPrice` has been explicitly set.
    var hasAskPrice: Bool {return self._askPrice != nil}
    /// Clears the value of `askPrice`. Subsequent reads from it will return its default value.
    mutating func clearAskPrice() {self._askPrice = nil}

    /// disable_auto_retire disables auto-retirement of credits which allows a
    /// buyer to disable auto-retirement in their buy order enabling them to
    /// resell the credits to another buyer.
    var disableAutoRetire: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _askPrice: Cosmos_Base_V1beta1_Coin? = nil
  }

  init() {}
}

/// MsgSellResponse is the Msg/Sell response type.
struct Regen_Ecocredit_V1alpha2_MsgSellResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// sell_order_ids are the sell order IDs of the newly created sell orders.
  var sellOrderIds: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateSellOrders is the Msg/UpdateSellOrders request type.
struct Regen_Ecocredit_V1alpha2_MsgUpdateSellOrders {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// owner is the owner of the sell orders.
  var owner: String = String()

  /// updates are updates to existing sell orders.
  var updates: [Regen_Ecocredit_V1alpha2_MsgUpdateSellOrders.Update] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Update is an update to an existing sell order.
  struct Update {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///  sell_order_id is the ID of an existing sell order.
    var sellOrderID: UInt64 = 0

    /// new_quantity is the updated quantity of credits available to sell, if it
    /// is set to zero then the order is cancelled.
    var newQuantity: String = String()

    /// new_ask_price is the new ask price for this sell order
    var newAskPrice: Cosmos_Base_V1beta1_Coin {
      get {return _newAskPrice ?? Cosmos_Base_V1beta1_Coin()}
      set {_newAskPrice = newValue}
    }
    /// Returns true if `newAskPrice` has been explicitly set.
    var hasNewAskPrice: Bool {return self._newAskPrice != nil}
    /// Clears the value of `newAskPrice`. Subsequent reads from it will return its default value.
    mutating func clearNewAskPrice() {self._newAskPrice = nil}

    /// disable_auto_retire updates the disable_auto_retire field in the sell order.
    var disableAutoRetire: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _newAskPrice: Cosmos_Base_V1beta1_Coin? = nil
  }

  init() {}
}

/// MsgUpdateSellOrdersResponse is the Msg/UpdateSellOrders response type.
struct Regen_Ecocredit_V1alpha2_MsgUpdateSellOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBuy is the Msg/Buy request type.
struct Regen_Ecocredit_V1alpha2_MsgBuy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// buyer is the address of the credit buyer.
  var buyer: String = String()

  /// orders are the new buy orders.
  var orders: [Regen_Ecocredit_V1alpha2_MsgBuy.Order] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Order is a buy order.
  struct Order {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// selection is the buy order selection.
    var selection: Regen_Ecocredit_V1alpha2_MsgBuy.Order.Selection {
      get {return _selection ?? Regen_Ecocredit_V1alpha2_MsgBuy.Order.Selection()}
      set {_selection = newValue}
    }
    /// Returns true if `selection` has been explicitly set.
    var hasSelection: Bool {return self._selection != nil}
    /// Clears the value of `selection`. Subsequent reads from it will return its default value.
    mutating func clearSelection() {self._selection = nil}

    /// quantity is the quantity of credits to buy. If the quantity of credits
    /// available is less than this amount the order will be partially filled
    /// unless disable_partial_fill is true.
    var quantity: String = String()

    /// bid price is the bid price for this buy order. A credit unit will be
    /// settled at a purchase price that is no more than the bid price. The
    /// buy order will fail if the buyer does not have enough funds available
    /// to complete the purchase.
    var bidPrice: Cosmos_Base_V1beta1_Coin {
      get {return _bidPrice ?? Cosmos_Base_V1beta1_Coin()}
      set {_bidPrice = newValue}
    }
    /// Returns true if `bidPrice` has been explicitly set.
    var hasBidPrice: Bool {return self._bidPrice != nil}
    /// Clears the value of `bidPrice`. Subsequent reads from it will return its default value.
    mutating func clearBidPrice() {self._bidPrice = nil}

    /// disable_auto_retire allows auto-retirement to be disabled. If it is set to true
    /// the credits will not auto-retire and can be resold assuming that the
    /// corresponding sell order has auto-retirement disabled. If the sell order
    /// hasn't disabled auto-retirement and the buy order tries to disable it,
    /// that buy order will fail.
    var disableAutoRetire: Bool = false

    /// disable_partial_fill disables the default behavior of partially filling
    /// buy orders if the requested quantity is not available.
    var disablePartialFill: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Selection defines a buy order selection.
    struct Selection {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// sum defines the type of selection.
      var sum: Regen_Ecocredit_V1alpha2_MsgBuy.Order.Selection.OneOf_Sum? = nil

      /// sell_order_id is the sell order ID against which the buyer is trying to buy.
      /// When sell_order_id is set, this is known as a direct buy order because it
      /// is placed directly against a specific sell order.
      var sellOrderID: UInt64 {
        get {
          if case .sellOrderID(let v)? = sum {return v}
          return 0
        }
        set {sum = .sellOrderID(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      /// sum defines the type of selection.
      enum OneOf_Sum: Equatable {
        /// sell_order_id is the sell order ID against which the buyer is trying to buy.
        /// When sell_order_id is set, this is known as a direct buy order because it
        /// is placed directly against a specific sell order.
        case sellOrderID(UInt64)

      #if !swift(>=4.1)
        static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgBuy.Order.Selection.OneOf_Sum, rhs: Regen_Ecocredit_V1alpha2_MsgBuy.Order.Selection.OneOf_Sum) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.sellOrderID, .sellOrderID): return {
            guard case .sellOrderID(let l) = lhs, case .sellOrderID(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          }
        }
      #endif
      }

      init() {}
    }

    init() {}

    fileprivate var _selection: Regen_Ecocredit_V1alpha2_MsgBuy.Order.Selection? = nil
    fileprivate var _bidPrice: Cosmos_Base_V1beta1_Coin? = nil
  }

  init() {}
}

/// MsgBuyResponse is the Msg/Buy response type.
struct Regen_Ecocredit_V1alpha2_MsgBuyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// buy_order_ids are the buy order IDs of the newly created buy orders. Buy
  /// orders may not settle instantaneously, but rather in batches at specified
  /// batch epoch times.
  var buyOrderIds: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAllowAskDenom is the Msg/AllowAskDenom request type.
struct Regen_Ecocredit_V1alpha2_MsgAllowAskDenom {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// root_address is the address of the governance account which can authorize ask denoms
  var rootAddress: String = String()

  /// denom is the denom to allow (ex. ibc/GLKHDSG423SGS)
  var denom: String = String()

  /// display_denom is the denom to display to the user and is informational
  var displayDenom: String = String()

  /// exponent is the exponent that relates the denom to the display_denom and is
  /// informational
  var exponent: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAllowAskDenomResponse is the Msg/AllowAskDenom response type.
struct Regen_Ecocredit_V1alpha2_MsgAllowAskDenomResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCreateBasket is the Msg/CreateBasket request type.
struct Regen_Ecocredit_V1alpha2_MsgCreateBasket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// curator is the address of the basket curator who is able to change certain
  /// basket settings.
  var curator: String = String()

  /// name will be used to create a bank denom for this basket token of the form
  /// ecocredit:{curator}:{name}.
  var name: String = String()

  /// display_name will be used to create a bank Metadata display name for this
  /// basket token of the form ecocredit:{curator}:{display_name}.
  var displayName: String = String()

  /// exponent is the exponent that will be used for denom metadata. An exponent
  /// of 6 will mean that 10^6 units of a basket token should be displayed
  /// as one unit in user interfaces.
  var exponent: UInt32 = 0

  /// basket_criteria is the criteria by which credits can be added to the
  /// basket. Basket criteria will be applied in order and the first criteria
  /// which applies to a credit will determine its multiplier in the basket.
  var basketCriteria: [Regen_Ecocredit_V1alpha2_BasketCriteria] = []

  /// disable_auto_retire allows auto-retirement to be disabled.
  /// The credits will be auto-retired if disable_auto_retire is
  /// false unless the credits were previously put into the basket by the
  /// address picking them from the basket, in which case they will remain
  /// tradable.
  var disableAutoRetire: Bool = false

  /// allow_picking specifies whether an address which didn't deposit the credits
  /// in the basket can pick those credits or not. 
  var allowPicking: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCreateBasketResponse is the Msg/CreateBasket response type.
struct Regen_Ecocredit_V1alpha2_MsgCreateBasketResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// basket_denom is the unique denomination ID of the newly created basket.
  var basketDenom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddToBasket is the Msg/AddToBasket request type.
struct Regen_Ecocredit_V1alpha2_MsgAddToBasket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// owner is the owner of credits being added to the basket.
  var owner: String = String()

  /// basket_denom is the basket denom to add credits to.
  var basketDenom: String = String()

  /// credits are credits to add to the basket. If they do not match the basket's
  /// admission criteria the operation will fail.
  var credits: [Regen_Ecocredit_V1alpha2_BasketCredit] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddToBasketResponse is the Msg/AddToBasket response type.
struct Regen_Ecocredit_V1alpha2_MsgAddToBasketResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// amount_received is the amount of basket tokens received.
  var amountReceived: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgTakeFromBasket is the Msg/TakeFromBasket request type.
struct Regen_Ecocredit_V1alpha2_MsgTakeFromBasket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// owner is the owner of the basket tokens.
  var owner: String = String()

  /// basket_denom is the basket denom to take credits from.
  var basketDenom: String = String()

  /// amount is the number of credits to take from the basket.
  var amount: String = String()

  /// retirement_location is the optional retirement location for the credits
  /// which will be used only if retire_on_take is true for this basket.
  var retirementLocation: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgTakeFromBasketResponse is the Msg/TakeFromBasket response type.
struct Regen_Ecocredit_V1alpha2_MsgTakeFromBasketResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// credits are the credits taken out of the basket.
  var credits: [Regen_Ecocredit_V1alpha2_BasketCredit] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgPickFromBasket is the Msg/PickFromBasket request type.
struct Regen_Ecocredit_V1alpha2_MsgPickFromBasket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// owner is the owner of the basket tokens.
  var owner: String = String()

  /// basket_denom is the basket denom to pick credits from.
  var basketDenom: String = String()

  /// credits are the units of credits being picked from the basket
  var credits: [Regen_Ecocredit_V1alpha2_BasketCredit] = []

  /// retirement_location is the optional retirement location for the credits
  /// which will be used only if retire_on_take is true for this basket.
  var retirementLocation: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgPickFromBasketResponse is the Msg/PickFromBasket response type.
struct Regen_Ecocredit_V1alpha2_MsgPickFromBasketResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "regen.ecocredit.v1alpha2"

extension Regen_Ecocredit_V1alpha2_MsgCreateClass: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateClass"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "admin"),
    2: .same(proto: "issuers"),
    3: .same(proto: "metadata"),
    4: .standard(proto: "credit_type_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.admin) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.issuers) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.creditTypeName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.admin.isEmpty {
      try visitor.visitSingularStringField(value: self.admin, fieldNumber: 1)
    }
    if !self.issuers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.issuers, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 3)
    }
    if !self.creditTypeName.isEmpty {
      try visitor.visitSingularStringField(value: self.creditTypeName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgCreateClass, rhs: Regen_Ecocredit_V1alpha2_MsgCreateClass) -> Bool {
    if lhs.admin != rhs.admin {return false}
    if lhs.issuers != rhs.issuers {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.creditTypeName != rhs.creditTypeName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgCreateClassResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateClassResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgCreateClassResponse, rhs: Regen_Ecocredit_V1alpha2_MsgCreateClassResponse) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgCreateProject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateProject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuer"),
    2: .standard(proto: "class_id"),
    3: .same(proto: "metadata"),
    4: .standard(proto: "project_location"),
    5: .standard(proto: "project_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.issuer) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.projectLocation) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.issuer.isEmpty {
      try visitor.visitSingularStringField(value: self.issuer, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 3)
    }
    if !self.projectLocation.isEmpty {
      try visitor.visitSingularStringField(value: self.projectLocation, fieldNumber: 4)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgCreateProject, rhs: Regen_Ecocredit_V1alpha2_MsgCreateProject) -> Bool {
    if lhs.issuer != rhs.issuer {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.projectLocation != rhs.projectLocation {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgCreateProjectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateProjectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgCreateProjectResponse, rhs: Regen_Ecocredit_V1alpha2_MsgCreateProjectResponse) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgCreateBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateBatch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuer"),
    2: .standard(proto: "project_id"),
    3: .same(proto: "issuance"),
    4: .same(proto: "metadata"),
    5: .standard(proto: "start_date"),
    6: .standard(proto: "end_date"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.issuer) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.issuance) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._startDate) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._endDate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.issuer.isEmpty {
      try visitor.visitSingularStringField(value: self.issuer, fieldNumber: 1)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 2)
    }
    if !self.issuance.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.issuance, fieldNumber: 3)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 4)
    }
    if let v = self._startDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._endDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgCreateBatch, rhs: Regen_Ecocredit_V1alpha2_MsgCreateBatch) -> Bool {
    if lhs.issuer != rhs.issuer {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.issuance != rhs.issuance {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs._startDate != rhs._startDate {return false}
    if lhs._endDate != rhs._endDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgCreateBatch.BatchIssuance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Regen_Ecocredit_V1alpha2_MsgCreateBatch.protoMessageName + ".BatchIssuance"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recipient"),
    2: .standard(proto: "tradable_amount"),
    3: .standard(proto: "retired_amount"),
    4: .standard(proto: "retirement_location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recipient) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tradableAmount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.retiredAmount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.retirementLocation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recipient.isEmpty {
      try visitor.visitSingularStringField(value: self.recipient, fieldNumber: 1)
    }
    if !self.tradableAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.tradableAmount, fieldNumber: 2)
    }
    if !self.retiredAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.retiredAmount, fieldNumber: 3)
    }
    if !self.retirementLocation.isEmpty {
      try visitor.visitSingularStringField(value: self.retirementLocation, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgCreateBatch.BatchIssuance, rhs: Regen_Ecocredit_V1alpha2_MsgCreateBatch.BatchIssuance) -> Bool {
    if lhs.recipient != rhs.recipient {return false}
    if lhs.tradableAmount != rhs.tradableAmount {return false}
    if lhs.retiredAmount != rhs.retiredAmount {return false}
    if lhs.retirementLocation != rhs.retirementLocation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgCreateBatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateBatchResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.batchDenom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.batchDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.batchDenom, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgCreateBatchResponse, rhs: Regen_Ecocredit_V1alpha2_MsgCreateBatchResponse) -> Bool {
    if lhs.batchDenom != rhs.batchDenom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgSend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "recipient"),
    3: .same(proto: "credits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.recipient) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.credits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.recipient.isEmpty {
      try visitor.visitSingularStringField(value: self.recipient, fieldNumber: 2)
    }
    if !self.credits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.credits, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgSend, rhs: Regen_Ecocredit_V1alpha2_MsgSend) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.recipient != rhs.recipient {return false}
    if lhs.credits != rhs.credits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgSend.SendCredits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Regen_Ecocredit_V1alpha2_MsgSend.protoMessageName + ".SendCredits"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_denom"),
    2: .standard(proto: "tradable_amount"),
    3: .standard(proto: "retired_amount"),
    4: .standard(proto: "retirement_location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.batchDenom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tradableAmount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.retiredAmount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.retirementLocation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.batchDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.batchDenom, fieldNumber: 1)
    }
    if !self.tradableAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.tradableAmount, fieldNumber: 2)
    }
    if !self.retiredAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.retiredAmount, fieldNumber: 3)
    }
    if !self.retirementLocation.isEmpty {
      try visitor.visitSingularStringField(value: self.retirementLocation, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgSend.SendCredits, rhs: Regen_Ecocredit_V1alpha2_MsgSend.SendCredits) -> Bool {
    if lhs.batchDenom != rhs.batchDenom {return false}
    if lhs.tradableAmount != rhs.tradableAmount {return false}
    if lhs.retiredAmount != rhs.retiredAmount {return false}
    if lhs.retirementLocation != rhs.retirementLocation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgSendResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSendResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgSendResponse, rhs: Regen_Ecocredit_V1alpha2_MsgSendResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgRetire: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRetire"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "holder"),
    2: .same(proto: "credits"),
    3: .same(proto: "location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.holder) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.credits) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.location) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.holder.isEmpty {
      try visitor.visitSingularStringField(value: self.holder, fieldNumber: 1)
    }
    if !self.credits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.credits, fieldNumber: 2)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgRetire, rhs: Regen_Ecocredit_V1alpha2_MsgRetire) -> Bool {
    if lhs.holder != rhs.holder {return false}
    if lhs.credits != rhs.credits {return false}
    if lhs.location != rhs.location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgRetire.RetireCredits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Regen_Ecocredit_V1alpha2_MsgRetire.protoMessageName + ".RetireCredits"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_denom"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.batchDenom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.batchDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.batchDenom, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgRetire.RetireCredits, rhs: Regen_Ecocredit_V1alpha2_MsgRetire.RetireCredits) -> Bool {
    if lhs.batchDenom != rhs.batchDenom {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgRetireResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRetireResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgRetireResponse, rhs: Regen_Ecocredit_V1alpha2_MsgRetireResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgCancel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "holder"),
    2: .same(proto: "credits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.holder) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.credits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.holder.isEmpty {
      try visitor.visitSingularStringField(value: self.holder, fieldNumber: 1)
    }
    if !self.credits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.credits, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgCancel, rhs: Regen_Ecocredit_V1alpha2_MsgCancel) -> Bool {
    if lhs.holder != rhs.holder {return false}
    if lhs.credits != rhs.credits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgCancel.CancelCredits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Regen_Ecocredit_V1alpha2_MsgCancel.protoMessageName + ".CancelCredits"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_denom"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.batchDenom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.batchDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.batchDenom, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgCancel.CancelCredits, rhs: Regen_Ecocredit_V1alpha2_MsgCancel.CancelCredits) -> Bool {
    if lhs.batchDenom != rhs.batchDenom {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgCancelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgCancelResponse, rhs: Regen_Ecocredit_V1alpha2_MsgCancelResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgUpdateClassAdmin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateClassAdmin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "admin"),
    2: .standard(proto: "class_id"),
    3: .standard(proto: "new_admin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.admin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.newAdmin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.admin.isEmpty {
      try visitor.visitSingularStringField(value: self.admin, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    if !self.newAdmin.isEmpty {
      try visitor.visitSingularStringField(value: self.newAdmin, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgUpdateClassAdmin, rhs: Regen_Ecocredit_V1alpha2_MsgUpdateClassAdmin) -> Bool {
    if lhs.admin != rhs.admin {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.newAdmin != rhs.newAdmin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgUpdateClassAdminResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateClassAdminResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgUpdateClassAdminResponse, rhs: Regen_Ecocredit_V1alpha2_MsgUpdateClassAdminResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgUpdateClassIssuers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateClassIssuers"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "admin"),
    2: .standard(proto: "class_id"),
    3: .same(proto: "issuers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.admin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.issuers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.admin.isEmpty {
      try visitor.visitSingularStringField(value: self.admin, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    if !self.issuers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.issuers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgUpdateClassIssuers, rhs: Regen_Ecocredit_V1alpha2_MsgUpdateClassIssuers) -> Bool {
    if lhs.admin != rhs.admin {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.issuers != rhs.issuers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgUpdateClassIssuersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateClassIssuersResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgUpdateClassIssuersResponse, rhs: Regen_Ecocredit_V1alpha2_MsgUpdateClassIssuersResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgUpdateClassMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateClassMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "admin"),
    2: .standard(proto: "class_id"),
    3: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.admin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.admin.isEmpty {
      try visitor.visitSingularStringField(value: self.admin, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgUpdateClassMetadata, rhs: Regen_Ecocredit_V1alpha2_MsgUpdateClassMetadata) -> Bool {
    if lhs.admin != rhs.admin {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgUpdateClassMetadataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateClassMetadataResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgUpdateClassMetadataResponse, rhs: Regen_Ecocredit_V1alpha2_MsgUpdateClassMetadataResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgSell: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSell"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 1)
    }
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgSell, rhs: Regen_Ecocredit_V1alpha2_MsgSell) -> Bool {
    if lhs.owner != rhs.owner {return false}
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgSell.Order: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Regen_Ecocredit_V1alpha2_MsgSell.protoMessageName + ".Order"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_denom"),
    2: .same(proto: "quantity"),
    3: .standard(proto: "ask_price"),
    4: .standard(proto: "disable_auto_retire"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.batchDenom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._askPrice) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.disableAutoRetire) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.batchDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.batchDenom, fieldNumber: 1)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 2)
    }
    if let v = self._askPrice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.disableAutoRetire != false {
      try visitor.visitSingularBoolField(value: self.disableAutoRetire, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgSell.Order, rhs: Regen_Ecocredit_V1alpha2_MsgSell.Order) -> Bool {
    if lhs.batchDenom != rhs.batchDenom {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs._askPrice != rhs._askPrice {return false}
    if lhs.disableAutoRetire != rhs.disableAutoRetire {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgSellResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSellResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sell_order_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.sellOrderIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sellOrderIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.sellOrderIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgSellResponse, rhs: Regen_Ecocredit_V1alpha2_MsgSellResponse) -> Bool {
    if lhs.sellOrderIds != rhs.sellOrderIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgUpdateSellOrders: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateSellOrders"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "updates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 1)
    }
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgUpdateSellOrders, rhs: Regen_Ecocredit_V1alpha2_MsgUpdateSellOrders) -> Bool {
    if lhs.owner != rhs.owner {return false}
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgUpdateSellOrders.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Regen_Ecocredit_V1alpha2_MsgUpdateSellOrders.protoMessageName + ".Update"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sell_order_id"),
    2: .standard(proto: "new_quantity"),
    3: .standard(proto: "new_ask_price"),
    4: .standard(proto: "disable_auto_retire"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.sellOrderID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newQuantity) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newAskPrice) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.disableAutoRetire) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sellOrderID != 0 {
      try visitor.visitSingularUInt64Field(value: self.sellOrderID, fieldNumber: 1)
    }
    if !self.newQuantity.isEmpty {
      try visitor.visitSingularStringField(value: self.newQuantity, fieldNumber: 2)
    }
    if let v = self._newAskPrice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.disableAutoRetire != false {
      try visitor.visitSingularBoolField(value: self.disableAutoRetire, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgUpdateSellOrders.Update, rhs: Regen_Ecocredit_V1alpha2_MsgUpdateSellOrders.Update) -> Bool {
    if lhs.sellOrderID != rhs.sellOrderID {return false}
    if lhs.newQuantity != rhs.newQuantity {return false}
    if lhs._newAskPrice != rhs._newAskPrice {return false}
    if lhs.disableAutoRetire != rhs.disableAutoRetire {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgUpdateSellOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateSellOrdersResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgUpdateSellOrdersResponse, rhs: Regen_Ecocredit_V1alpha2_MsgUpdateSellOrdersResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgBuy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBuy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "buyer"),
    2: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.buyer) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buyer.isEmpty {
      try visitor.visitSingularStringField(value: self.buyer, fieldNumber: 1)
    }
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgBuy, rhs: Regen_Ecocredit_V1alpha2_MsgBuy) -> Bool {
    if lhs.buyer != rhs.buyer {return false}
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgBuy.Order: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Regen_Ecocredit_V1alpha2_MsgBuy.protoMessageName + ".Order"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "selection"),
    2: .same(proto: "quantity"),
    3: .standard(proto: "bid_price"),
    4: .standard(proto: "disable_auto_retire"),
    5: .standard(proto: "disable_partial_fill"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._selection) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._bidPrice) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.disableAutoRetire) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.disablePartialFill) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._selection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 2)
    }
    if let v = self._bidPrice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.disableAutoRetire != false {
      try visitor.visitSingularBoolField(value: self.disableAutoRetire, fieldNumber: 4)
    }
    if self.disablePartialFill != false {
      try visitor.visitSingularBoolField(value: self.disablePartialFill, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgBuy.Order, rhs: Regen_Ecocredit_V1alpha2_MsgBuy.Order) -> Bool {
    if lhs._selection != rhs._selection {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs._bidPrice != rhs._bidPrice {return false}
    if lhs.disableAutoRetire != rhs.disableAutoRetire {return false}
    if lhs.disablePartialFill != rhs.disablePartialFill {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgBuy.Order.Selection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Regen_Ecocredit_V1alpha2_MsgBuy.Order.protoMessageName + ".Selection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sell_order_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.sum != nil {try decoder.handleConflictingOneOf()}
          self.sum = .sellOrderID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .sellOrderID(let v)? = self.sum {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgBuy.Order.Selection, rhs: Regen_Ecocredit_V1alpha2_MsgBuy.Order.Selection) -> Bool {
    if lhs.sum != rhs.sum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgBuyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBuyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "buy_order_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.buyOrderIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buyOrderIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.buyOrderIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgBuyResponse, rhs: Regen_Ecocredit_V1alpha2_MsgBuyResponse) -> Bool {
    if lhs.buyOrderIds != rhs.buyOrderIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgAllowAskDenom: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAllowAskDenom"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_address"),
    2: .same(proto: "denom"),
    3: .standard(proto: "display_denom"),
    4: .same(proto: "exponent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.displayDenom) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.exponent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.rootAddress, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    if !self.displayDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.displayDenom, fieldNumber: 3)
    }
    if self.exponent != 0 {
      try visitor.visitSingularUInt32Field(value: self.exponent, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgAllowAskDenom, rhs: Regen_Ecocredit_V1alpha2_MsgAllowAskDenom) -> Bool {
    if lhs.rootAddress != rhs.rootAddress {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.displayDenom != rhs.displayDenom {return false}
    if lhs.exponent != rhs.exponent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgAllowAskDenomResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAllowAskDenomResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgAllowAskDenomResponse, rhs: Regen_Ecocredit_V1alpha2_MsgAllowAskDenomResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgCreateBasket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateBasket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "curator"),
    2: .same(proto: "name"),
    3: .standard(proto: "display_name"),
    4: .same(proto: "exponent"),
    5: .standard(proto: "basket_criteria"),
    6: .standard(proto: "disable_auto_retire"),
    7: .standard(proto: "allow_picking"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.curator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.exponent) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.basketCriteria) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disableAutoRetire) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.allowPicking) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.curator.isEmpty {
      try visitor.visitSingularStringField(value: self.curator, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 3)
    }
    if self.exponent != 0 {
      try visitor.visitSingularUInt32Field(value: self.exponent, fieldNumber: 4)
    }
    if !self.basketCriteria.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.basketCriteria, fieldNumber: 5)
    }
    if self.disableAutoRetire != false {
      try visitor.visitSingularBoolField(value: self.disableAutoRetire, fieldNumber: 6)
    }
    if self.allowPicking != false {
      try visitor.visitSingularBoolField(value: self.allowPicking, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgCreateBasket, rhs: Regen_Ecocredit_V1alpha2_MsgCreateBasket) -> Bool {
    if lhs.curator != rhs.curator {return false}
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.exponent != rhs.exponent {return false}
    if lhs.basketCriteria != rhs.basketCriteria {return false}
    if lhs.disableAutoRetire != rhs.disableAutoRetire {return false}
    if lhs.allowPicking != rhs.allowPicking {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgCreateBasketResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateBasketResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "basket_denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.basketDenom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.basketDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.basketDenom, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgCreateBasketResponse, rhs: Regen_Ecocredit_V1alpha2_MsgCreateBasketResponse) -> Bool {
    if lhs.basketDenom != rhs.basketDenom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgAddToBasket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddToBasket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .standard(proto: "basket_denom"),
    3: .same(proto: "credits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.basketDenom) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.credits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 1)
    }
    if !self.basketDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.basketDenom, fieldNumber: 2)
    }
    if !self.credits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.credits, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgAddToBasket, rhs: Regen_Ecocredit_V1alpha2_MsgAddToBasket) -> Bool {
    if lhs.owner != rhs.owner {return false}
    if lhs.basketDenom != rhs.basketDenom {return false}
    if lhs.credits != rhs.credits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgAddToBasketResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddToBasketResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "amount_received"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.amountReceived) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amountReceived.isEmpty {
      try visitor.visitSingularStringField(value: self.amountReceived, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgAddToBasketResponse, rhs: Regen_Ecocredit_V1alpha2_MsgAddToBasketResponse) -> Bool {
    if lhs.amountReceived != rhs.amountReceived {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgTakeFromBasket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgTakeFromBasket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .standard(proto: "basket_denom"),
    3: .same(proto: "amount"),
    4: .standard(proto: "retirement_location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.basketDenom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.retirementLocation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 1)
    }
    if !self.basketDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.basketDenom, fieldNumber: 2)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 3)
    }
    if !self.retirementLocation.isEmpty {
      try visitor.visitSingularStringField(value: self.retirementLocation, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgTakeFromBasket, rhs: Regen_Ecocredit_V1alpha2_MsgTakeFromBasket) -> Bool {
    if lhs.owner != rhs.owner {return false}
    if lhs.basketDenom != rhs.basketDenom {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.retirementLocation != rhs.retirementLocation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgTakeFromBasketResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgTakeFromBasketResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "credits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.credits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.credits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.credits, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgTakeFromBasketResponse, rhs: Regen_Ecocredit_V1alpha2_MsgTakeFromBasketResponse) -> Bool {
    if lhs.credits != rhs.credits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgPickFromBasket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgPickFromBasket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .standard(proto: "basket_denom"),
    3: .same(proto: "credits"),
    4: .standard(proto: "retirement_location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.basketDenom) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.credits) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.retirementLocation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 1)
    }
    if !self.basketDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.basketDenom, fieldNumber: 2)
    }
    if !self.credits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.credits, fieldNumber: 3)
    }
    if !self.retirementLocation.isEmpty {
      try visitor.visitSingularStringField(value: self.retirementLocation, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgPickFromBasket, rhs: Regen_Ecocredit_V1alpha2_MsgPickFromBasket) -> Bool {
    if lhs.owner != rhs.owner {return false}
    if lhs.basketDenom != rhs.basketDenom {return false}
    if lhs.credits != rhs.credits {return false}
    if lhs.retirementLocation != rhs.retirementLocation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_MsgPickFromBasketResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgPickFromBasketResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_MsgPickFromBasketResponse, rhs: Regen_Ecocredit_V1alpha2_MsgPickFromBasketResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
