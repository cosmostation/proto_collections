// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: provenance/metadata/v1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MsgWriteScopeRequest is the request type for the Msg/WriteScope RPC method.
struct Provenance_Metadata_V1_MsgWriteScopeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope is the Scope you want added or updated.
  var scope: Provenance_Metadata_V1_Scope {
    get {return _scope ?? Provenance_Metadata_V1_Scope()}
    set {_scope = newValue}
  }
  /// Returns true if `scope` has been explicitly set.
  var hasScope: Bool {return self._scope != nil}
  /// Clears the value of `scope`. Subsequent reads from it will return its default value.
  mutating func clearScope() {self._scope = nil}

  /// signers is the list of address of those signing this request.
  var signers: [String] = []

  /// scope_uuid is an optional uuid string, e.g. "91978ba2-5f35-459a-86a7-feca1b0512e0"
  /// If provided, it will be used to generate the MetadataAddress for the scope which will override the scope_id in the
  /// provided scope. If not provided (or it is an empty string), nothing special happens.
  /// If there is a value in scope.scope_id that is different from the one created from this uuid, an error is returned.
  var scopeUuid: String = String()

  /// spec_uuid is an optional scope specification uuid string, e.g. "dc83ea70-eacd-40fe-9adf-1cf6148bf8a2"
  /// If provided, it will be used to generate the MetadataAddress for the scope specification which will override the
  /// specification_id in the provided scope. If not provided (or it is an empty string), nothing special happens.
  /// If there is a value in scope.specification_id that is different from the one created from this uuid, an error is
  /// returned.
  var specUuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scope: Provenance_Metadata_V1_Scope? = nil
}

/// MsgWriteScopeResponse is the response type for the Msg/WriteScope RPC method.
struct Provenance_Metadata_V1_MsgWriteScopeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope_id_info contains information about the id/address of the scope that was added or updated.
  var scopeIDInfo: Provenance_Metadata_V1_ScopeIdInfo {
    get {return _scopeIDInfo ?? Provenance_Metadata_V1_ScopeIdInfo()}
    set {_scopeIDInfo = newValue}
  }
  /// Returns true if `scopeIDInfo` has been explicitly set.
  var hasScopeIDInfo: Bool {return self._scopeIDInfo != nil}
  /// Clears the value of `scopeIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearScopeIDInfo() {self._scopeIDInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scopeIDInfo: Provenance_Metadata_V1_ScopeIdInfo? = nil
}

/// MsgDeleteScopeRequest is the request type for the Msg/DeleteScope RPC method.
struct Provenance_Metadata_V1_MsgDeleteScopeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID for the scope to delete
  var scopeID: Data = Data()

  var signers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteScopeResponse is the response type for the Msg/DeleteScope RPC method.
struct Provenance_Metadata_V1_MsgDeleteScopeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddScopeDataAccessRequest is the request to add data access AccAddress to scope
struct Provenance_Metadata_V1_MsgAddScopeDataAccessRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope MetadataAddress for updating data access
  var scopeID: Data = Data()

  /// AccAddress addresses to be added to scope
  var dataAccess: [String] = []

  /// signers is the list of address of those signing this request.
  var signers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddScopeDataAccessResponse is the response for adding data access AccAddress to scope
struct Provenance_Metadata_V1_MsgAddScopeDataAccessResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteScopeDataAccessRequest is the request to remove data access AccAddress to scope
struct Provenance_Metadata_V1_MsgDeleteScopeDataAccessRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope MetadataAddress for removing data access
  var scopeID: Data = Data()

  /// AccAddress address to be removed from scope
  var dataAccess: [String] = []

  /// signers is the list of address of those signing this request.
  var signers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteScopeDataAccessResponse is the response from removing data access AccAddress to scope
struct Provenance_Metadata_V1_MsgDeleteScopeDataAccessResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddScopeOwnerRequest is the request to add owner AccAddress to scope
struct Provenance_Metadata_V1_MsgAddScopeOwnerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope MetadataAddress for updating data access
  var scopeID: Data = Data()

  /// AccAddress owner addresses to be added to scope
  var owners: [Provenance_Metadata_V1_Party] = []

  /// signers is the list of address of those signing this request.
  var signers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddScopeOwnerResponse is the response for adding owner AccAddresses to scope
struct Provenance_Metadata_V1_MsgAddScopeOwnerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteScopeOwnerRequest is the request to remove owner AccAddresses to scope
struct Provenance_Metadata_V1_MsgDeleteScopeOwnerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope MetadataAddress for removing data access
  var scopeID: Data = Data()

  /// AccAddress owner addresses to be removed from scope
  var owners: [String] = []

  /// signers is the list of address of those signing this request.
  var signers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteScopeOwnerResponse is the response from removing owner AccAddress to scope
struct Provenance_Metadata_V1_MsgDeleteScopeOwnerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgWriteSessionRequest is the request type for the Msg/WriteSession RPC method.
struct Provenance_Metadata_V1_MsgWriteSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// session is the Session you want added or updated.
  var session: Provenance_Metadata_V1_Session {
    get {return _storage._session ?? Provenance_Metadata_V1_Session()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// signers is the list of address of those signing this request.
  var signers: [String] {
    get {return _storage._signers}
    set {_uniqueStorage()._signers = newValue}
  }

  /// SessionIDComponents is an optional (alternate) way of defining what the session_id should be in the provided
  /// session. If provided, it must have both a scope and session_uuid. Those components will be used to create the
  /// MetadataAddress for the session which will override the session_id in the provided session. If not provided (or
  /// all empty), nothing special happens.
  /// If there is a value in session.session_id that is different from the one created from these components, an error is
  /// returned.
  var sessionIDComponents: Provenance_Metadata_V1_SessionIdComponents {
    get {return _storage._sessionIDComponents ?? Provenance_Metadata_V1_SessionIdComponents()}
    set {_uniqueStorage()._sessionIDComponents = newValue}
  }
  /// Returns true if `sessionIDComponents` has been explicitly set.
  var hasSessionIDComponents: Bool {return _storage._sessionIDComponents != nil}
  /// Clears the value of `sessionIDComponents`. Subsequent reads from it will return its default value.
  mutating func clearSessionIDComponents() {_uniqueStorage()._sessionIDComponents = nil}

  /// spec_uuid is an optional contract specification uuid string, e.g. "def6bc0a-c9dd-4874-948f-5206e6060a84"
  /// If provided, it will be used to generate the MetadataAddress for the contract specification which will override the
  /// specification_id in the provided session. If not provided (or it is an empty string), nothing special happens.
  /// If there is a value in session.specification_id that is different from the one created from this uuid, an error is
  /// returned.
  var specUuid: String {
    get {return _storage._specUuid}
    set {_uniqueStorage()._specUuid = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SessionIDComponents contains fields for the components that make up a session id.
struct Provenance_Metadata_V1_SessionIdComponents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope is used to define the scope this session belongs to.
  var scopeIdentifier: Provenance_Metadata_V1_SessionIdComponents.OneOf_ScopeIdentifier? = nil

  /// scope_uuid is the uuid string for the scope, e.g. "91978ba2-5f35-459a-86a7-feca1b0512e0"
  var scopeUuid: String {
    get {
      if case .scopeUuid(let v)? = scopeIdentifier {return v}
      return String()
    }
    set {scopeIdentifier = .scopeUuid(newValue)}
  }

  /// scope_addr is the bech32 address string for the scope, g.g. "scope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel"
  var scopeAddr: String {
    get {
      if case .scopeAddr(let v)? = scopeIdentifier {return v}
      return String()
    }
    set {scopeIdentifier = .scopeAddr(newValue)}
  }

  /// session_uuid is a uuid string for identifying this session, e.g. "5803f8bc-6067-4eb5-951f-2121671c2ec0"
  var sessionUuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// scope is used to define the scope this session belongs to.
  enum OneOf_ScopeIdentifier: Equatable {
    /// scope_uuid is the uuid string for the scope, e.g. "91978ba2-5f35-459a-86a7-feca1b0512e0"
    case scopeUuid(String)
    /// scope_addr is the bech32 address string for the scope, g.g. "scope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel"
    case scopeAddr(String)

  #if !swift(>=4.1)
    static func ==(lhs: Provenance_Metadata_V1_SessionIdComponents.OneOf_ScopeIdentifier, rhs: Provenance_Metadata_V1_SessionIdComponents.OneOf_ScopeIdentifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.scopeUuid, .scopeUuid): return {
        guard case .scopeUuid(let l) = lhs, case .scopeUuid(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scopeAddr, .scopeAddr): return {
        guard case .scopeAddr(let l) = lhs, case .scopeAddr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// MsgWriteSessionResponse is the response type for the Msg/WriteSession RPC method.
struct Provenance_Metadata_V1_MsgWriteSessionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// session_id_info contains information about the id/address of the session that was added or updated.
  var sessionIDInfo: Provenance_Metadata_V1_SessionIdInfo {
    get {return _sessionIDInfo ?? Provenance_Metadata_V1_SessionIdInfo()}
    set {_sessionIDInfo = newValue}
  }
  /// Returns true if `sessionIDInfo` has been explicitly set.
  var hasSessionIDInfo: Bool {return self._sessionIDInfo != nil}
  /// Clears the value of `sessionIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearSessionIDInfo() {self._sessionIDInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sessionIDInfo: Provenance_Metadata_V1_SessionIdInfo? = nil
}

/// MsgWriteRecordRequest is the request type for the Msg/WriteRecord RPC method.
struct Provenance_Metadata_V1_MsgWriteRecordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// record is the Record you want added or updated.
  var record: Provenance_Metadata_V1_Record {
    get {return _record ?? Provenance_Metadata_V1_Record()}
    set {_record = newValue}
  }
  /// Returns true if `record` has been explicitly set.
  var hasRecord: Bool {return self._record != nil}
  /// Clears the value of `record`. Subsequent reads from it will return its default value.
  mutating func clearRecord() {self._record = nil}

  /// signers is the list of address of those signing this request.
  var signers: [String] = []

  /// SessionIDComponents is an optional (alternate) way of defining what the session_id should be in the provided
  /// record. If provided, it must have both a scope and session_uuid. Those components will be used to create the
  /// MetadataAddress for the session which will override the session_id in the provided record. If not provided (or
  /// all empty), nothing special happens.
  /// If there is a value in record.session_id that is different from the one created from these components, an error is
  /// returned.
  var sessionIDComponents: Provenance_Metadata_V1_SessionIdComponents {
    get {return _sessionIDComponents ?? Provenance_Metadata_V1_SessionIdComponents()}
    set {_sessionIDComponents = newValue}
  }
  /// Returns true if `sessionIDComponents` has been explicitly set.
  var hasSessionIDComponents: Bool {return self._sessionIDComponents != nil}
  /// Clears the value of `sessionIDComponents`. Subsequent reads from it will return its default value.
  mutating func clearSessionIDComponents() {self._sessionIDComponents = nil}

  /// contract_spec_uuid is an optional contract specification uuid string, e.g. "def6bc0a-c9dd-4874-948f-5206e6060a84"
  /// If provided, it will be combined with the record name to generate the MetadataAddress for the record specification
  /// which will override the specification_id in the provided record. If not provided (or it is an empty string),
  /// nothing special happens.
  /// If there is a value in record.specification_id that is different from the one created from this uuid and
  /// record.name, an error is returned.
  var contractSpecUuid: String = String()

  /// parties is the list of parties involved with this record.
  var parties: [Provenance_Metadata_V1_Party] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _record: Provenance_Metadata_V1_Record? = nil
  fileprivate var _sessionIDComponents: Provenance_Metadata_V1_SessionIdComponents? = nil
}

/// MsgWriteRecordResponse is the response type for the Msg/WriteRecord RPC method.
struct Provenance_Metadata_V1_MsgWriteRecordResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// record_id_info contains information about the id/address of the record that was added or updated.
  var recordIDInfo: Provenance_Metadata_V1_RecordIdInfo {
    get {return _recordIDInfo ?? Provenance_Metadata_V1_RecordIdInfo()}
    set {_recordIDInfo = newValue}
  }
  /// Returns true if `recordIDInfo` has been explicitly set.
  var hasRecordIDInfo: Bool {return self._recordIDInfo != nil}
  /// Clears the value of `recordIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearRecordIDInfo() {self._recordIDInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _recordIDInfo: Provenance_Metadata_V1_RecordIdInfo? = nil
}

/// MsgDeleteRecordRequest is the request type for the Msg/DeleteRecord RPC method.
struct Provenance_Metadata_V1_MsgDeleteRecordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var recordID: Data = Data()

  var signers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteRecordResponse is the response type for the Msg/DeleteRecord RPC method.
struct Provenance_Metadata_V1_MsgDeleteRecordResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgWriteScopeSpecificationRequest is the request type for the Msg/WriteScopeSpecification RPC method.
struct Provenance_Metadata_V1_MsgWriteScopeSpecificationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// specification is the ScopeSpecification you want added or updated.
  var specification: Provenance_Metadata_V1_ScopeSpecification {
    get {return _specification ?? Provenance_Metadata_V1_ScopeSpecification()}
    set {_specification = newValue}
  }
  /// Returns true if `specification` has been explicitly set.
  var hasSpecification: Bool {return self._specification != nil}
  /// Clears the value of `specification`. Subsequent reads from it will return its default value.
  mutating func clearSpecification() {self._specification = nil}

  /// signers is the list of address of those signing this request.
  var signers: [String] = []

  /// spec_uuid is an optional scope specification uuid string, e.g. "dc83ea70-eacd-40fe-9adf-1cf6148bf8a2"
  /// If provided, it will be used to generate the MetadataAddress for the scope specification which will override the
  /// specification_id in the provided specification. If not provided (or it is an empty string), nothing special
  /// happens.
  /// If there is a value in specification.specification_id that is different from the one created from this uuid, an
  /// error is returned.
  var specUuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _specification: Provenance_Metadata_V1_ScopeSpecification? = nil
}

/// MsgWriteScopeSpecificationResponse is the response type for the Msg/WriteScopeSpecification RPC method.
struct Provenance_Metadata_V1_MsgWriteScopeSpecificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope_spec_id_info contains information about the id/address of the scope specification that was added or updated.
  var scopeSpecIDInfo: Provenance_Metadata_V1_ScopeSpecIdInfo {
    get {return _scopeSpecIDInfo ?? Provenance_Metadata_V1_ScopeSpecIdInfo()}
    set {_scopeSpecIDInfo = newValue}
  }
  /// Returns true if `scopeSpecIDInfo` has been explicitly set.
  var hasScopeSpecIDInfo: Bool {return self._scopeSpecIDInfo != nil}
  /// Clears the value of `scopeSpecIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearScopeSpecIDInfo() {self._scopeSpecIDInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scopeSpecIDInfo: Provenance_Metadata_V1_ScopeSpecIdInfo? = nil
}

/// MsgDeleteScopeSpecificationRequest is the request type for the Msg/DeleteScopeSpecification RPC method.
struct Provenance_Metadata_V1_MsgDeleteScopeSpecificationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// MetadataAddress for the scope specification to delete.
  var specificationID: Data = Data()

  var signers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteScopeSpecificationResponse is the response type for the Msg/DeleteScopeSpecification RPC method.
struct Provenance_Metadata_V1_MsgDeleteScopeSpecificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgWriteContractSpecificationRequest is the request type for the Msg/WriteContractSpecification RPC method.
struct Provenance_Metadata_V1_MsgWriteContractSpecificationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// specification is the ContractSpecification you want added or updated.
  var specification: Provenance_Metadata_V1_ContractSpecification {
    get {return _specification ?? Provenance_Metadata_V1_ContractSpecification()}
    set {_specification = newValue}
  }
  /// Returns true if `specification` has been explicitly set.
  var hasSpecification: Bool {return self._specification != nil}
  /// Clears the value of `specification`. Subsequent reads from it will return its default value.
  mutating func clearSpecification() {self._specification = nil}

  /// signers is the list of address of those signing this request.
  var signers: [String] = []

  /// spec_uuid is an optional contract specification uuid string, e.g. "def6bc0a-c9dd-4874-948f-5206e6060a84"
  /// If provided, it will be used to generate the MetadataAddress for the contract specification which will override the
  /// specification_id in the provided specification. If not provided (or it is an empty string), nothing special
  /// happens.
  /// If there is a value in specification.specification_id that is different from the one created from this uuid, an
  /// error is returned.
  var specUuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _specification: Provenance_Metadata_V1_ContractSpecification? = nil
}

/// MsgWriteContractSpecificationResponse is the response type for the Msg/WriteContractSpecification RPC method.
struct Provenance_Metadata_V1_MsgWriteContractSpecificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// contract_spec_id_info contains information about the id/address of the contract specification that was added or
  /// updated.
  var contractSpecIDInfo: Provenance_Metadata_V1_ContractSpecIdInfo {
    get {return _contractSpecIDInfo ?? Provenance_Metadata_V1_ContractSpecIdInfo()}
    set {_contractSpecIDInfo = newValue}
  }
  /// Returns true if `contractSpecIDInfo` has been explicitly set.
  var hasContractSpecIDInfo: Bool {return self._contractSpecIDInfo != nil}
  /// Clears the value of `contractSpecIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearContractSpecIDInfo() {self._contractSpecIDInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _contractSpecIDInfo: Provenance_Metadata_V1_ContractSpecIdInfo? = nil
}

/// MsgAddContractSpecToScopeSpecRequest is the request type for the Msg/AddContractSpecToScopeSpec RPC method.
struct Provenance_Metadata_V1_MsgAddContractSpecToScopeSpecRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// MetadataAddress for the contract specification to add.
  var contractSpecificationID: Data = Data()

  /// MetadataAddress for the scope specification to add contract specification to.
  var scopeSpecificationID: Data = Data()

  var signers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddContractSpecToScopeSpecResponse is the response type for the Msg/AddContractSpecToScopeSpec RPC method.
struct Provenance_Metadata_V1_MsgAddContractSpecToScopeSpecResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteContractSpecFromScopeSpecRequest is the request type for the Msg/DeleteContractSpecFromScopeSpec RPC method.
struct Provenance_Metadata_V1_MsgDeleteContractSpecFromScopeSpecRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// MetadataAddress for the contract specification to add.
  var contractSpecificationID: Data = Data()

  /// MetadataAddress for the scope specification to add contract specification to.
  var scopeSpecificationID: Data = Data()

  var signers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteContractSpecFromScopeSpecResponse is the response type for the Msg/DeleteContractSpecFromScopeSpec RPC
/// method.
struct Provenance_Metadata_V1_MsgDeleteContractSpecFromScopeSpecResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteContractSpecificationRequest is the request type for the Msg/DeleteContractSpecification RPC method.
struct Provenance_Metadata_V1_MsgDeleteContractSpecificationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// MetadataAddress for the contract specification to delete.
  var specificationID: Data = Data()

  var signers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteContractSpecificationResponse is the response type for the Msg/DeleteContractSpecification RPC method.
struct Provenance_Metadata_V1_MsgDeleteContractSpecificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgWriteRecordSpecificationRequest is the request type for the Msg/WriteRecordSpecification RPC method.
struct Provenance_Metadata_V1_MsgWriteRecordSpecificationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// specification is the RecordSpecification you want added or updated.
  var specification: Provenance_Metadata_V1_RecordSpecification {
    get {return _specification ?? Provenance_Metadata_V1_RecordSpecification()}
    set {_specification = newValue}
  }
  /// Returns true if `specification` has been explicitly set.
  var hasSpecification: Bool {return self._specification != nil}
  /// Clears the value of `specification`. Subsequent reads from it will return its default value.
  mutating func clearSpecification() {self._specification = nil}

  /// signers is the list of address of those signing this request.
  var signers: [String] = []

  /// contract_spec_uuid is an optional contract specification uuid string, e.g. "def6bc0a-c9dd-4874-948f-5206e6060a84"
  /// If provided, it will be combined with the record specification name to generate the MetadataAddress for the record
  /// specification which will override the specification_id in the provided specification. If not provided (or it is an
  /// empty string), nothing special happens.
  /// If there is a value in specification.specification_id that is different from the one created from this uuid and
  /// specification.name, an error is returned.
  var contractSpecUuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _specification: Provenance_Metadata_V1_RecordSpecification? = nil
}

/// MsgWriteRecordSpecificationResponse is the response type for the Msg/WriteRecordSpecification RPC method.
struct Provenance_Metadata_V1_MsgWriteRecordSpecificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// record_spec_id_info contains information about the id/address of the record specification that was added or
  /// updated.
  var recordSpecIDInfo: Provenance_Metadata_V1_RecordSpecIdInfo {
    get {return _recordSpecIDInfo ?? Provenance_Metadata_V1_RecordSpecIdInfo()}
    set {_recordSpecIDInfo = newValue}
  }
  /// Returns true if `recordSpecIDInfo` has been explicitly set.
  var hasRecordSpecIDInfo: Bool {return self._recordSpecIDInfo != nil}
  /// Clears the value of `recordSpecIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearRecordSpecIDInfo() {self._recordSpecIDInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _recordSpecIDInfo: Provenance_Metadata_V1_RecordSpecIdInfo? = nil
}

/// MsgDeleteRecordSpecificationRequest is the request type for the Msg/DeleteRecordSpecification RPC method.
struct Provenance_Metadata_V1_MsgDeleteRecordSpecificationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// MetadataAddress for the record specification to delete.
  var specificationID: Data = Data()

  var signers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteRecordSpecificationResponse is the response type for the Msg/DeleteRecordSpecification RPC method.
struct Provenance_Metadata_V1_MsgDeleteRecordSpecificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgWriteP8eContractSpecRequest is the request type for the Msg/WriteP8eContractSpec RPC method.
struct Provenance_Metadata_V1_MsgWriteP8eContractSpecRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ContractSpec v39 p8e ContractSpect to be converted into a v40
  var contractspec: Provenance_Metadata_V1_P8e_ContractSpec {
    get {return _contractspec ?? Provenance_Metadata_V1_P8e_ContractSpec()}
    set {_contractspec = newValue}
  }
  /// Returns true if `contractspec` has been explicitly set.
  var hasContractspec: Bool {return self._contractspec != nil}
  /// Clears the value of `contractspec`. Subsequent reads from it will return its default value.
  mutating func clearContractspec() {self._contractspec = nil}

  var signers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _contractspec: Provenance_Metadata_V1_P8e_ContractSpec? = nil
}

/// MsgWriteP8eContractSpecResponse is the response type for the Msg/WriteP8eContractSpec RPC method.
struct Provenance_Metadata_V1_MsgWriteP8eContractSpecResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// contract_spec_id_info contains information about the id/address of the contract specification that was added or
  /// updated.
  var contractSpecIDInfo: Provenance_Metadata_V1_ContractSpecIdInfo {
    get {return _contractSpecIDInfo ?? Provenance_Metadata_V1_ContractSpecIdInfo()}
    set {_contractSpecIDInfo = newValue}
  }
  /// Returns true if `contractSpecIDInfo` has been explicitly set.
  var hasContractSpecIDInfo: Bool {return self._contractSpecIDInfo != nil}
  /// Clears the value of `contractSpecIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearContractSpecIDInfo() {self._contractSpecIDInfo = nil}

  /// record_spec_id_infos contains information about the ids/addresses of the record specifications that were added or
  /// updated.
  var recordSpecIDInfos: [Provenance_Metadata_V1_RecordSpecIdInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _contractSpecIDInfo: Provenance_Metadata_V1_ContractSpecIdInfo? = nil
}

/// MsgP8eMemorializeContractRequest is the request type for the Msg/P8eMemorializeContract RPC method.
struct Provenance_Metadata_V1_MsgP8eMemorializeContractRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The scope id of the object being add or modified on blockchain.
  var scopeID: String = String()

  /// The uuid of the contract execution.
  var groupID: String = String()

  /// The scope specification id.
  var scopeSpecificationID: String = String()

  /// The new recitals for the scope.  Used in leu of Contract for direct ownership changes.
  var recitals: Provenance_Metadata_V1_P8e_Recitals {
    get {return _recitals ?? Provenance_Metadata_V1_P8e_Recitals()}
    set {_recitals = newValue}
  }
  /// Returns true if `recitals` has been explicitly set.
  var hasRecitals: Bool {return self._recitals != nil}
  /// Clears the value of `recitals`. Subsequent reads from it will return its default value.
  mutating func clearRecitals() {self._recitals = nil}

  /// The executed contract.
  var contract: Provenance_Metadata_V1_P8e_Contract {
    get {return _contract ?? Provenance_Metadata_V1_P8e_Contract()}
    set {_contract = newValue}
  }
  /// Returns true if `contract` has been explicitly set.
  var hasContract: Bool {return self._contract != nil}
  /// Clears the value of `contract`. Subsequent reads from it will return its default value.
  mutating func clearContract() {self._contract = nil}

  /// The contract signatures
  var signatures: Provenance_Metadata_V1_P8e_SignatureSet {
    get {return _signatures ?? Provenance_Metadata_V1_P8e_SignatureSet()}
    set {_signatures = newValue}
  }
  /// Returns true if `signatures` has been explicitly set.
  var hasSignatures: Bool {return self._signatures != nil}
  /// Clears the value of `signatures`. Subsequent reads from it will return its default value.
  mutating func clearSignatures() {self._signatures = nil}

  /// The bech32 address of the notary (ie the broadcaster of this message).
  var invoker: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _recitals: Provenance_Metadata_V1_P8e_Recitals? = nil
  fileprivate var _contract: Provenance_Metadata_V1_P8e_Contract? = nil
  fileprivate var _signatures: Provenance_Metadata_V1_P8e_SignatureSet? = nil
}

/// MsgP8eMemorializeContractResponse is the response type for the Msg/P8eMemorializeContract RPC method.
struct Provenance_Metadata_V1_MsgP8eMemorializeContractResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope_id_info contains information about the id/address of the scope that was added or updated.
  var scopeIDInfo: Provenance_Metadata_V1_ScopeIdInfo {
    get {return _storage._scopeIDInfo ?? Provenance_Metadata_V1_ScopeIdInfo()}
    set {_uniqueStorage()._scopeIDInfo = newValue}
  }
  /// Returns true if `scopeIDInfo` has been explicitly set.
  var hasScopeIDInfo: Bool {return _storage._scopeIDInfo != nil}
  /// Clears the value of `scopeIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearScopeIDInfo() {_uniqueStorage()._scopeIDInfo = nil}

  /// session_id_info contains information about the id/address of the session that was added or updated.
  var sessionIDInfo: Provenance_Metadata_V1_SessionIdInfo {
    get {return _storage._sessionIDInfo ?? Provenance_Metadata_V1_SessionIdInfo()}
    set {_uniqueStorage()._sessionIDInfo = newValue}
  }
  /// Returns true if `sessionIDInfo` has been explicitly set.
  var hasSessionIDInfo: Bool {return _storage._sessionIDInfo != nil}
  /// Clears the value of `sessionIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearSessionIDInfo() {_uniqueStorage()._sessionIDInfo = nil}

  /// record_id_infos contains information about the ids/addresses of the records that were added or updated.
  var recordIDInfos: [Provenance_Metadata_V1_RecordIdInfo] {
    get {return _storage._recordIDInfos}
    set {_uniqueStorage()._recordIDInfos = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MsgBindOSLocatorRequest is the request type for the Msg/BindOSLocator RPC method.
struct Provenance_Metadata_V1_MsgBindOSLocatorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The object locator to bind the address to bind to the URI.
  var locator: Provenance_Metadata_V1_ObjectStoreLocator {
    get {return _locator ?? Provenance_Metadata_V1_ObjectStoreLocator()}
    set {_locator = newValue}
  }
  /// Returns true if `locator` has been explicitly set.
  var hasLocator: Bool {return self._locator != nil}
  /// Clears the value of `locator`. Subsequent reads from it will return its default value.
  mutating func clearLocator() {self._locator = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _locator: Provenance_Metadata_V1_ObjectStoreLocator? = nil
}

/// MsgBindOSLocatorResponse is the response type for the Msg/BindOSLocator RPC method.
struct Provenance_Metadata_V1_MsgBindOSLocatorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var locator: Provenance_Metadata_V1_ObjectStoreLocator {
    get {return _locator ?? Provenance_Metadata_V1_ObjectStoreLocator()}
    set {_locator = newValue}
  }
  /// Returns true if `locator` has been explicitly set.
  var hasLocator: Bool {return self._locator != nil}
  /// Clears the value of `locator`. Subsequent reads from it will return its default value.
  mutating func clearLocator() {self._locator = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _locator: Provenance_Metadata_V1_ObjectStoreLocator? = nil
}

/// MsgDeleteOSLocatorRequest is the request type for the Msg/DeleteOSLocator RPC method.
struct Provenance_Metadata_V1_MsgDeleteOSLocatorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The record being removed
  var locator: Provenance_Metadata_V1_ObjectStoreLocator {
    get {return _locator ?? Provenance_Metadata_V1_ObjectStoreLocator()}
    set {_locator = newValue}
  }
  /// Returns true if `locator` has been explicitly set.
  var hasLocator: Bool {return self._locator != nil}
  /// Clears the value of `locator`. Subsequent reads from it will return its default value.
  mutating func clearLocator() {self._locator = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _locator: Provenance_Metadata_V1_ObjectStoreLocator? = nil
}

/// MsgDeleteOSLocatorResponse is the response type for the Msg/DeleteOSLocator RPC method.
struct Provenance_Metadata_V1_MsgDeleteOSLocatorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var locator: Provenance_Metadata_V1_ObjectStoreLocator {
    get {return _locator ?? Provenance_Metadata_V1_ObjectStoreLocator()}
    set {_locator = newValue}
  }
  /// Returns true if `locator` has been explicitly set.
  var hasLocator: Bool {return self._locator != nil}
  /// Clears the value of `locator`. Subsequent reads from it will return its default value.
  mutating func clearLocator() {self._locator = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _locator: Provenance_Metadata_V1_ObjectStoreLocator? = nil
}

/// MsgModifyOSLocatorRequest is the request type for the Msg/ModifyOSLocator RPC method.
struct Provenance_Metadata_V1_MsgModifyOSLocatorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The object locator to bind the address to bind to the URI.
  var locator: Provenance_Metadata_V1_ObjectStoreLocator {
    get {return _locator ?? Provenance_Metadata_V1_ObjectStoreLocator()}
    set {_locator = newValue}
  }
  /// Returns true if `locator` has been explicitly set.
  var hasLocator: Bool {return self._locator != nil}
  /// Clears the value of `locator`. Subsequent reads from it will return its default value.
  mutating func clearLocator() {self._locator = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _locator: Provenance_Metadata_V1_ObjectStoreLocator? = nil
}

/// MsgModifyOSLocatorResponse is the response type for the Msg/ModifyOSLocator RPC method.
struct Provenance_Metadata_V1_MsgModifyOSLocatorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var locator: Provenance_Metadata_V1_ObjectStoreLocator {
    get {return _locator ?? Provenance_Metadata_V1_ObjectStoreLocator()}
    set {_locator = newValue}
  }
  /// Returns true if `locator` has been explicitly set.
  var hasLocator: Bool {return self._locator != nil}
  /// Clears the value of `locator`. Subsequent reads from it will return its default value.
  mutating func clearLocator() {self._locator = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _locator: Provenance_Metadata_V1_ObjectStoreLocator? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "provenance.metadata.v1"

extension Provenance_Metadata_V1_MsgWriteScopeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWriteScopeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "signers"),
    3: .standard(proto: "scope_uuid"),
    4: .standard(proto: "spec_uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scope) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.signers) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.scopeUuid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.specUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._scope {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 2)
    }
    if !self.scopeUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeUuid, fieldNumber: 3)
    }
    if !self.specUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.specUuid, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgWriteScopeRequest, rhs: Provenance_Metadata_V1_MsgWriteScopeRequest) -> Bool {
    if lhs._scope != rhs._scope {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs.scopeUuid != rhs.scopeUuid {return false}
    if lhs.specUuid != rhs.specUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgWriteScopeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWriteScopeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_id_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scopeIDInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._scopeIDInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgWriteScopeResponse, rhs: Provenance_Metadata_V1_MsgWriteScopeResponse) -> Bool {
    if lhs._scopeIDInfo != rhs._scopeIDInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgDeleteScopeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteScopeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_id"),
    2: .same(proto: "signers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.scopeID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.signers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeID.isEmpty {
      try visitor.visitSingularBytesField(value: self.scopeID, fieldNumber: 1)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgDeleteScopeRequest, rhs: Provenance_Metadata_V1_MsgDeleteScopeRequest) -> Bool {
    if lhs.scopeID != rhs.scopeID {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgDeleteScopeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteScopeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgDeleteScopeResponse, rhs: Provenance_Metadata_V1_MsgDeleteScopeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgAddScopeDataAccessRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddScopeDataAccessRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_id"),
    2: .standard(proto: "data_access"),
    3: .same(proto: "signers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.scopeID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.dataAccess) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.signers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeID.isEmpty {
      try visitor.visitSingularBytesField(value: self.scopeID, fieldNumber: 1)
    }
    if !self.dataAccess.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dataAccess, fieldNumber: 2)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgAddScopeDataAccessRequest, rhs: Provenance_Metadata_V1_MsgAddScopeDataAccessRequest) -> Bool {
    if lhs.scopeID != rhs.scopeID {return false}
    if lhs.dataAccess != rhs.dataAccess {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgAddScopeDataAccessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddScopeDataAccessResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgAddScopeDataAccessResponse, rhs: Provenance_Metadata_V1_MsgAddScopeDataAccessResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgDeleteScopeDataAccessRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteScopeDataAccessRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_id"),
    2: .standard(proto: "data_access"),
    3: .same(proto: "signers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.scopeID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.dataAccess) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.signers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeID.isEmpty {
      try visitor.visitSingularBytesField(value: self.scopeID, fieldNumber: 1)
    }
    if !self.dataAccess.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dataAccess, fieldNumber: 2)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgDeleteScopeDataAccessRequest, rhs: Provenance_Metadata_V1_MsgDeleteScopeDataAccessRequest) -> Bool {
    if lhs.scopeID != rhs.scopeID {return false}
    if lhs.dataAccess != rhs.dataAccess {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgDeleteScopeDataAccessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteScopeDataAccessResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgDeleteScopeDataAccessResponse, rhs: Provenance_Metadata_V1_MsgDeleteScopeDataAccessResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgAddScopeOwnerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddScopeOwnerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_id"),
    2: .same(proto: "owners"),
    3: .same(proto: "signers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.scopeID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.owners) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.signers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeID.isEmpty {
      try visitor.visitSingularBytesField(value: self.scopeID, fieldNumber: 1)
    }
    if !self.owners.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.owners, fieldNumber: 2)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgAddScopeOwnerRequest, rhs: Provenance_Metadata_V1_MsgAddScopeOwnerRequest) -> Bool {
    if lhs.scopeID != rhs.scopeID {return false}
    if lhs.owners != rhs.owners {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgAddScopeOwnerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddScopeOwnerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgAddScopeOwnerResponse, rhs: Provenance_Metadata_V1_MsgAddScopeOwnerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgDeleteScopeOwnerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteScopeOwnerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_id"),
    2: .same(proto: "owners"),
    3: .same(proto: "signers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.scopeID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.owners) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.signers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeID.isEmpty {
      try visitor.visitSingularBytesField(value: self.scopeID, fieldNumber: 1)
    }
    if !self.owners.isEmpty {
      try visitor.visitRepeatedStringField(value: self.owners, fieldNumber: 2)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgDeleteScopeOwnerRequest, rhs: Provenance_Metadata_V1_MsgDeleteScopeOwnerRequest) -> Bool {
    if lhs.scopeID != rhs.scopeID {return false}
    if lhs.owners != rhs.owners {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgDeleteScopeOwnerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteScopeOwnerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgDeleteScopeOwnerResponse, rhs: Provenance_Metadata_V1_MsgDeleteScopeOwnerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgWriteSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWriteSessionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .same(proto: "signers"),
    3: .standard(proto: "session_id_components"),
    4: .standard(proto: "spec_uuid"),
  ]

  fileprivate class _StorageClass {
    var _session: Provenance_Metadata_V1_Session? = nil
    var _signers: [String] = []
    var _sessionIDComponents: Provenance_Metadata_V1_SessionIdComponents? = nil
    var _specUuid: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _session = source._session
      _signers = source._signers
      _sessionIDComponents = source._sessionIDComponents
      _specUuid = source._specUuid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._signers) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._sessionIDComponents) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._specUuid) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._signers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._signers, fieldNumber: 2)
      }
      if let v = _storage._sessionIDComponents {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._specUuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._specUuid, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgWriteSessionRequest, rhs: Provenance_Metadata_V1_MsgWriteSessionRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._session != rhs_storage._session {return false}
        if _storage._signers != rhs_storage._signers {return false}
        if _storage._sessionIDComponents != rhs_storage._sessionIDComponents {return false}
        if _storage._specUuid != rhs_storage._specUuid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_SessionIdComponents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionIdComponents"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_uuid"),
    2: .standard(proto: "scope_addr"),
    3: .standard(proto: "session_uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.scopeIdentifier != nil {try decoder.handleConflictingOneOf()}
          self.scopeIdentifier = .scopeUuid(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.scopeIdentifier != nil {try decoder.handleConflictingOneOf()}
          self.scopeIdentifier = .scopeAddr(v)
        }
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sessionUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.scopeIdentifier {
    case .scopeUuid?: try {
      guard case .scopeUuid(let v)? = self.scopeIdentifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .scopeAddr?: try {
      guard case .scopeAddr(let v)? = self.scopeIdentifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.sessionUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionUuid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_SessionIdComponents, rhs: Provenance_Metadata_V1_SessionIdComponents) -> Bool {
    if lhs.scopeIdentifier != rhs.scopeIdentifier {return false}
    if lhs.sessionUuid != rhs.sessionUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgWriteSessionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWriteSessionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sessionIDInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sessionIDInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgWriteSessionResponse, rhs: Provenance_Metadata_V1_MsgWriteSessionResponse) -> Bool {
    if lhs._sessionIDInfo != rhs._sessionIDInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgWriteRecordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWriteRecordRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "record"),
    2: .same(proto: "signers"),
    3: .standard(proto: "session_id_components"),
    4: .standard(proto: "contract_spec_uuid"),
    5: .same(proto: "parties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._record) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.signers) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sessionIDComponents) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.contractSpecUuid) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.parties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._record {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 2)
    }
    if let v = self._sessionIDComponents {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.contractSpecUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.contractSpecUuid, fieldNumber: 4)
    }
    if !self.parties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parties, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgWriteRecordRequest, rhs: Provenance_Metadata_V1_MsgWriteRecordRequest) -> Bool {
    if lhs._record != rhs._record {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs._sessionIDComponents != rhs._sessionIDComponents {return false}
    if lhs.contractSpecUuid != rhs.contractSpecUuid {return false}
    if lhs.parties != rhs.parties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgWriteRecordResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWriteRecordResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_id_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._recordIDInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._recordIDInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgWriteRecordResponse, rhs: Provenance_Metadata_V1_MsgWriteRecordResponse) -> Bool {
    if lhs._recordIDInfo != rhs._recordIDInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgDeleteRecordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteRecordRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_id"),
    2: .same(proto: "signers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.recordID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.signers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recordID.isEmpty {
      try visitor.visitSingularBytesField(value: self.recordID, fieldNumber: 1)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgDeleteRecordRequest, rhs: Provenance_Metadata_V1_MsgDeleteRecordRequest) -> Bool {
    if lhs.recordID != rhs.recordID {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgDeleteRecordResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteRecordResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgDeleteRecordResponse, rhs: Provenance_Metadata_V1_MsgDeleteRecordResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgWriteScopeSpecificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWriteScopeSpecificationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "specification"),
    2: .same(proto: "signers"),
    3: .standard(proto: "spec_uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._specification) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.signers) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.specUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._specification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 2)
    }
    if !self.specUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.specUuid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgWriteScopeSpecificationRequest, rhs: Provenance_Metadata_V1_MsgWriteScopeSpecificationRequest) -> Bool {
    if lhs._specification != rhs._specification {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs.specUuid != rhs.specUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgWriteScopeSpecificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWriteScopeSpecificationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_spec_id_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scopeSpecIDInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._scopeSpecIDInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgWriteScopeSpecificationResponse, rhs: Provenance_Metadata_V1_MsgWriteScopeSpecificationResponse) -> Bool {
    if lhs._scopeSpecIDInfo != rhs._scopeSpecIDInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgDeleteScopeSpecificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteScopeSpecificationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "specification_id"),
    2: .same(proto: "signers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.specificationID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.signers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.specificationID.isEmpty {
      try visitor.visitSingularBytesField(value: self.specificationID, fieldNumber: 1)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgDeleteScopeSpecificationRequest, rhs: Provenance_Metadata_V1_MsgDeleteScopeSpecificationRequest) -> Bool {
    if lhs.specificationID != rhs.specificationID {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgDeleteScopeSpecificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteScopeSpecificationResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgDeleteScopeSpecificationResponse, rhs: Provenance_Metadata_V1_MsgDeleteScopeSpecificationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgWriteContractSpecificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWriteContractSpecificationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "specification"),
    2: .same(proto: "signers"),
    3: .standard(proto: "spec_uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._specification) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.signers) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.specUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._specification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 2)
    }
    if !self.specUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.specUuid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgWriteContractSpecificationRequest, rhs: Provenance_Metadata_V1_MsgWriteContractSpecificationRequest) -> Bool {
    if lhs._specification != rhs._specification {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs.specUuid != rhs.specUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgWriteContractSpecificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWriteContractSpecificationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_spec_id_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._contractSpecIDInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._contractSpecIDInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgWriteContractSpecificationResponse, rhs: Provenance_Metadata_V1_MsgWriteContractSpecificationResponse) -> Bool {
    if lhs._contractSpecIDInfo != rhs._contractSpecIDInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgAddContractSpecToScopeSpecRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddContractSpecToScopeSpecRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_specification_id"),
    2: .standard(proto: "scope_specification_id"),
    3: .same(proto: "signers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.contractSpecificationID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.scopeSpecificationID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.signers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contractSpecificationID.isEmpty {
      try visitor.visitSingularBytesField(value: self.contractSpecificationID, fieldNumber: 1)
    }
    if !self.scopeSpecificationID.isEmpty {
      try visitor.visitSingularBytesField(value: self.scopeSpecificationID, fieldNumber: 2)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgAddContractSpecToScopeSpecRequest, rhs: Provenance_Metadata_V1_MsgAddContractSpecToScopeSpecRequest) -> Bool {
    if lhs.contractSpecificationID != rhs.contractSpecificationID {return false}
    if lhs.scopeSpecificationID != rhs.scopeSpecificationID {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgAddContractSpecToScopeSpecResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddContractSpecToScopeSpecResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgAddContractSpecToScopeSpecResponse, rhs: Provenance_Metadata_V1_MsgAddContractSpecToScopeSpecResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgDeleteContractSpecFromScopeSpecRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteContractSpecFromScopeSpecRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_specification_id"),
    2: .standard(proto: "scope_specification_id"),
    3: .same(proto: "signers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.contractSpecificationID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.scopeSpecificationID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.signers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contractSpecificationID.isEmpty {
      try visitor.visitSingularBytesField(value: self.contractSpecificationID, fieldNumber: 1)
    }
    if !self.scopeSpecificationID.isEmpty {
      try visitor.visitSingularBytesField(value: self.scopeSpecificationID, fieldNumber: 2)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgDeleteContractSpecFromScopeSpecRequest, rhs: Provenance_Metadata_V1_MsgDeleteContractSpecFromScopeSpecRequest) -> Bool {
    if lhs.contractSpecificationID != rhs.contractSpecificationID {return false}
    if lhs.scopeSpecificationID != rhs.scopeSpecificationID {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgDeleteContractSpecFromScopeSpecResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteContractSpecFromScopeSpecResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgDeleteContractSpecFromScopeSpecResponse, rhs: Provenance_Metadata_V1_MsgDeleteContractSpecFromScopeSpecResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgDeleteContractSpecificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteContractSpecificationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "specification_id"),
    2: .same(proto: "signers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.specificationID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.signers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.specificationID.isEmpty {
      try visitor.visitSingularBytesField(value: self.specificationID, fieldNumber: 1)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgDeleteContractSpecificationRequest, rhs: Provenance_Metadata_V1_MsgDeleteContractSpecificationRequest) -> Bool {
    if lhs.specificationID != rhs.specificationID {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgDeleteContractSpecificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteContractSpecificationResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgDeleteContractSpecificationResponse, rhs: Provenance_Metadata_V1_MsgDeleteContractSpecificationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgWriteRecordSpecificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWriteRecordSpecificationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "specification"),
    2: .same(proto: "signers"),
    3: .standard(proto: "contract_spec_uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._specification) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.signers) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contractSpecUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._specification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 2)
    }
    if !self.contractSpecUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.contractSpecUuid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgWriteRecordSpecificationRequest, rhs: Provenance_Metadata_V1_MsgWriteRecordSpecificationRequest) -> Bool {
    if lhs._specification != rhs._specification {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs.contractSpecUuid != rhs.contractSpecUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgWriteRecordSpecificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWriteRecordSpecificationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_spec_id_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._recordSpecIDInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._recordSpecIDInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgWriteRecordSpecificationResponse, rhs: Provenance_Metadata_V1_MsgWriteRecordSpecificationResponse) -> Bool {
    if lhs._recordSpecIDInfo != rhs._recordSpecIDInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgDeleteRecordSpecificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteRecordSpecificationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "specification_id"),
    2: .same(proto: "signers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.specificationID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.signers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.specificationID.isEmpty {
      try visitor.visitSingularBytesField(value: self.specificationID, fieldNumber: 1)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgDeleteRecordSpecificationRequest, rhs: Provenance_Metadata_V1_MsgDeleteRecordSpecificationRequest) -> Bool {
    if lhs.specificationID != rhs.specificationID {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgDeleteRecordSpecificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteRecordSpecificationResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgDeleteRecordSpecificationResponse, rhs: Provenance_Metadata_V1_MsgDeleteRecordSpecificationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgWriteP8eContractSpecRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWriteP8eContractSpecRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contractspec"),
    2: .same(proto: "signers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._contractspec) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.signers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._contractspec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgWriteP8eContractSpecRequest, rhs: Provenance_Metadata_V1_MsgWriteP8eContractSpecRequest) -> Bool {
    if lhs._contractspec != rhs._contractspec {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgWriteP8eContractSpecResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWriteP8eContractSpecResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_spec_id_info"),
    2: .standard(proto: "record_spec_id_infos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._contractSpecIDInfo) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.recordSpecIDInfos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._contractSpecIDInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.recordSpecIDInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recordSpecIDInfos, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgWriteP8eContractSpecResponse, rhs: Provenance_Metadata_V1_MsgWriteP8eContractSpecResponse) -> Bool {
    if lhs._contractSpecIDInfo != rhs._contractSpecIDInfo {return false}
    if lhs.recordSpecIDInfos != rhs.recordSpecIDInfos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgP8eMemorializeContractRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgP8eMemorializeContractRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_id"),
    2: .standard(proto: "group_id"),
    3: .standard(proto: "scope_specification_id"),
    4: .same(proto: "recitals"),
    5: .same(proto: "contract"),
    6: .same(proto: "signatures"),
    7: .same(proto: "invoker"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scopeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.scopeSpecificationID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._recitals) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._contract) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._signatures) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.invoker) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeID.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeID, fieldNumber: 1)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 2)
    }
    if !self.scopeSpecificationID.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeSpecificationID, fieldNumber: 3)
    }
    if let v = self._recitals {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._contract {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._signatures {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.invoker.isEmpty {
      try visitor.visitSingularStringField(value: self.invoker, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgP8eMemorializeContractRequest, rhs: Provenance_Metadata_V1_MsgP8eMemorializeContractRequest) -> Bool {
    if lhs.scopeID != rhs.scopeID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.scopeSpecificationID != rhs.scopeSpecificationID {return false}
    if lhs._recitals != rhs._recitals {return false}
    if lhs._contract != rhs._contract {return false}
    if lhs._signatures != rhs._signatures {return false}
    if lhs.invoker != rhs.invoker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgP8eMemorializeContractResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgP8eMemorializeContractResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_id_info"),
    2: .standard(proto: "session_id_info"),
    3: .standard(proto: "record_id_infos"),
  ]

  fileprivate class _StorageClass {
    var _scopeIDInfo: Provenance_Metadata_V1_ScopeIdInfo? = nil
    var _sessionIDInfo: Provenance_Metadata_V1_SessionIdInfo? = nil
    var _recordIDInfos: [Provenance_Metadata_V1_RecordIdInfo] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _scopeIDInfo = source._scopeIDInfo
      _sessionIDInfo = source._sessionIDInfo
      _recordIDInfos = source._recordIDInfos
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._scopeIDInfo) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._sessionIDInfo) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._recordIDInfos) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._scopeIDInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._sessionIDInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._recordIDInfos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._recordIDInfos, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgP8eMemorializeContractResponse, rhs: Provenance_Metadata_V1_MsgP8eMemorializeContractResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._scopeIDInfo != rhs_storage._scopeIDInfo {return false}
        if _storage._sessionIDInfo != rhs_storage._sessionIDInfo {return false}
        if _storage._recordIDInfos != rhs_storage._recordIDInfos {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgBindOSLocatorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBindOSLocatorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._locator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._locator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgBindOSLocatorRequest, rhs: Provenance_Metadata_V1_MsgBindOSLocatorRequest) -> Bool {
    if lhs._locator != rhs._locator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgBindOSLocatorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBindOSLocatorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._locator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._locator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgBindOSLocatorResponse, rhs: Provenance_Metadata_V1_MsgBindOSLocatorResponse) -> Bool {
    if lhs._locator != rhs._locator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgDeleteOSLocatorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteOSLocatorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._locator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._locator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgDeleteOSLocatorRequest, rhs: Provenance_Metadata_V1_MsgDeleteOSLocatorRequest) -> Bool {
    if lhs._locator != rhs._locator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgDeleteOSLocatorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteOSLocatorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._locator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._locator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgDeleteOSLocatorResponse, rhs: Provenance_Metadata_V1_MsgDeleteOSLocatorResponse) -> Bool {
    if lhs._locator != rhs._locator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgModifyOSLocatorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgModifyOSLocatorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._locator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._locator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgModifyOSLocatorRequest, rhs: Provenance_Metadata_V1_MsgModifyOSLocatorRequest) -> Bool {
    if lhs._locator != rhs._locator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_MsgModifyOSLocatorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgModifyOSLocatorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._locator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._locator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_MsgModifyOSLocatorResponse, rhs: Provenance_Metadata_V1_MsgModifyOSLocatorResponse) -> Bool {
    if lhs._locator != rhs._locator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
