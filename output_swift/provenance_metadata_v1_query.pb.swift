// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: provenance/metadata/v1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// QueryParamsRequest is the request type for the Query/Params RPC method.
struct Provenance_Metadata_V1_QueryParamsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryParamsResponse is the response type for the Query/Params RPC method.
struct Provenance_Metadata_V1_QueryParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// params defines the parameters of the module.
  var params: Provenance_Metadata_V1_Params {
    get {return _params ?? Provenance_Metadata_V1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_QueryParamsRequest {
    get {return _request ?? Provenance_Metadata_V1_QueryParamsRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Provenance_Metadata_V1_Params? = nil
  fileprivate var _request: Provenance_Metadata_V1_QueryParamsRequest? = nil
}

/// ScopeRequest is the request type for the Query/Scope RPC method.
struct Provenance_Metadata_V1_ScopeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.
  /// scope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel.
  var scopeID: String = String()

  /// session_addr is a bech32 session address, e.g.
  /// session1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr.
  var sessionAddr: String = String()

  /// record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.
  var recordAddr: String = String()

  /// include_sessions is a flag for whether or not the sessions in the scope should be included.
  var includeSessions: Bool = false

  /// include_records is a flag for whether or not the records in the scope should be included.
  var includeRecords: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ScopeResponse is the response type for the Query/Scope RPC method.
struct Provenance_Metadata_V1_ScopeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope is the wrapped scope result.
  var scope: Provenance_Metadata_V1_ScopeWrapper {
    get {return _storage._scope ?? Provenance_Metadata_V1_ScopeWrapper()}
    set {_uniqueStorage()._scope = newValue}
  }
  /// Returns true if `scope` has been explicitly set.
  var hasScope: Bool {return _storage._scope != nil}
  /// Clears the value of `scope`. Subsequent reads from it will return its default value.
  mutating func clearScope() {_uniqueStorage()._scope = nil}

  /// sessions is any number of wrapped sessions in this scope (if requested).
  var sessions: [Provenance_Metadata_V1_SessionWrapper] {
    get {return _storage._sessions}
    set {_uniqueStorage()._sessions = newValue}
  }

  /// records is any number of wrapped records in this scope (if requested).
  var records: [Provenance_Metadata_V1_RecordWrapper] {
    get {return _storage._records}
    set {_uniqueStorage()._records = newValue}
  }

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_ScopeRequest {
    get {return _storage._request ?? Provenance_Metadata_V1_ScopeRequest()}
    set {_uniqueStorage()._request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return _storage._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {_uniqueStorage()._request = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SessionWrapper contains a single scope and its uuid.
struct Provenance_Metadata_V1_ScopeWrapper {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope is the on-chain scope message.
  var scope: Provenance_Metadata_V1_Scope {
    get {return _scope ?? Provenance_Metadata_V1_Scope()}
    set {_scope = newValue}
  }
  /// Returns true if `scope` has been explicitly set.
  var hasScope: Bool {return self._scope != nil}
  /// Clears the value of `scope`. Subsequent reads from it will return its default value.
  mutating func clearScope() {self._scope = nil}

  /// scope_id_info contains information about the id/address of the scope.
  var scopeIDInfo: Provenance_Metadata_V1_ScopeIdInfo {
    get {return _scopeIDInfo ?? Provenance_Metadata_V1_ScopeIdInfo()}
    set {_scopeIDInfo = newValue}
  }
  /// Returns true if `scopeIDInfo` has been explicitly set.
  var hasScopeIDInfo: Bool {return self._scopeIDInfo != nil}
  /// Clears the value of `scopeIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearScopeIDInfo() {self._scopeIDInfo = nil}

  /// scope_spec_id_info contains information about the id/address of the scope specification.
  var scopeSpecIDInfo: Provenance_Metadata_V1_ScopeSpecIdInfo {
    get {return _scopeSpecIDInfo ?? Provenance_Metadata_V1_ScopeSpecIdInfo()}
    set {_scopeSpecIDInfo = newValue}
  }
  /// Returns true if `scopeSpecIDInfo` has been explicitly set.
  var hasScopeSpecIDInfo: Bool {return self._scopeSpecIDInfo != nil}
  /// Clears the value of `scopeSpecIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearScopeSpecIDInfo() {self._scopeSpecIDInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scope: Provenance_Metadata_V1_Scope? = nil
  fileprivate var _scopeIDInfo: Provenance_Metadata_V1_ScopeIdInfo? = nil
  fileprivate var _scopeSpecIDInfo: Provenance_Metadata_V1_ScopeSpecIdInfo? = nil
}

/// ScopesAllRequest is the request type for the Query/ScopesAll RPC method.
struct Provenance_Metadata_V1_ScopesAllRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pagination defines optional pagination parameters for the request.
  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// ScopesAllResponse is the response type for the Query/ScopesAll RPC method.
struct Provenance_Metadata_V1_ScopesAllResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scopes are the wrapped scopes.
  var scopes: [Provenance_Metadata_V1_ScopeWrapper] = []

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_ScopesAllRequest {
    get {return _request ?? Provenance_Metadata_V1_ScopesAllRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  /// pagination provides the pagination information of this response.
  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _request: Provenance_Metadata_V1_ScopesAllRequest? = nil
  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// SessionsRequest is the request type for the Query/Sessions RPC method.
struct Provenance_Metadata_V1_SessionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.
  /// scope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel.
  var scopeID: String = String()

  /// session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.
  /// session1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also
  /// provided.
  var sessionID: String = String()

  /// record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.
  var recordAddr: String = String()

  /// record_name is the name of the record to find the session for in the provided scope.
  var recordName: String = String()

  /// include_scope is a flag for whether or not the scope containing these sessions should be included.
  var includeScope: Bool = false

  /// include_records is a flag for whether or not the records in these sessions should be included.
  var includeRecords: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SessionsResponse is the response type for the Query/Sessions RPC method.
struct Provenance_Metadata_V1_SessionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope is the wrapped scope that holds these sessions (if requested).
  var scope: Provenance_Metadata_V1_ScopeWrapper {
    get {return _storage._scope ?? Provenance_Metadata_V1_ScopeWrapper()}
    set {_uniqueStorage()._scope = newValue}
  }
  /// Returns true if `scope` has been explicitly set.
  var hasScope: Bool {return _storage._scope != nil}
  /// Clears the value of `scope`. Subsequent reads from it will return its default value.
  mutating func clearScope() {_uniqueStorage()._scope = nil}

  /// sessions is any number of wrapped session results.
  var sessions: [Provenance_Metadata_V1_SessionWrapper] {
    get {return _storage._sessions}
    set {_uniqueStorage()._sessions = newValue}
  }

  /// records is any number of wrapped records contained in these sessions (if requested).
  var records: [Provenance_Metadata_V1_RecordWrapper] {
    get {return _storage._records}
    set {_uniqueStorage()._records = newValue}
  }

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_SessionsRequest {
    get {return _storage._request ?? Provenance_Metadata_V1_SessionsRequest()}
    set {_uniqueStorage()._request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return _storage._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {_uniqueStorage()._request = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SessionWrapper contains a single session and some extra identifiers for it.
struct Provenance_Metadata_V1_SessionWrapper {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// session is the on-chain session message.
  var session: Provenance_Metadata_V1_Session {
    get {return _storage._session ?? Provenance_Metadata_V1_Session()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// session_id_info contains information about the id/address of the session.
  var sessionIDInfo: Provenance_Metadata_V1_SessionIdInfo {
    get {return _storage._sessionIDInfo ?? Provenance_Metadata_V1_SessionIdInfo()}
    set {_uniqueStorage()._sessionIDInfo = newValue}
  }
  /// Returns true if `sessionIDInfo` has been explicitly set.
  var hasSessionIDInfo: Bool {return _storage._sessionIDInfo != nil}
  /// Clears the value of `sessionIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearSessionIDInfo() {_uniqueStorage()._sessionIDInfo = nil}

  /// contract_spec_id_info contains information about the id/address of the contract specification.
  var contractSpecIDInfo: Provenance_Metadata_V1_ContractSpecIdInfo {
    get {return _storage._contractSpecIDInfo ?? Provenance_Metadata_V1_ContractSpecIdInfo()}
    set {_uniqueStorage()._contractSpecIDInfo = newValue}
  }
  /// Returns true if `contractSpecIDInfo` has been explicitly set.
  var hasContractSpecIDInfo: Bool {return _storage._contractSpecIDInfo != nil}
  /// Clears the value of `contractSpecIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearContractSpecIDInfo() {_uniqueStorage()._contractSpecIDInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SessionsAllRequest is the request type for the Query/SessionsAll RPC method.
struct Provenance_Metadata_V1_SessionsAllRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pagination defines optional pagination parameters for the request.
  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// SessionsAllResponse is the response type for the Query/SessionsAll RPC method.
struct Provenance_Metadata_V1_SessionsAllResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// sessions are the wrapped sessions.
  var sessions: [Provenance_Metadata_V1_SessionWrapper] = []

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_SessionsAllRequest {
    get {return _request ?? Provenance_Metadata_V1_SessionsAllRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  /// pagination provides the pagination information of this response.
  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _request: Provenance_Metadata_V1_SessionsAllRequest? = nil
  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// RecordsRequest is the request type for the Query/Records RPC method.
struct Provenance_Metadata_V1_RecordsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.
  var recordAddr: String = String()

  /// scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.
  /// scope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel.
  var scopeID: String = String()

  /// session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.
  /// session1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also
  /// provided.
  var sessionID: String = String()

  /// name is the name of the record to look for
  var name: String = String()

  /// include_scope is a flag for whether or not the scope containing these records should be included.
  var includeScope: Bool = false

  /// include_sessions is a flag for whether or not the sessions containing these records should be included.
  var includeSessions: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RecordsResponse is the response type for the Query/Records RPC method.
struct Provenance_Metadata_V1_RecordsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope is the wrapped scope that holds these records (if requested).
  var scope: Provenance_Metadata_V1_ScopeWrapper {
    get {return _storage._scope ?? Provenance_Metadata_V1_ScopeWrapper()}
    set {_uniqueStorage()._scope = newValue}
  }
  /// Returns true if `scope` has been explicitly set.
  var hasScope: Bool {return _storage._scope != nil}
  /// Clears the value of `scope`. Subsequent reads from it will return its default value.
  mutating func clearScope() {_uniqueStorage()._scope = nil}

  /// sessions is any number of wrapped sessions that hold these records (if requested).
  var sessions: [Provenance_Metadata_V1_SessionWrapper] {
    get {return _storage._sessions}
    set {_uniqueStorage()._sessions = newValue}
  }

  /// records is any number of wrapped record results.
  var records: [Provenance_Metadata_V1_RecordWrapper] {
    get {return _storage._records}
    set {_uniqueStorage()._records = newValue}
  }

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_RecordsRequest {
    get {return _storage._request ?? Provenance_Metadata_V1_RecordsRequest()}
    set {_uniqueStorage()._request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return _storage._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {_uniqueStorage()._request = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RecordWrapper contains a single record and some extra identifiers for it.
struct Provenance_Metadata_V1_RecordWrapper {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// record is the on-chain record message.
  var record: Provenance_Metadata_V1_Record {
    get {return _storage._record ?? Provenance_Metadata_V1_Record()}
    set {_uniqueStorage()._record = newValue}
  }
  /// Returns true if `record` has been explicitly set.
  var hasRecord: Bool {return _storage._record != nil}
  /// Clears the value of `record`. Subsequent reads from it will return its default value.
  mutating func clearRecord() {_uniqueStorage()._record = nil}

  /// record_id_info contains information about the id/address of the record.
  var recordIDInfo: Provenance_Metadata_V1_RecordIdInfo {
    get {return _storage._recordIDInfo ?? Provenance_Metadata_V1_RecordIdInfo()}
    set {_uniqueStorage()._recordIDInfo = newValue}
  }
  /// Returns true if `recordIDInfo` has been explicitly set.
  var hasRecordIDInfo: Bool {return _storage._recordIDInfo != nil}
  /// Clears the value of `recordIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearRecordIDInfo() {_uniqueStorage()._recordIDInfo = nil}

  /// record_spec_id_info contains information about the id/address of the record specification.
  var recordSpecIDInfo: Provenance_Metadata_V1_RecordSpecIdInfo {
    get {return _storage._recordSpecIDInfo ?? Provenance_Metadata_V1_RecordSpecIdInfo()}
    set {_uniqueStorage()._recordSpecIDInfo = newValue}
  }
  /// Returns true if `recordSpecIDInfo` has been explicitly set.
  var hasRecordSpecIDInfo: Bool {return _storage._recordSpecIDInfo != nil}
  /// Clears the value of `recordSpecIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearRecordSpecIDInfo() {_uniqueStorage()._recordSpecIDInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RecordsAllRequest is the request type for the Query/RecordsAll RPC method.
struct Provenance_Metadata_V1_RecordsAllRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pagination defines optional pagination parameters for the request.
  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// RecordsAllResponse is the response type for the Query/RecordsAll RPC method.
struct Provenance_Metadata_V1_RecordsAllResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// records are the wrapped records.
  var records: [Provenance_Metadata_V1_RecordWrapper] = []

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_RecordsAllRequest {
    get {return _request ?? Provenance_Metadata_V1_RecordsAllRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  /// pagination provides the pagination information of this response.
  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _request: Provenance_Metadata_V1_RecordsAllRequest? = nil
  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// OwnershipRequest is the request type for the Query/Ownership RPC method.
struct Provenance_Metadata_V1_OwnershipRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  /// pagination defines optional pagination parameters for the request.
  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// OwnershipResponse is the response type for the Query/Ownership RPC method.
struct Provenance_Metadata_V1_OwnershipResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of scope ids (uuid) associated with the given address.
  var scopeUuids: [String] = []

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_OwnershipRequest {
    get {return _request ?? Provenance_Metadata_V1_OwnershipRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  /// pagination provides the pagination information of this response.
  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _request: Provenance_Metadata_V1_OwnershipRequest? = nil
  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// ValueOwnershipRequest is the request type for the Query/ValueOwnership RPC method.
struct Provenance_Metadata_V1_ValueOwnershipRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  /// pagination defines optional pagination parameters for the request.
  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// ValueOwnershipResponse is the response type for the Query/ValueOwnership RPC method.
struct Provenance_Metadata_V1_ValueOwnershipResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of scope ids (uuid) associated with the given address.
  var scopeUuids: [String] = []

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_ValueOwnershipRequest {
    get {return _request ?? Provenance_Metadata_V1_ValueOwnershipRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  /// pagination provides the pagination information of this response.
  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _request: Provenance_Metadata_V1_ValueOwnershipRequest? = nil
  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// ScopeSpecificationRequest is the request type for the Query/ScopeSpecification RPC method.
struct Provenance_Metadata_V1_ScopeSpecificationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// specification_id can either be a uuid, e.g. dc83ea70-eacd-40fe-9adf-1cf6148bf8a2 or a bech32 scope specification
  /// address, e.g. scopespec1qnwg86nsatx5pl56muw0v9ytlz3qu3jx6m.
  var specificationID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ScopeSpecificationResponse is the response type for the Query/ScopeSpecification RPC method.
struct Provenance_Metadata_V1_ScopeSpecificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope_specification is the wrapped scope specification.
  var scopeSpecification: Provenance_Metadata_V1_ScopeSpecificationWrapper {
    get {return _scopeSpecification ?? Provenance_Metadata_V1_ScopeSpecificationWrapper()}
    set {_scopeSpecification = newValue}
  }
  /// Returns true if `scopeSpecification` has been explicitly set.
  var hasScopeSpecification: Bool {return self._scopeSpecification != nil}
  /// Clears the value of `scopeSpecification`. Subsequent reads from it will return its default value.
  mutating func clearScopeSpecification() {self._scopeSpecification = nil}

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_ScopeSpecificationRequest {
    get {return _request ?? Provenance_Metadata_V1_ScopeSpecificationRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scopeSpecification: Provenance_Metadata_V1_ScopeSpecificationWrapper? = nil
  fileprivate var _request: Provenance_Metadata_V1_ScopeSpecificationRequest? = nil
}

/// ScopeSpecificationWrapper contains a single scope specification and some extra identifiers for it.
struct Provenance_Metadata_V1_ScopeSpecificationWrapper {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// specification is the on-chain scope specification message.
  var specification: Provenance_Metadata_V1_ScopeSpecification {
    get {return _specification ?? Provenance_Metadata_V1_ScopeSpecification()}
    set {_specification = newValue}
  }
  /// Returns true if `specification` has been explicitly set.
  var hasSpecification: Bool {return self._specification != nil}
  /// Clears the value of `specification`. Subsequent reads from it will return its default value.
  mutating func clearSpecification() {self._specification = nil}

  /// scope_spec_id_info contains information about the id/address of the scope specification.
  var scopeSpecIDInfo: Provenance_Metadata_V1_ScopeSpecIdInfo {
    get {return _scopeSpecIDInfo ?? Provenance_Metadata_V1_ScopeSpecIdInfo()}
    set {_scopeSpecIDInfo = newValue}
  }
  /// Returns true if `scopeSpecIDInfo` has been explicitly set.
  var hasScopeSpecIDInfo: Bool {return self._scopeSpecIDInfo != nil}
  /// Clears the value of `scopeSpecIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearScopeSpecIDInfo() {self._scopeSpecIDInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _specification: Provenance_Metadata_V1_ScopeSpecification? = nil
  fileprivate var _scopeSpecIDInfo: Provenance_Metadata_V1_ScopeSpecIdInfo? = nil
}

/// ScopeSpecificationsAllRequest is the request type for the Query/ScopeSpecificationsAll RPC method.
struct Provenance_Metadata_V1_ScopeSpecificationsAllRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pagination defines optional pagination parameters for the request.
  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// ScopeSpecificationsAllResponse is the response type for the Query/ScopeSpecificationsAll RPC method.
struct Provenance_Metadata_V1_ScopeSpecificationsAllResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope_specifications are the wrapped scope specifications.
  var scopeSpecifications: [Provenance_Metadata_V1_ScopeSpecificationWrapper] = []

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_ScopeSpecificationsAllRequest {
    get {return _request ?? Provenance_Metadata_V1_ScopeSpecificationsAllRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  /// pagination provides the pagination information of this response.
  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _request: Provenance_Metadata_V1_ScopeSpecificationsAllRequest? = nil
  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// ContractSpecificationRequest is the request type for the Query/ContractSpecification RPC method.
struct Provenance_Metadata_V1_ContractSpecificationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84 or a bech32 contract specification
  /// address, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn.
  /// It can also be a record specification address, e.g.
  /// recspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44.
  var specificationID: String = String()

  /// include_record_specs is a flag for whether or not the record specifications in this contract specification should
  /// be included in the result.
  var includeRecordSpecs: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ContractSpecificationResponse is the response type for the Query/ContractSpecification RPC method.
struct Provenance_Metadata_V1_ContractSpecificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// contract_specification is the wrapped contract specification.
  var contractSpecification: Provenance_Metadata_V1_ContractSpecificationWrapper {
    get {return _storage._contractSpecification ?? Provenance_Metadata_V1_ContractSpecificationWrapper()}
    set {_uniqueStorage()._contractSpecification = newValue}
  }
  /// Returns true if `contractSpecification` has been explicitly set.
  var hasContractSpecification: Bool {return _storage._contractSpecification != nil}
  /// Clears the value of `contractSpecification`. Subsequent reads from it will return its default value.
  mutating func clearContractSpecification() {_uniqueStorage()._contractSpecification = nil}

  /// record_specifications is any number or wrapped record specifications associated with this contract_specification
  /// (if requested).
  var recordSpecifications: [Provenance_Metadata_V1_RecordSpecificationWrapper] {
    get {return _storage._recordSpecifications}
    set {_uniqueStorage()._recordSpecifications = newValue}
  }

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_ContractSpecificationRequest {
    get {return _storage._request ?? Provenance_Metadata_V1_ContractSpecificationRequest()}
    set {_uniqueStorage()._request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return _storage._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {_uniqueStorage()._request = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ContractSpecificationWrapper contains a single contract specification and some extra identifiers for it.
struct Provenance_Metadata_V1_ContractSpecificationWrapper {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// specification is the on-chain contract specification message.
  var specification: Provenance_Metadata_V1_ContractSpecification {
    get {return _specification ?? Provenance_Metadata_V1_ContractSpecification()}
    set {_specification = newValue}
  }
  /// Returns true if `specification` has been explicitly set.
  var hasSpecification: Bool {return self._specification != nil}
  /// Clears the value of `specification`. Subsequent reads from it will return its default value.
  mutating func clearSpecification() {self._specification = nil}

  /// contract_spec_id_info contains information about the id/address of the contract specification.
  var contractSpecIDInfo: Provenance_Metadata_V1_ContractSpecIdInfo {
    get {return _contractSpecIDInfo ?? Provenance_Metadata_V1_ContractSpecIdInfo()}
    set {_contractSpecIDInfo = newValue}
  }
  /// Returns true if `contractSpecIDInfo` has been explicitly set.
  var hasContractSpecIDInfo: Bool {return self._contractSpecIDInfo != nil}
  /// Clears the value of `contractSpecIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearContractSpecIDInfo() {self._contractSpecIDInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _specification: Provenance_Metadata_V1_ContractSpecification? = nil
  fileprivate var _contractSpecIDInfo: Provenance_Metadata_V1_ContractSpecIdInfo? = nil
}

/// ContractSpecificationsAllRequest is the request type for the Query/ContractSpecificationsAll RPC method.
struct Provenance_Metadata_V1_ContractSpecificationsAllRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pagination defines optional pagination parameters for the request.
  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// ContractSpecificationsAllResponse is the response type for the Query/ContractSpecificationsAll RPC method.
struct Provenance_Metadata_V1_ContractSpecificationsAllResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// contract_specifications are the wrapped contract specifications.
  var contractSpecifications: [Provenance_Metadata_V1_ContractSpecificationWrapper] = []

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_ContractSpecificationsAllRequest {
    get {return _request ?? Provenance_Metadata_V1_ContractSpecificationsAllRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  /// pagination provides the pagination information of this response.
  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _request: Provenance_Metadata_V1_ContractSpecificationsAllRequest? = nil
  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// RecordSpecificationsForContractSpecificationRequest is the request type for the
/// Query/RecordSpecificationsForContractSpecification RPC method.
struct Provenance_Metadata_V1_RecordSpecificationsForContractSpecificationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84 or a bech32 contract specification
  /// address, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn.
  /// It can also be a record specification address, e.g.
  /// recspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44.
  var specificationID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RecordSpecificationsForContractSpecificationResponse is the response type for the
/// Query/RecordSpecificationsForContractSpecification RPC method.
struct Provenance_Metadata_V1_RecordSpecificationsForContractSpecificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// record_specifications is any number of wrapped record specifications associated with this contract_specification.
  var recordSpecifications: [Provenance_Metadata_V1_RecordSpecificationWrapper] = []

  /// contract_specification_uuid is the uuid of this contract specification.
  var contractSpecificationUuid: String = String()

  /// contract_specification_addr is the contract specification address as a bech32 encoded string.
  var contractSpecificationAddr: String = String()

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_RecordSpecificationsForContractSpecificationRequest {
    get {return _request ?? Provenance_Metadata_V1_RecordSpecificationsForContractSpecificationRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _request: Provenance_Metadata_V1_RecordSpecificationsForContractSpecificationRequest? = nil
}

/// RecordSpecificationRequest is the request type for the Query/RecordSpecification RPC method.
struct Provenance_Metadata_V1_RecordSpecificationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84 or a bech32 contract specification
  /// address, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn.
  /// It can also be a record specification address, e.g.
  /// recspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44.
  var specificationID: String = String()

  /// name is the name of the record to look up.
  /// It is required if the specification_id is a uuid or contract specification address.
  /// It is ignored if the specification_id is a record specification address.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RecordSpecificationResponse is the response type for the Query/RecordSpecification RPC method.
struct Provenance_Metadata_V1_RecordSpecificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// record_specification is the wrapped record specification.
  var recordSpecification: Provenance_Metadata_V1_RecordSpecificationWrapper {
    get {return _storage._recordSpecification ?? Provenance_Metadata_V1_RecordSpecificationWrapper()}
    set {_uniqueStorage()._recordSpecification = newValue}
  }
  /// Returns true if `recordSpecification` has been explicitly set.
  var hasRecordSpecification: Bool {return _storage._recordSpecification != nil}
  /// Clears the value of `recordSpecification`. Subsequent reads from it will return its default value.
  mutating func clearRecordSpecification() {_uniqueStorage()._recordSpecification = nil}

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_RecordSpecificationRequest {
    get {return _storage._request ?? Provenance_Metadata_V1_RecordSpecificationRequest()}
    set {_uniqueStorage()._request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return _storage._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {_uniqueStorage()._request = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RecordSpecificationWrapper contains a single record specification and some extra identifiers for it.
struct Provenance_Metadata_V1_RecordSpecificationWrapper {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// specification is the on-chain record specification message.
  var specification: Provenance_Metadata_V1_RecordSpecification {
    get {return _specification ?? Provenance_Metadata_V1_RecordSpecification()}
    set {_specification = newValue}
  }
  /// Returns true if `specification` has been explicitly set.
  var hasSpecification: Bool {return self._specification != nil}
  /// Clears the value of `specification`. Subsequent reads from it will return its default value.
  mutating func clearSpecification() {self._specification = nil}

  /// record_spec_id_info contains information about the id/address of the record specification.
  var recordSpecIDInfo: Provenance_Metadata_V1_RecordSpecIdInfo {
    get {return _recordSpecIDInfo ?? Provenance_Metadata_V1_RecordSpecIdInfo()}
    set {_recordSpecIDInfo = newValue}
  }
  /// Returns true if `recordSpecIDInfo` has been explicitly set.
  var hasRecordSpecIDInfo: Bool {return self._recordSpecIDInfo != nil}
  /// Clears the value of `recordSpecIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearRecordSpecIDInfo() {self._recordSpecIDInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _specification: Provenance_Metadata_V1_RecordSpecification? = nil
  fileprivate var _recordSpecIDInfo: Provenance_Metadata_V1_RecordSpecIdInfo? = nil
}

/// RecordSpecificationsAllRequest is the request type for the Query/RecordSpecificationsAll RPC method.
struct Provenance_Metadata_V1_RecordSpecificationsAllRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pagination defines optional pagination parameters for the request.
  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// RecordSpecificationsAllResponse is the response type for the Query/RecordSpecificationsAll RPC method.
struct Provenance_Metadata_V1_RecordSpecificationsAllResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// record_specifications are the wrapped record specifications.
  var recordSpecifications: [Provenance_Metadata_V1_RecordSpecificationWrapper] = []

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_RecordSpecificationsAllRequest {
    get {return _request ?? Provenance_Metadata_V1_RecordSpecificationsAllRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  /// pagination provides the pagination information of this response.
  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _request: Provenance_Metadata_V1_RecordSpecificationsAllRequest? = nil
  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// OSLocatorParamsRequest is the request type for the Query/OSLocatorParams RPC method.
struct Provenance_Metadata_V1_OSLocatorParamsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OSLocatorParamsResponse is the response type for the Query/OSLocatorParams RPC method.
struct Provenance_Metadata_V1_OSLocatorParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// params defines the parameters of the module.
  var params: Provenance_Metadata_V1_OSLocatorParams {
    get {return _params ?? Provenance_Metadata_V1_OSLocatorParams()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_OSLocatorParamsRequest {
    get {return _request ?? Provenance_Metadata_V1_OSLocatorParamsRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Provenance_Metadata_V1_OSLocatorParams? = nil
  fileprivate var _request: Provenance_Metadata_V1_OSLocatorParamsRequest? = nil
}

/// OSLocatorRequest is the request type for the Query/OSLocator RPC method.
struct Provenance_Metadata_V1_OSLocatorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var owner: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OSLocatorResponse is the response type for the Query/OSLocator RPC method.
struct Provenance_Metadata_V1_OSLocatorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var locator: Provenance_Metadata_V1_ObjectStoreLocator {
    get {return _locator ?? Provenance_Metadata_V1_ObjectStoreLocator()}
    set {_locator = newValue}
  }
  /// Returns true if `locator` has been explicitly set.
  var hasLocator: Bool {return self._locator != nil}
  /// Clears the value of `locator`. Subsequent reads from it will return its default value.
  mutating func clearLocator() {self._locator = nil}

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_OSLocatorRequest {
    get {return _request ?? Provenance_Metadata_V1_OSLocatorRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _locator: Provenance_Metadata_V1_ObjectStoreLocator? = nil
  fileprivate var _request: Provenance_Metadata_V1_OSLocatorRequest? = nil
}

/// OSLocatorsByURIRequest is the request type for the Query/OSLocatorsByURI RPC method.
struct Provenance_Metadata_V1_OSLocatorsByURIRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uri: String = String()

  /// pagination defines optional pagination parameters for the request.
  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// OSLocatorsByURIResponse is the response type for the Query/OSLocatorsByURI RPC method.
struct Provenance_Metadata_V1_OSLocatorsByURIResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var locators: [Provenance_Metadata_V1_ObjectStoreLocator] = []

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_OSLocatorsByURIRequest {
    get {return _request ?? Provenance_Metadata_V1_OSLocatorsByURIRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  /// pagination provides the pagination information of this response.
  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _request: Provenance_Metadata_V1_OSLocatorsByURIRequest? = nil
  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// OSLocatorsByScopeRequest is the request type for the Query/OSLocatorsByScope RPC method.
struct Provenance_Metadata_V1_OSLocatorsByScopeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scopeID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OSLocatorsByScopeResponse is the response type for the Query/OSLocatorsByScope RPC method.
struct Provenance_Metadata_V1_OSLocatorsByScopeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var locators: [Provenance_Metadata_V1_ObjectStoreLocator] = []

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_OSLocatorsByScopeRequest {
    get {return _request ?? Provenance_Metadata_V1_OSLocatorsByScopeRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _request: Provenance_Metadata_V1_OSLocatorsByScopeRequest? = nil
}

/// OSAllLocatorsRequest is the request type for the Query/OSAllLocators RPC method.
struct Provenance_Metadata_V1_OSAllLocatorsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pagination defines optional pagination parameters for the request.
  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// OSAllLocatorsResponse is the response type for the Query/OSAllLocators RPC method.
struct Provenance_Metadata_V1_OSAllLocatorsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var locators: [Provenance_Metadata_V1_ObjectStoreLocator] = []

  /// request is a copy of the request that generated these results.
  var request: Provenance_Metadata_V1_OSAllLocatorsRequest {
    get {return _request ?? Provenance_Metadata_V1_OSAllLocatorsRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  /// pagination provides the pagination information of this response.
  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _request: Provenance_Metadata_V1_OSAllLocatorsRequest? = nil
  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "provenance.metadata.v1"

extension Provenance_Metadata_V1_QueryParamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_QueryParamsRequest, rhs: Provenance_Metadata_V1_QueryParamsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_QueryParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
    98: .same(proto: "request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      case 98: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_QueryParamsResponse, rhs: Provenance_Metadata_V1_QueryParamsResponse) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_ScopeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScopeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_id"),
    2: .standard(proto: "session_addr"),
    3: .standard(proto: "record_addr"),
    10: .standard(proto: "include_sessions"),
    11: .standard(proto: "include_records"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scopeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionAddr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.recordAddr) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.includeSessions) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.includeRecords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeID.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeID, fieldNumber: 1)
    }
    if !self.sessionAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionAddr, fieldNumber: 2)
    }
    if !self.recordAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.recordAddr, fieldNumber: 3)
    }
    if self.includeSessions != false {
      try visitor.visitSingularBoolField(value: self.includeSessions, fieldNumber: 10)
    }
    if self.includeRecords != false {
      try visitor.visitSingularBoolField(value: self.includeRecords, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_ScopeRequest, rhs: Provenance_Metadata_V1_ScopeRequest) -> Bool {
    if lhs.scopeID != rhs.scopeID {return false}
    if lhs.sessionAddr != rhs.sessionAddr {return false}
    if lhs.recordAddr != rhs.recordAddr {return false}
    if lhs.includeSessions != rhs.includeSessions {return false}
    if lhs.includeRecords != rhs.includeRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_ScopeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScopeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "sessions"),
    3: .same(proto: "records"),
    98: .same(proto: "request"),
  ]

  fileprivate class _StorageClass {
    var _scope: Provenance_Metadata_V1_ScopeWrapper? = nil
    var _sessions: [Provenance_Metadata_V1_SessionWrapper] = []
    var _records: [Provenance_Metadata_V1_RecordWrapper] = []
    var _request: Provenance_Metadata_V1_ScopeRequest? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _scope = source._scope
      _sessions = source._sessions
      _records = source._records
      _request = source._request
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._scope) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._sessions) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._records) }()
        case 98: try { try decoder.decodeSingularMessageField(value: &_storage._request) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._scope {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._sessions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sessions, fieldNumber: 2)
      }
      if !_storage._records.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._records, fieldNumber: 3)
      }
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_ScopeResponse, rhs: Provenance_Metadata_V1_ScopeResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._scope != rhs_storage._scope {return false}
        if _storage._sessions != rhs_storage._sessions {return false}
        if _storage._records != rhs_storage._records {return false}
        if _storage._request != rhs_storage._request {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_ScopeWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScopeWrapper"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .standard(proto: "scope_id_info"),
    3: .standard(proto: "scope_spec_id_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scope) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._scopeIDInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._scopeSpecIDInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._scope {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._scopeIDInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._scopeSpecIDInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_ScopeWrapper, rhs: Provenance_Metadata_V1_ScopeWrapper) -> Bool {
    if lhs._scope != rhs._scope {return false}
    if lhs._scopeIDInfo != rhs._scopeIDInfo {return false}
    if lhs._scopeSpecIDInfo != rhs._scopeSpecIDInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_ScopesAllRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScopesAllRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_ScopesAllRequest, rhs: Provenance_Metadata_V1_ScopesAllRequest) -> Bool {
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_ScopesAllResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScopesAllResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scopes"),
    98: .same(proto: "request"),
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.scopes) }()
      case 98: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.scopes, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_ScopesAllResponse, rhs: Provenance_Metadata_V1_ScopesAllResponse) -> Bool {
    if lhs.scopes != rhs.scopes {return false}
    if lhs._request != rhs._request {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_SessionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_id"),
    2: .standard(proto: "session_id"),
    3: .standard(proto: "record_addr"),
    4: .standard(proto: "record_name"),
    10: .standard(proto: "include_scope"),
    11: .standard(proto: "include_records"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scopeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.recordAddr) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.recordName) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.includeScope) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.includeRecords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeID.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeID, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    if !self.recordAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.recordAddr, fieldNumber: 3)
    }
    if !self.recordName.isEmpty {
      try visitor.visitSingularStringField(value: self.recordName, fieldNumber: 4)
    }
    if self.includeScope != false {
      try visitor.visitSingularBoolField(value: self.includeScope, fieldNumber: 10)
    }
    if self.includeRecords != false {
      try visitor.visitSingularBoolField(value: self.includeRecords, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_SessionsRequest, rhs: Provenance_Metadata_V1_SessionsRequest) -> Bool {
    if lhs.scopeID != rhs.scopeID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.recordAddr != rhs.recordAddr {return false}
    if lhs.recordName != rhs.recordName {return false}
    if lhs.includeScope != rhs.includeScope {return false}
    if lhs.includeRecords != rhs.includeRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_SessionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "sessions"),
    3: .same(proto: "records"),
    98: .same(proto: "request"),
  ]

  fileprivate class _StorageClass {
    var _scope: Provenance_Metadata_V1_ScopeWrapper? = nil
    var _sessions: [Provenance_Metadata_V1_SessionWrapper] = []
    var _records: [Provenance_Metadata_V1_RecordWrapper] = []
    var _request: Provenance_Metadata_V1_SessionsRequest? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _scope = source._scope
      _sessions = source._sessions
      _records = source._records
      _request = source._request
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._scope) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._sessions) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._records) }()
        case 98: try { try decoder.decodeSingularMessageField(value: &_storage._request) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._scope {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._sessions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sessions, fieldNumber: 2)
      }
      if !_storage._records.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._records, fieldNumber: 3)
      }
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_SessionsResponse, rhs: Provenance_Metadata_V1_SessionsResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._scope != rhs_storage._scope {return false}
        if _storage._sessions != rhs_storage._sessions {return false}
        if _storage._records != rhs_storage._records {return false}
        if _storage._request != rhs_storage._request {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_SessionWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionWrapper"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .standard(proto: "session_id_info"),
    3: .standard(proto: "contract_spec_id_info"),
  ]

  fileprivate class _StorageClass {
    var _session: Provenance_Metadata_V1_Session? = nil
    var _sessionIDInfo: Provenance_Metadata_V1_SessionIdInfo? = nil
    var _contractSpecIDInfo: Provenance_Metadata_V1_ContractSpecIdInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _session = source._session
      _sessionIDInfo = source._sessionIDInfo
      _contractSpecIDInfo = source._contractSpecIDInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._sessionIDInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._contractSpecIDInfo) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._sessionIDInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._contractSpecIDInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_SessionWrapper, rhs: Provenance_Metadata_V1_SessionWrapper) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._session != rhs_storage._session {return false}
        if _storage._sessionIDInfo != rhs_storage._sessionIDInfo {return false}
        if _storage._contractSpecIDInfo != rhs_storage._contractSpecIDInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_SessionsAllRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionsAllRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_SessionsAllRequest, rhs: Provenance_Metadata_V1_SessionsAllRequest) -> Bool {
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_SessionsAllResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionsAllResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sessions"),
    98: .same(proto: "request"),
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sessions) }()
      case 98: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sessions, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_SessionsAllResponse, rhs: Provenance_Metadata_V1_SessionsAllResponse) -> Bool {
    if lhs.sessions != rhs.sessions {return false}
    if lhs._request != rhs._request {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_RecordsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_addr"),
    2: .standard(proto: "scope_id"),
    3: .standard(proto: "session_id"),
    4: .same(proto: "name"),
    10: .standard(proto: "include_scope"),
    11: .standard(proto: "include_sessions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recordAddr) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scopeID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.includeScope) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.includeSessions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recordAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.recordAddr, fieldNumber: 1)
    }
    if !self.scopeID.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeID, fieldNumber: 2)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if self.includeScope != false {
      try visitor.visitSingularBoolField(value: self.includeScope, fieldNumber: 10)
    }
    if self.includeSessions != false {
      try visitor.visitSingularBoolField(value: self.includeSessions, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_RecordsRequest, rhs: Provenance_Metadata_V1_RecordsRequest) -> Bool {
    if lhs.recordAddr != rhs.recordAddr {return false}
    if lhs.scopeID != rhs.scopeID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.includeScope != rhs.includeScope {return false}
    if lhs.includeSessions != rhs.includeSessions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_RecordsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "sessions"),
    3: .same(proto: "records"),
    98: .same(proto: "request"),
  ]

  fileprivate class _StorageClass {
    var _scope: Provenance_Metadata_V1_ScopeWrapper? = nil
    var _sessions: [Provenance_Metadata_V1_SessionWrapper] = []
    var _records: [Provenance_Metadata_V1_RecordWrapper] = []
    var _request: Provenance_Metadata_V1_RecordsRequest? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _scope = source._scope
      _sessions = source._sessions
      _records = source._records
      _request = source._request
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._scope) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._sessions) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._records) }()
        case 98: try { try decoder.decodeSingularMessageField(value: &_storage._request) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._scope {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._sessions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sessions, fieldNumber: 2)
      }
      if !_storage._records.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._records, fieldNumber: 3)
      }
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_RecordsResponse, rhs: Provenance_Metadata_V1_RecordsResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._scope != rhs_storage._scope {return false}
        if _storage._sessions != rhs_storage._sessions {return false}
        if _storage._records != rhs_storage._records {return false}
        if _storage._request != rhs_storage._request {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_RecordWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordWrapper"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "record"),
    2: .standard(proto: "record_id_info"),
    3: .standard(proto: "record_spec_id_info"),
  ]

  fileprivate class _StorageClass {
    var _record: Provenance_Metadata_V1_Record? = nil
    var _recordIDInfo: Provenance_Metadata_V1_RecordIdInfo? = nil
    var _recordSpecIDInfo: Provenance_Metadata_V1_RecordSpecIdInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _record = source._record
      _recordIDInfo = source._recordIDInfo
      _recordSpecIDInfo = source._recordSpecIDInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._record) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._recordIDInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._recordSpecIDInfo) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._record {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._recordIDInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._recordSpecIDInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_RecordWrapper, rhs: Provenance_Metadata_V1_RecordWrapper) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._record != rhs_storage._record {return false}
        if _storage._recordIDInfo != rhs_storage._recordIDInfo {return false}
        if _storage._recordSpecIDInfo != rhs_storage._recordSpecIDInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_RecordsAllRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordsAllRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_RecordsAllRequest, rhs: Provenance_Metadata_V1_RecordsAllRequest) -> Bool {
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_RecordsAllResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordsAllResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "records"),
    98: .same(proto: "request"),
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      case 98: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_RecordsAllResponse, rhs: Provenance_Metadata_V1_RecordsAllResponse) -> Bool {
    if lhs.records != rhs.records {return false}
    if lhs._request != rhs._request {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_OwnershipRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OwnershipRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_OwnershipRequest, rhs: Provenance_Metadata_V1_OwnershipRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_OwnershipResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OwnershipResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_uuids"),
    98: .same(proto: "request"),
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.scopeUuids) }()
      case 98: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeUuids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scopeUuids, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_OwnershipResponse, rhs: Provenance_Metadata_V1_OwnershipResponse) -> Bool {
    if lhs.scopeUuids != rhs.scopeUuids {return false}
    if lhs._request != rhs._request {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_ValueOwnershipRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValueOwnershipRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_ValueOwnershipRequest, rhs: Provenance_Metadata_V1_ValueOwnershipRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_ValueOwnershipResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValueOwnershipResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_uuids"),
    98: .same(proto: "request"),
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.scopeUuids) }()
      case 98: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeUuids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scopeUuids, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_ValueOwnershipResponse, rhs: Provenance_Metadata_V1_ValueOwnershipResponse) -> Bool {
    if lhs.scopeUuids != rhs.scopeUuids {return false}
    if lhs._request != rhs._request {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_ScopeSpecificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScopeSpecificationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "specification_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.specificationID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.specificationID.isEmpty {
      try visitor.visitSingularStringField(value: self.specificationID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_ScopeSpecificationRequest, rhs: Provenance_Metadata_V1_ScopeSpecificationRequest) -> Bool {
    if lhs.specificationID != rhs.specificationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_ScopeSpecificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScopeSpecificationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_specification"),
    98: .same(proto: "request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scopeSpecification) }()
      case 98: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._scopeSpecification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_ScopeSpecificationResponse, rhs: Provenance_Metadata_V1_ScopeSpecificationResponse) -> Bool {
    if lhs._scopeSpecification != rhs._scopeSpecification {return false}
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_ScopeSpecificationWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScopeSpecificationWrapper"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "specification"),
    2: .standard(proto: "scope_spec_id_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._specification) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._scopeSpecIDInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._specification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._scopeSpecIDInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_ScopeSpecificationWrapper, rhs: Provenance_Metadata_V1_ScopeSpecificationWrapper) -> Bool {
    if lhs._specification != rhs._specification {return false}
    if lhs._scopeSpecIDInfo != rhs._scopeSpecIDInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_ScopeSpecificationsAllRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScopeSpecificationsAllRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_ScopeSpecificationsAllRequest, rhs: Provenance_Metadata_V1_ScopeSpecificationsAllRequest) -> Bool {
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_ScopeSpecificationsAllResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScopeSpecificationsAllResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_specifications"),
    98: .same(proto: "request"),
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.scopeSpecifications) }()
      case 98: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeSpecifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.scopeSpecifications, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_ScopeSpecificationsAllResponse, rhs: Provenance_Metadata_V1_ScopeSpecificationsAllResponse) -> Bool {
    if lhs.scopeSpecifications != rhs.scopeSpecifications {return false}
    if lhs._request != rhs._request {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_ContractSpecificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractSpecificationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "specification_id"),
    10: .standard(proto: "include_record_specs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.specificationID) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.includeRecordSpecs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.specificationID.isEmpty {
      try visitor.visitSingularStringField(value: self.specificationID, fieldNumber: 1)
    }
    if self.includeRecordSpecs != false {
      try visitor.visitSingularBoolField(value: self.includeRecordSpecs, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_ContractSpecificationRequest, rhs: Provenance_Metadata_V1_ContractSpecificationRequest) -> Bool {
    if lhs.specificationID != rhs.specificationID {return false}
    if lhs.includeRecordSpecs != rhs.includeRecordSpecs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_ContractSpecificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractSpecificationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_specification"),
    3: .standard(proto: "record_specifications"),
    98: .same(proto: "request"),
  ]

  fileprivate class _StorageClass {
    var _contractSpecification: Provenance_Metadata_V1_ContractSpecificationWrapper? = nil
    var _recordSpecifications: [Provenance_Metadata_V1_RecordSpecificationWrapper] = []
    var _request: Provenance_Metadata_V1_ContractSpecificationRequest? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _contractSpecification = source._contractSpecification
      _recordSpecifications = source._recordSpecifications
      _request = source._request
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._contractSpecification) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._recordSpecifications) }()
        case 98: try { try decoder.decodeSingularMessageField(value: &_storage._request) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._contractSpecification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._recordSpecifications.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._recordSpecifications, fieldNumber: 3)
      }
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_ContractSpecificationResponse, rhs: Provenance_Metadata_V1_ContractSpecificationResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._contractSpecification != rhs_storage._contractSpecification {return false}
        if _storage._recordSpecifications != rhs_storage._recordSpecifications {return false}
        if _storage._request != rhs_storage._request {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_ContractSpecificationWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractSpecificationWrapper"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "specification"),
    2: .standard(proto: "contract_spec_id_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._specification) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._contractSpecIDInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._specification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._contractSpecIDInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_ContractSpecificationWrapper, rhs: Provenance_Metadata_V1_ContractSpecificationWrapper) -> Bool {
    if lhs._specification != rhs._specification {return false}
    if lhs._contractSpecIDInfo != rhs._contractSpecIDInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_ContractSpecificationsAllRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractSpecificationsAllRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_ContractSpecificationsAllRequest, rhs: Provenance_Metadata_V1_ContractSpecificationsAllRequest) -> Bool {
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_ContractSpecificationsAllResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractSpecificationsAllResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_specifications"),
    98: .same(proto: "request"),
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.contractSpecifications) }()
      case 98: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contractSpecifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contractSpecifications, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_ContractSpecificationsAllResponse, rhs: Provenance_Metadata_V1_ContractSpecificationsAllResponse) -> Bool {
    if lhs.contractSpecifications != rhs.contractSpecifications {return false}
    if lhs._request != rhs._request {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_RecordSpecificationsForContractSpecificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordSpecificationsForContractSpecificationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "specification_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.specificationID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.specificationID.isEmpty {
      try visitor.visitSingularStringField(value: self.specificationID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_RecordSpecificationsForContractSpecificationRequest, rhs: Provenance_Metadata_V1_RecordSpecificationsForContractSpecificationRequest) -> Bool {
    if lhs.specificationID != rhs.specificationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_RecordSpecificationsForContractSpecificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordSpecificationsForContractSpecificationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_specifications"),
    2: .standard(proto: "contract_specification_uuid"),
    3: .standard(proto: "contract_specification_addr"),
    98: .same(proto: "request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.recordSpecifications) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contractSpecificationUuid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contractSpecificationAddr) }()
      case 98: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recordSpecifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recordSpecifications, fieldNumber: 1)
    }
    if !self.contractSpecificationUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.contractSpecificationUuid, fieldNumber: 2)
    }
    if !self.contractSpecificationAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.contractSpecificationAddr, fieldNumber: 3)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_RecordSpecificationsForContractSpecificationResponse, rhs: Provenance_Metadata_V1_RecordSpecificationsForContractSpecificationResponse) -> Bool {
    if lhs.recordSpecifications != rhs.recordSpecifications {return false}
    if lhs.contractSpecificationUuid != rhs.contractSpecificationUuid {return false}
    if lhs.contractSpecificationAddr != rhs.contractSpecificationAddr {return false}
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_RecordSpecificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordSpecificationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "specification_id"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.specificationID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.specificationID.isEmpty {
      try visitor.visitSingularStringField(value: self.specificationID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_RecordSpecificationRequest, rhs: Provenance_Metadata_V1_RecordSpecificationRequest) -> Bool {
    if lhs.specificationID != rhs.specificationID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_RecordSpecificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordSpecificationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_specification"),
    98: .same(proto: "request"),
  ]

  fileprivate class _StorageClass {
    var _recordSpecification: Provenance_Metadata_V1_RecordSpecificationWrapper? = nil
    var _request: Provenance_Metadata_V1_RecordSpecificationRequest? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _recordSpecification = source._recordSpecification
      _request = source._request
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._recordSpecification) }()
        case 98: try { try decoder.decodeSingularMessageField(value: &_storage._request) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._recordSpecification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_RecordSpecificationResponse, rhs: Provenance_Metadata_V1_RecordSpecificationResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._recordSpecification != rhs_storage._recordSpecification {return false}
        if _storage._request != rhs_storage._request {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_RecordSpecificationWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordSpecificationWrapper"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "specification"),
    2: .standard(proto: "record_spec_id_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._specification) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._recordSpecIDInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._specification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._recordSpecIDInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_RecordSpecificationWrapper, rhs: Provenance_Metadata_V1_RecordSpecificationWrapper) -> Bool {
    if lhs._specification != rhs._specification {return false}
    if lhs._recordSpecIDInfo != rhs._recordSpecIDInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_RecordSpecificationsAllRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordSpecificationsAllRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_RecordSpecificationsAllRequest, rhs: Provenance_Metadata_V1_RecordSpecificationsAllRequest) -> Bool {
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_RecordSpecificationsAllResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordSpecificationsAllResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_specifications"),
    98: .same(proto: "request"),
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.recordSpecifications) }()
      case 98: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recordSpecifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recordSpecifications, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_RecordSpecificationsAllResponse, rhs: Provenance_Metadata_V1_RecordSpecificationsAllResponse) -> Bool {
    if lhs.recordSpecifications != rhs.recordSpecifications {return false}
    if lhs._request != rhs._request {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_OSLocatorParamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OSLocatorParamsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_OSLocatorParamsRequest, rhs: Provenance_Metadata_V1_OSLocatorParamsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_OSLocatorParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OSLocatorParamsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
    98: .same(proto: "request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      case 98: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_OSLocatorParamsResponse, rhs: Provenance_Metadata_V1_OSLocatorParamsResponse) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_OSLocatorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OSLocatorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_OSLocatorRequest, rhs: Provenance_Metadata_V1_OSLocatorRequest) -> Bool {
    if lhs.owner != rhs.owner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_OSLocatorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OSLocatorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locator"),
    98: .same(proto: "request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._locator) }()
      case 98: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._locator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_OSLocatorResponse, rhs: Provenance_Metadata_V1_OSLocatorResponse) -> Bool {
    if lhs._locator != rhs._locator {return false}
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_OSLocatorsByURIRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OSLocatorsByURIRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_OSLocatorsByURIRequest, rhs: Provenance_Metadata_V1_OSLocatorsByURIRequest) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_OSLocatorsByURIResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OSLocatorsByURIResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locators"),
    98: .same(proto: "request"),
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.locators) }()
      case 98: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.locators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.locators, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_OSLocatorsByURIResponse, rhs: Provenance_Metadata_V1_OSLocatorsByURIResponse) -> Bool {
    if lhs.locators != rhs.locators {return false}
    if lhs._request != rhs._request {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_OSLocatorsByScopeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OSLocatorsByScopeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scopeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeID.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_OSLocatorsByScopeRequest, rhs: Provenance_Metadata_V1_OSLocatorsByScopeRequest) -> Bool {
    if lhs.scopeID != rhs.scopeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_OSLocatorsByScopeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OSLocatorsByScopeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locators"),
    98: .same(proto: "request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.locators) }()
      case 98: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.locators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.locators, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_OSLocatorsByScopeResponse, rhs: Provenance_Metadata_V1_OSLocatorsByScopeResponse) -> Bool {
    if lhs.locators != rhs.locators {return false}
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_OSAllLocatorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OSAllLocatorsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_OSAllLocatorsRequest, rhs: Provenance_Metadata_V1_OSAllLocatorsRequest) -> Bool {
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_OSAllLocatorsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OSAllLocatorsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locators"),
    98: .same(proto: "request"),
    99: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.locators) }()
      case 98: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.locators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.locators, fieldNumber: 1)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_OSAllLocatorsResponse, rhs: Provenance_Metadata_V1_OSAllLocatorsResponse) -> Bool {
    if lhs.locators != rhs.locators {return false}
    if lhs._request != rhs._request {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
