// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: regen/ecocredit/v1alpha2/types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// ClassInfo represents the high-level on-chain information for a credit class.
struct Regen_Ecocredit_V1alpha2_ClassInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// class_id is the unique ID of credit class.
  var classID: String = String()

  /// admin is the admin of the credit class.
  var admin: String = String()

  /// issuers are the approved issuers of the credit class.
  var issuers: [String] = []

  /// metadata is any arbitrary metadata to attached to the credit class.
  var metadata: Data = Data()

  /// credit_type describes the type of credit (e.g. carbon, biodiversity), as well as unit and precision.
  var creditType: Regen_Ecocredit_V1alpha2_CreditType {
    get {return _creditType ?? Regen_Ecocredit_V1alpha2_CreditType()}
    set {_creditType = newValue}
  }
  /// Returns true if `creditType` has been explicitly set.
  var hasCreditType: Bool {return self._creditType != nil}
  /// Clears the value of `creditType`. Subsequent reads from it will return its default value.
  mutating func clearCreditType() {self._creditType = nil}

  /// The number of batches issued in this credit class.
  var numBatches: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _creditType: Regen_Ecocredit_V1alpha2_CreditType? = nil
}

/// ProjectInfo represents the high-level on-chain information for a project.
struct Regen_Ecocredit_V1alpha2_ProjectInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// project_id is the unique ID of the project.
  var projectID: String = String()

  /// class_id is the unique ID of credit class for this project.
  var classID: String = String()

  /// issuer is the issuer of the credit batches for this project.
  var issuer: String = String()

  /// project_location is the location of the project.
  /// Full documentation can be found in MsgCreateProject.project_location.
  var projectLocation: String = String()

  /// metadata is any arbitrary metadata attached to the project.
  var metadata: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BatchInfo represents the high-level on-chain information for a credit batch.
struct Regen_Ecocredit_V1alpha2_BatchInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// project_id is the unique ID of the project this batch belongs to.
  var projectID: String = String()

  /// batch_denom is the unique ID of credit batch.
  var batchDenom: String = String()

  /// total_amount is the total number of active credits in the credit batch.
  /// Some of the issued credits may be cancelled and will be removed from
  /// total_amount and tracked in amount_cancelled. total_amount and
  /// amount_cancelled will always sum to the original amount of credits that
  /// were issued.
  var totalAmount: String = String()

  /// metadata is any arbitrary metadata attached to the credit batch.
  var metadata: Data = Data()

  /// amount_cancelled is the number of credits in the batch that have been
  /// cancelled, effectively undoing there issuance. The sum of total_amount and
  /// amount_cancelled will always sum to the original amount of credits that
  /// were issued.
  var amountCancelled: String = String()

  /// start_date is the beginning of the period during which this credit batch
  /// was quantified and verified.
  var startDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startDate = newValue}
  }
  /// Returns true if `startDate` has been explicitly set.
  var hasStartDate: Bool {return self._startDate != nil}
  /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
  mutating func clearStartDate() {self._startDate = nil}

  /// end_date is the end of the period during which this credit batch was
  /// quantified and verified.
  var endDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endDate = newValue}
  }
  /// Returns true if `endDate` has been explicitly set.
  var hasEndDate: Bool {return self._endDate != nil}
  /// Clears the value of `endDate`. Subsequent reads from it will return its default value.
  mutating func clearEndDate() {self._endDate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Params defines the updatable global parameters of the ecocredit module for
/// use with the x/params module.
struct Regen_Ecocredit_V1alpha2_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// credit_class_fee is the fixed fee charged on creation of a new credit class
  var creditClassFee: [Cosmos_Base_V1beta1_Coin] = []

  /// allowed_class_creators is an allowlist defining the addresses with
  /// the required permissions to create credit classes
  var allowedClassCreators: [String] = []

  /// allowlist_enabled is a param that enables/disables the allowlist for credit
  /// creation
  var allowlistEnabled: Bool = false

  /// credit_types is a list of definitions for credit types
  var creditTypes: [Regen_Ecocredit_V1alpha2_CreditType] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CreditType defines the measurement unit/precision of a certain credit type
/// (e.g. carbon, biodiversity...)
struct Regen_Ecocredit_V1alpha2_CreditType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the type of credit (e.g. carbon, biodiversity, etc)
  var name: String = String()

  /// abbreviation is a 1-3 character uppercase abbreviation of the CreditType
  /// name, used in batch denominations within the CreditType. It must be unique.
  var abbreviation: String = String()

  /// the measurement unit (e.g. kg, ton, etc)
  var unit: String = String()

  /// the decimal precision
  var precision: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CreditTypeSeq associates a sequence number with a credit type abbreviation.
/// This represents the number of credit classes created with that credit type.
struct Regen_Ecocredit_V1alpha2_CreditTypeSeq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The credit type abbreviation
  var abbreviation: String = String()

  /// The sequence number of classes of the credit type
  var seqNumber: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SellOrder represents the information for a sell order.
struct Regen_Ecocredit_V1alpha2_SellOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// order_id is the unique ID of sell order.
  var orderID: UInt64 = 0

  /// owner is the address of the owner of the credits being sold.
  var owner: String = String()

  /// batch_denom is the credit batch being sold.
  var batchDenom: String = String()

  /// quantity is the quantity of credits being sold.
  var quantity: String = String()

  /// ask_price is the price the seller is asking for each unit of the
  /// batch_denom. Each credit unit of the batch will be sold for at least the
  /// ask_price or more.
  var askPrice: Cosmos_Base_V1beta1_Coin {
    get {return _askPrice ?? Cosmos_Base_V1beta1_Coin()}
    set {_askPrice = newValue}
  }
  /// Returns true if `askPrice` has been explicitly set.
  var hasAskPrice: Bool {return self._askPrice != nil}
  /// Clears the value of `askPrice`. Subsequent reads from it will return its default value.
  mutating func clearAskPrice() {self._askPrice = nil}

  /// disable_auto_retire disables auto-retirement of credits which allows a
  /// buyer to disable auto-retirement in their buy order enabling them to
  /// resell the credits to another buyer.
  var disableAutoRetire: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _askPrice: Cosmos_Base_V1beta1_Coin? = nil
}

/// BuyOrder represents the information for a buy order.
struct Regen_Ecocredit_V1alpha2_BuyOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// buy_order_id is the unique ID of buy order.
  var buyOrderID: UInt64 = 0

  /// buyer is the address that created the buy order
  var buyer: String = String()

  /// selection is the buy order selection.
  var selection: Regen_Ecocredit_V1alpha2_BuyOrder.Selection {
    get {return _selection ?? Regen_Ecocredit_V1alpha2_BuyOrder.Selection()}
    set {_selection = newValue}
  }
  /// Returns true if `selection` has been explicitly set.
  var hasSelection: Bool {return self._selection != nil}
  /// Clears the value of `selection`. Subsequent reads from it will return its default value.
  mutating func clearSelection() {self._selection = nil}

  /// quantity is the quantity of credits to buy. If the quantity of credits
  /// available is less than this amount the order will be partially filled
  /// unless disable_partial_fill is true.
  var quantity: String = String()

  /// bid price is the bid price for this buy order. A credit unit will be
  /// settled at a purchase price that is no more than the bid price. The
  /// buy order will fail if the buyer does not have enough funds available
  /// to complete the purchase.
  var bidPrice: Cosmos_Base_V1beta1_Coin {
    get {return _bidPrice ?? Cosmos_Base_V1beta1_Coin()}
    set {_bidPrice = newValue}
  }
  /// Returns true if `bidPrice` has been explicitly set.
  var hasBidPrice: Bool {return self._bidPrice != nil}
  /// Clears the value of `bidPrice`. Subsequent reads from it will return its default value.
  mutating func clearBidPrice() {self._bidPrice = nil}

  /// disable_auto_retire allows auto-retirement to be disabled. If it is set to true
  /// the credits will not auto-retire and can be resold assuming that the
  /// corresponding sell order has auto-retirement disabled. If the sell order
  /// hasn't disabled auto-retirement and the buy order tries to disable it,
  /// that buy order will fail.
  var disableAutoRetire: Bool = false

  /// disable_partial_fill disables the default behavior of partially filling
  /// buy orders if the requested quantity is not available.
  var disablePartialFill: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Selection defines a buy order selection.
  struct Selection {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// sum defines the type of selection.
    var sum: Regen_Ecocredit_V1alpha2_BuyOrder.Selection.OneOf_Sum? = nil

    /// sell_order_id is the sell order ID against which the buyer is trying to buy.
    /// When sell_order_id is set, this is known as a direct buy order because it
    /// is placed directly against a specific sell order.
    var sellOrderID: UInt64 {
      get {
        if case .sellOrderID(let v)? = sum {return v}
        return 0
      }
      set {sum = .sellOrderID(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// sum defines the type of selection.
    enum OneOf_Sum: Equatable {
      /// sell_order_id is the sell order ID against which the buyer is trying to buy.
      /// When sell_order_id is set, this is known as a direct buy order because it
      /// is placed directly against a specific sell order.
      case sellOrderID(UInt64)

    #if !swift(>=4.1)
      static func ==(lhs: Regen_Ecocredit_V1alpha2_BuyOrder.Selection.OneOf_Sum, rhs: Regen_Ecocredit_V1alpha2_BuyOrder.Selection.OneOf_Sum) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.sellOrderID, .sellOrderID): return {
          guard case .sellOrderID(let l) = lhs, case .sellOrderID(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    init() {}
  }

  init() {}

  fileprivate var _selection: Regen_Ecocredit_V1alpha2_BuyOrder.Selection? = nil
  fileprivate var _bidPrice: Cosmos_Base_V1beta1_Coin? = nil
}

/// AskDenom represents the information for an ask denom.
struct Regen_Ecocredit_V1alpha2_AskDenom {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// denom is the denom to allow (ex. ibc/GLKHDSG423SGS)
  var denom: String = String()

  /// display_denom is the denom to display to the user and is informational
  var displayDenom: String = String()

  /// exponent is the exponent that relates the denom to the display_denom and is
  /// informational
  var exponent: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BasketCredit represents the information for a credit batch inside a basket.
struct Regen_Ecocredit_V1alpha2_BasketCredit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// batch_denom is the unique ID of the credit batch.
  var batchDenom: String = String()

  /// tradable_amount is the number of credits in this transfer that can be
  /// traded by the recipient. Decimal values are acceptable within the
  /// precision returned by Query/Precision.
  var tradableAmount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BasketCriteria defines a criteria by which credits can be added to a basket.
struct Regen_Ecocredit_V1alpha2_BasketCriteria {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// filter defines condition(s) that credits should satisfy in order to be
  /// added to the basket.
  var filter: Regen_Ecocredit_V1alpha2_Filter {
    get {return _filter ?? Regen_Ecocredit_V1alpha2_Filter()}
    set {_filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  var hasFilter: Bool {return self._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  mutating func clearFilter() {self._filter = nil}

  /// multiplier is an integer number which is applied to credit units when
  /// converting to basket units. For example if the multiplier is 2000, then
  /// 1.1 credits will result in 2200 basket tokens. If there are any fractional
  /// amounts left over in this calculation when adding credits to a basket,
  /// those fractional amounts will not get added to the basket.
  var multiplier: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _filter: Regen_Ecocredit_V1alpha2_Filter? = nil
}

/// Filter defines condition(s) that credits should satisfy in order to be added
/// to the basket. It can handled nested conditions linked with and/or operators.
struct Regen_Ecocredit_V1alpha2_Filter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// sum is the oneof that specifies the type of filter.
  var sum: Regen_Ecocredit_V1alpha2_Filter.OneOf_Sum? = nil

  /// and specifies a list of filters where all conditions should be satisfied.
  var and: Regen_Ecocredit_V1alpha2_Filter.And {
    get {
      if case .and(let v)? = sum {return v}
      return Regen_Ecocredit_V1alpha2_Filter.And()
    }
    set {sum = .and(newValue)}
  }

  /// or specifies a list of filters where at least one of the conditions should be satisfied.
  var or: Regen_Ecocredit_V1alpha2_Filter.Or {
    get {
      if case .or(let v)? = sum {return v}
      return Regen_Ecocredit_V1alpha2_Filter.Or()
    }
    set {sum = .or(newValue)}
  }

  /// credit_type_name filters against credits from this credit type name.
  var creditTypeName: String {
    get {
      if case .creditTypeName(let v)? = sum {return v}
      return String()
    }
    set {sum = .creditTypeName(newValue)}
  }

  /// class_id filters against credits from this credit class id.
  var classID: String {
    get {
      if case .classID(let v)? = sum {return v}
      return String()
    }
    set {sum = .classID(newValue)}
  }

  /// project_id filters against credits from this project.
  var projectID: String {
    get {
      if case .projectID(let v)? = sum {return v}
      return String()
    }
    set {sum = .projectID(newValue)}
  }

  /// batch_denom filters against credits from this batch.
  var batchDenom: String {
    get {
      if case .batchDenom(let v)? = sum {return v}
      return String()
    }
    set {sum = .batchDenom(newValue)}
  }

  /// class_admin filters against credits issued by this class admin.
  var classAdmin: String {
    get {
      if case .classAdmin(let v)? = sum {return v}
      return String()
    }
    set {sum = .classAdmin(newValue)}
  }

  /// issuer filters against credits issued by this issuer address.
  var issuer: String {
    get {
      if case .issuer(let v)? = sum {return v}
      return String()
    }
    set {sum = .issuer(newValue)}
  }

  /// owner filters against credits currently owned by this address.
  var owner: String {
    get {
      if case .owner(let v)? = sum {return v}
      return String()
    }
    set {sum = .owner(newValue)}
  }

  /// project_location can be specified in three levels of granularity:
  /// country, sub-national-code, or postal code. If just country is given,
  /// for instance "US" then any credits in the "US" will be matched even
  /// their project location is more specific, ex. "US-NY 12345". If
  /// a country, sub-national-code and postal code are all provided then
  /// only projects in that postal code will match.
  var projectLocation: String {
    get {
      if case .projectLocation(let v)? = sum {return v}
      return String()
    }
    set {sum = .projectLocation(newValue)}
  }

  /// date_range filters against credit batch start_date and/or end_date.
  var dateRange: Regen_Ecocredit_V1alpha2_Filter.DateRange {
    get {
      if case .dateRange(let v)? = sum {return v}
      return Regen_Ecocredit_V1alpha2_Filter.DateRange()
    }
    set {sum = .dateRange(newValue)}
  }

  /// tag specifies a curation tag to match against.
  var tag: String {
    get {
      if case .tag(let v)? = sum {return v}
      return String()
    }
    set {sum = .tag(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// sum is the oneof that specifies the type of filter.
  enum OneOf_Sum: Equatable {
    /// and specifies a list of filters where all conditions should be satisfied.
    case and(Regen_Ecocredit_V1alpha2_Filter.And)
    /// or specifies a list of filters where at least one of the conditions should be satisfied.
    case or(Regen_Ecocredit_V1alpha2_Filter.Or)
    /// credit_type_name filters against credits from this credit type name.
    case creditTypeName(String)
    /// class_id filters against credits from this credit class id.
    case classID(String)
    /// project_id filters against credits from this project.
    case projectID(String)
    /// batch_denom filters against credits from this batch.
    case batchDenom(String)
    /// class_admin filters against credits issued by this class admin.
    case classAdmin(String)
    /// issuer filters against credits issued by this issuer address.
    case issuer(String)
    /// owner filters against credits currently owned by this address.
    case owner(String)
    /// project_location can be specified in three levels of granularity:
    /// country, sub-national-code, or postal code. If just country is given,
    /// for instance "US" then any credits in the "US" will be matched even
    /// their project location is more specific, ex. "US-NY 12345". If
    /// a country, sub-national-code and postal code are all provided then
    /// only projects in that postal code will match.
    case projectLocation(String)
    /// date_range filters against credit batch start_date and/or end_date.
    case dateRange(Regen_Ecocredit_V1alpha2_Filter.DateRange)
    /// tag specifies a curation tag to match against.
    case tag(String)

  #if !swift(>=4.1)
    static func ==(lhs: Regen_Ecocredit_V1alpha2_Filter.OneOf_Sum, rhs: Regen_Ecocredit_V1alpha2_Filter.OneOf_Sum) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.and, .and): return {
        guard case .and(let l) = lhs, case .and(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.or, .or): return {
        guard case .or(let l) = lhs, case .or(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.creditTypeName, .creditTypeName): return {
        guard case .creditTypeName(let l) = lhs, case .creditTypeName(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.classID, .classID): return {
        guard case .classID(let l) = lhs, case .classID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.projectID, .projectID): return {
        guard case .projectID(let l) = lhs, case .projectID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.batchDenom, .batchDenom): return {
        guard case .batchDenom(let l) = lhs, case .batchDenom(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.classAdmin, .classAdmin): return {
        guard case .classAdmin(let l) = lhs, case .classAdmin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.issuer, .issuer): return {
        guard case .issuer(let l) = lhs, case .issuer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.owner, .owner): return {
        guard case .owner(let l) = lhs, case .owner(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.projectLocation, .projectLocation): return {
        guard case .projectLocation(let l) = lhs, case .projectLocation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dateRange, .dateRange): return {
        guard case .dateRange(let l) = lhs, case .dateRange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tag, .tag): return {
        guard case .tag(let l) = lhs, case .tag(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// And specifies an "and" condition between the list of filters.
  struct And {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// filters is a list of filters where all conditions should be satisfied.
    var filters: [Regen_Ecocredit_V1alpha2_Filter] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// And specifies an "or" condition between the list of filters.
  struct Or {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// filters is a list of filters where at least one of the conditions should be satisfied.
    var filters: [Regen_Ecocredit_V1alpha2_Filter] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// DateRange defines a period for credit batches in a basket.
  struct DateRange {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// start_date is the beginning of the period during which this credit batch
    /// was quantified and verified. If it is empty then there is no start date
    /// limit.
    var startDate: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _startDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_startDate = newValue}
    }
    /// Returns true if `startDate` has been explicitly set.
    var hasStartDate: Bool {return self._startDate != nil}
    /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
    mutating func clearStartDate() {self._startDate = nil}

    /// end_date is the end of the period during which this credit batch was
    /// quantified and verified. If it is empty then there is no end date
    /// limit.
    var endDate: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _endDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_endDate = newValue}
    }
    /// Returns true if `endDate` has been explicitly set.
    var hasEndDate: Bool {return self._endDate != nil}
    /// Clears the value of `endDate`. Subsequent reads from it will return its default value.
    mutating func clearEndDate() {self._endDate = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _startDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _endDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "regen.ecocredit.v1alpha2"

extension Regen_Ecocredit_V1alpha2_ClassInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClassInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "class_id"),
    2: .same(proto: "admin"),
    3: .same(proto: "issuers"),
    4: .same(proto: "metadata"),
    5: .standard(proto: "credit_type"),
    6: .standard(proto: "num_batches"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.admin) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.issuers) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._creditType) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.numBatches) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 1)
    }
    if !self.admin.isEmpty {
      try visitor.visitSingularStringField(value: self.admin, fieldNumber: 2)
    }
    if !self.issuers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.issuers, fieldNumber: 3)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 4)
    }
    if let v = self._creditType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.numBatches != 0 {
      try visitor.visitSingularUInt64Field(value: self.numBatches, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_ClassInfo, rhs: Regen_Ecocredit_V1alpha2_ClassInfo) -> Bool {
    if lhs.classID != rhs.classID {return false}
    if lhs.admin != rhs.admin {return false}
    if lhs.issuers != rhs.issuers {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs._creditType != rhs._creditType {return false}
    if lhs.numBatches != rhs.numBatches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_ProjectInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProjectInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "class_id"),
    3: .same(proto: "issuer"),
    4: .standard(proto: "project_location"),
    5: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.classID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.issuer) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.projectLocation) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.classID.isEmpty {
      try visitor.visitSingularStringField(value: self.classID, fieldNumber: 2)
    }
    if !self.issuer.isEmpty {
      try visitor.visitSingularStringField(value: self.issuer, fieldNumber: 3)
    }
    if !self.projectLocation.isEmpty {
      try visitor.visitSingularStringField(value: self.projectLocation, fieldNumber: 4)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_ProjectInfo, rhs: Regen_Ecocredit_V1alpha2_ProjectInfo) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.classID != rhs.classID {return false}
    if lhs.issuer != rhs.issuer {return false}
    if lhs.projectLocation != rhs.projectLocation {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_BatchInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "batch_denom"),
    4: .standard(proto: "total_amount"),
    5: .same(proto: "metadata"),
    6: .standard(proto: "amount_cancelled"),
    7: .standard(proto: "start_date"),
    8: .standard(proto: "end_date"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.batchDenom) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.totalAmount) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.amountCancelled) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._startDate) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._endDate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.batchDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.batchDenom, fieldNumber: 2)
    }
    if !self.totalAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.totalAmount, fieldNumber: 4)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 5)
    }
    if !self.amountCancelled.isEmpty {
      try visitor.visitSingularStringField(value: self.amountCancelled, fieldNumber: 6)
    }
    if let v = self._startDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._endDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_BatchInfo, rhs: Regen_Ecocredit_V1alpha2_BatchInfo) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.batchDenom != rhs.batchDenom {return false}
    if lhs.totalAmount != rhs.totalAmount {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.amountCancelled != rhs.amountCancelled {return false}
    if lhs._startDate != rhs._startDate {return false}
    if lhs._endDate != rhs._endDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "credit_class_fee"),
    2: .standard(proto: "allowed_class_creators"),
    3: .standard(proto: "allowlist_enabled"),
    4: .standard(proto: "credit_types"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.creditClassFee) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.allowedClassCreators) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allowlistEnabled) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.creditTypes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.creditClassFee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.creditClassFee, fieldNumber: 1)
    }
    if !self.allowedClassCreators.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedClassCreators, fieldNumber: 2)
    }
    if self.allowlistEnabled != false {
      try visitor.visitSingularBoolField(value: self.allowlistEnabled, fieldNumber: 3)
    }
    if !self.creditTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.creditTypes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_Params, rhs: Regen_Ecocredit_V1alpha2_Params) -> Bool {
    if lhs.creditClassFee != rhs.creditClassFee {return false}
    if lhs.allowedClassCreators != rhs.allowedClassCreators {return false}
    if lhs.allowlistEnabled != rhs.allowlistEnabled {return false}
    if lhs.creditTypes != rhs.creditTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_CreditType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreditType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "abbreviation"),
    3: .same(proto: "unit"),
    4: .same(proto: "precision"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.abbreviation) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.unit) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.precision) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.abbreviation.isEmpty {
      try visitor.visitSingularStringField(value: self.abbreviation, fieldNumber: 2)
    }
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 3)
    }
    if self.precision != 0 {
      try visitor.visitSingularUInt32Field(value: self.precision, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_CreditType, rhs: Regen_Ecocredit_V1alpha2_CreditType) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.abbreviation != rhs.abbreviation {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.precision != rhs.precision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_CreditTypeSeq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreditTypeSeq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "abbreviation"),
    2: .standard(proto: "seq_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.abbreviation) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.seqNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.abbreviation.isEmpty {
      try visitor.visitSingularStringField(value: self.abbreviation, fieldNumber: 1)
    }
    if self.seqNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.seqNumber, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_CreditTypeSeq, rhs: Regen_Ecocredit_V1alpha2_CreditTypeSeq) -> Bool {
    if lhs.abbreviation != rhs.abbreviation {return false}
    if lhs.seqNumber != rhs.seqNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_SellOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SellOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_id"),
    2: .same(proto: "owner"),
    3: .standard(proto: "batch_denom"),
    4: .same(proto: "quantity"),
    5: .standard(proto: "ask_price"),
    6: .standard(proto: "disable_auto_retire"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.orderID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.batchDenom) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._askPrice) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disableAutoRetire) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.orderID != 0 {
      try visitor.visitSingularUInt64Field(value: self.orderID, fieldNumber: 1)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 2)
    }
    if !self.batchDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.batchDenom, fieldNumber: 3)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 4)
    }
    if let v = self._askPrice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.disableAutoRetire != false {
      try visitor.visitSingularBoolField(value: self.disableAutoRetire, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_SellOrder, rhs: Regen_Ecocredit_V1alpha2_SellOrder) -> Bool {
    if lhs.orderID != rhs.orderID {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.batchDenom != rhs.batchDenom {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs._askPrice != rhs._askPrice {return false}
    if lhs.disableAutoRetire != rhs.disableAutoRetire {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_BuyOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BuyOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "buy_order_id"),
    2: .same(proto: "buyer"),
    3: .same(proto: "selection"),
    4: .same(proto: "quantity"),
    5: .standard(proto: "bid_price"),
    6: .standard(proto: "disable_auto_retire"),
    7: .standard(proto: "disable_partial_fill"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.buyOrderID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.buyer) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._selection) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._bidPrice) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disableAutoRetire) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.disablePartialFill) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.buyOrderID != 0 {
      try visitor.visitSingularUInt64Field(value: self.buyOrderID, fieldNumber: 1)
    }
    if !self.buyer.isEmpty {
      try visitor.visitSingularStringField(value: self.buyer, fieldNumber: 2)
    }
    if let v = self._selection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 4)
    }
    if let v = self._bidPrice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.disableAutoRetire != false {
      try visitor.visitSingularBoolField(value: self.disableAutoRetire, fieldNumber: 6)
    }
    if self.disablePartialFill != false {
      try visitor.visitSingularBoolField(value: self.disablePartialFill, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_BuyOrder, rhs: Regen_Ecocredit_V1alpha2_BuyOrder) -> Bool {
    if lhs.buyOrderID != rhs.buyOrderID {return false}
    if lhs.buyer != rhs.buyer {return false}
    if lhs._selection != rhs._selection {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs._bidPrice != rhs._bidPrice {return false}
    if lhs.disableAutoRetire != rhs.disableAutoRetire {return false}
    if lhs.disablePartialFill != rhs.disablePartialFill {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_BuyOrder.Selection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Regen_Ecocredit_V1alpha2_BuyOrder.protoMessageName + ".Selection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sell_order_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.sum != nil {try decoder.handleConflictingOneOf()}
          self.sum = .sellOrderID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .sellOrderID(let v)? = self.sum {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_BuyOrder.Selection, rhs: Regen_Ecocredit_V1alpha2_BuyOrder.Selection) -> Bool {
    if lhs.sum != rhs.sum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_AskDenom: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AskDenom"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .standard(proto: "display_denom"),
    3: .same(proto: "exponent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayDenom) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.exponent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.displayDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.displayDenom, fieldNumber: 2)
    }
    if self.exponent != 0 {
      try visitor.visitSingularUInt32Field(value: self.exponent, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_AskDenom, rhs: Regen_Ecocredit_V1alpha2_AskDenom) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.displayDenom != rhs.displayDenom {return false}
    if lhs.exponent != rhs.exponent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_BasketCredit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BasketCredit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_denom"),
    2: .standard(proto: "tradable_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.batchDenom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tradableAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.batchDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.batchDenom, fieldNumber: 1)
    }
    if !self.tradableAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.tradableAmount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_BasketCredit, rhs: Regen_Ecocredit_V1alpha2_BasketCredit) -> Bool {
    if lhs.batchDenom != rhs.batchDenom {return false}
    if lhs.tradableAmount != rhs.tradableAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_BasketCriteria: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BasketCriteria"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filter"),
    2: .same(proto: "multiplier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.multiplier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.multiplier.isEmpty {
      try visitor.visitSingularStringField(value: self.multiplier, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_BasketCriteria, rhs: Regen_Ecocredit_V1alpha2_BasketCriteria) -> Bool {
    if lhs._filter != rhs._filter {return false}
    if lhs.multiplier != rhs.multiplier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Filter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "and"),
    2: .same(proto: "or"),
    3: .standard(proto: "credit_type_name"),
    4: .standard(proto: "class_id"),
    5: .standard(proto: "project_id"),
    6: .standard(proto: "batch_denom"),
    7: .standard(proto: "class_admin"),
    8: .same(proto: "issuer"),
    9: .same(proto: "owner"),
    10: .standard(proto: "project_location"),
    11: .standard(proto: "date_range"),
    12: .same(proto: "tag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Regen_Ecocredit_V1alpha2_Filter.And?
        var hadOneofValue = false
        if let current = self.sum {
          hadOneofValue = true
          if case .and(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sum = .and(v)
        }
      }()
      case 2: try {
        var v: Regen_Ecocredit_V1alpha2_Filter.Or?
        var hadOneofValue = false
        if let current = self.sum {
          hadOneofValue = true
          if case .or(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sum = .or(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.sum != nil {try decoder.handleConflictingOneOf()}
          self.sum = .creditTypeName(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.sum != nil {try decoder.handleConflictingOneOf()}
          self.sum = .classID(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.sum != nil {try decoder.handleConflictingOneOf()}
          self.sum = .projectID(v)
        }
      }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.sum != nil {try decoder.handleConflictingOneOf()}
          self.sum = .batchDenom(v)
        }
      }()
      case 7: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.sum != nil {try decoder.handleConflictingOneOf()}
          self.sum = .classAdmin(v)
        }
      }()
      case 8: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.sum != nil {try decoder.handleConflictingOneOf()}
          self.sum = .issuer(v)
        }
      }()
      case 9: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.sum != nil {try decoder.handleConflictingOneOf()}
          self.sum = .owner(v)
        }
      }()
      case 10: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.sum != nil {try decoder.handleConflictingOneOf()}
          self.sum = .projectLocation(v)
        }
      }()
      case 11: try {
        var v: Regen_Ecocredit_V1alpha2_Filter.DateRange?
        var hadOneofValue = false
        if let current = self.sum {
          hadOneofValue = true
          if case .dateRange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sum = .dateRange(v)
        }
      }()
      case 12: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.sum != nil {try decoder.handleConflictingOneOf()}
          self.sum = .tag(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.sum {
    case .and?: try {
      guard case .and(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .or?: try {
      guard case .or(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .creditTypeName?: try {
      guard case .creditTypeName(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .classID?: try {
      guard case .classID(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .projectID?: try {
      guard case .projectID(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .batchDenom?: try {
      guard case .batchDenom(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    case .classAdmin?: try {
      guard case .classAdmin(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }()
    case .issuer?: try {
      guard case .issuer(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    }()
    case .owner?: try {
      guard case .owner(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    }()
    case .projectLocation?: try {
      guard case .projectLocation(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    }()
    case .dateRange?: try {
      guard case .dateRange(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .tag?: try {
      guard case .tag(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_Filter, rhs: Regen_Ecocredit_V1alpha2_Filter) -> Bool {
    if lhs.sum != rhs.sum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_Filter.And: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Regen_Ecocredit_V1alpha2_Filter.protoMessageName + ".And"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_Filter.And, rhs: Regen_Ecocredit_V1alpha2_Filter.And) -> Bool {
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_Filter.Or: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Regen_Ecocredit_V1alpha2_Filter.protoMessageName + ".Or"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_Filter.Or, rhs: Regen_Ecocredit_V1alpha2_Filter.Or) -> Bool {
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Regen_Ecocredit_V1alpha2_Filter.DateRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Regen_Ecocredit_V1alpha2_Filter.protoMessageName + ".DateRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    7: .standard(proto: "start_date"),
    8: .standard(proto: "end_date"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 7: try { try decoder.decodeSingularMessageField(value: &self._startDate) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._endDate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._endDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Regen_Ecocredit_V1alpha2_Filter.DateRange, rhs: Regen_Ecocredit_V1alpha2_Filter.DateRange) -> Bool {
    if lhs._startDate != rhs._startDate {return false}
    if lhs._endDate != rhs._endDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
