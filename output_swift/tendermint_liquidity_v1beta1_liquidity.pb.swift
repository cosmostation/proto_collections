// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tendermint/liquidity/v1beta1/liquidity.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Structure for the pool type to distinguish the characteristics of the reserve pools.
struct Tendermint_Liquidity_V1beta1_PoolType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is the id of the pool_type that is used as pool_type_id for pool creation.
  /// In this version, only pool-type-id 1 is supported.
  /// {"id":1,"name":"ConstantProductLiquidityPool","min_reserve_coin_num":2,"max_reserve_coin_num":2,"description":""}
  var id: UInt32 = 0

  /// name of the pool type.
  var name: String = String()

  /// minimum number of reserveCoins for LiquidityPoolType, only 2 reserve coins are supported.
  var minReserveCoinNum: UInt32 = 0

  /// maximum number of reserveCoins for LiquidityPoolType, only 2 reserve coins are supported.
  var maxReserveCoinNum: UInt32 = 0

  /// description of the pool type.
  var description_p: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Params defines the parameters for the liquidity module.
struct Tendermint_Liquidity_V1beta1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// list of available pool types
  var poolTypes: [Tendermint_Liquidity_V1beta1_PoolType] = []

  /// Minimum number of coins to be deposited to the liquidity pool on pool creation.
  var minInitDepositAmount: String = String()

  /// Initial mint amount of pool coins upon pool creation.
  var initPoolCoinMintAmount: String = String()

  /// Limit the size of each liquidity pool to minimize risk. In development, set to 0 for no limit. In production, set a limit.
  var maxReserveCoinAmount: String = String()

  /// Fee paid to create a Liquidity Pool. Set a fee to prevent spamming.
  var poolCreationFee: [Cosmos_Base_V1beta1_Coin] = []

  /// Swap fee rate for every executed swap.
  var swapFeeRate: String = String()

  /// Reserve coin withdrawal with less proportion by withdrawFeeRate.
  var withdrawFeeRate: String = String()

  /// Maximum ratio of reserve coins that can be ordered at a swap order.
  var maxOrderAmountRatio: String = String()

  /// The smallest unit batch height for every liquidity pool.
  var unitBatchHeight: UInt32 = 0

  /// Circuit breaker enables or disables transaction messages in liquidity module.
  var circuitBreakerEnabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Pool defines the liquidity pool that contains pool information.
struct Tendermint_Liquidity_V1beta1_Pool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of the pool
  var id: UInt64 = 0

  /// id of the pool_type
  var typeID: UInt32 = 0

  /// denoms of reserve coin pair of the pool
  var reserveCoinDenoms: [String] = []

  /// reserve account address of the pool
  var reserveAccountAddress: String = String()

  /// denom of pool coin of the pool
  var poolCoinDenom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Metadata for the state of each pool for invariant checking after genesis export or import.
struct Tendermint_Liquidity_V1beta1_PoolMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of the pool
  var poolID: UInt64 = 0

  /// pool coin issued at the pool
  var poolCoinTotalSupply: Cosmos_Base_V1beta1_Coin {
    get {return _poolCoinTotalSupply ?? Cosmos_Base_V1beta1_Coin()}
    set {_poolCoinTotalSupply = newValue}
  }
  /// Returns true if `poolCoinTotalSupply` has been explicitly set.
  var hasPoolCoinTotalSupply: Bool {return self._poolCoinTotalSupply != nil}
  /// Clears the value of `poolCoinTotalSupply`. Subsequent reads from it will return its default value.
  mutating func clearPoolCoinTotalSupply() {self._poolCoinTotalSupply = nil}

  /// reserve coins deposited in the pool
  var reserveCoins: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _poolCoinTotalSupply: Cosmos_Base_V1beta1_Coin? = nil
}

/// PoolBatch defines the batch or batches of a given liquidity pool that contains indexes of deposit, withdraw, and swap messages. 
/// Index param increments by 1 if the pool id is same.
struct Tendermint_Liquidity_V1beta1_PoolBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of the pool
  var poolID: UInt64 = 0

  /// index of this batch
  var index: UInt64 = 0

  /// height where this batch is started
  var beginHeight: Int64 = 0

  /// last index of DepositMsgStates
  var depositMsgIndex: UInt64 = 0

  /// last index of WithdrawMsgStates
  var withdrawMsgIndex: UInt64 = 0

  /// last index of SwapMsgStates
  var swapMsgIndex: UInt64 = 0

  /// true if executed, false if not executed 
  var executed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DepositMsgState defines the state of deposit message that contains state information as it is processed in the next batch or batches.
struct Tendermint_Liquidity_V1beta1_DepositMsgState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// height where this message is appended to the batch
  var msgHeight: Int64 = 0

  /// index of this deposit message in this liquidity pool
  var msgIndex: UInt64 = 0

  /// true if executed on this batch, false if not executed 
  var executed: Bool = false

  /// true if executed successfully on this batch, false if failed
  var succeeded: Bool = false

  /// true if ready to be deleted on kvstore, false if not ready to be deleted
  var toBeDeleted: Bool = false

  /// MsgDepositWithinBatch
  var msg: Tendermint_Liquidity_V1beta1_MsgDepositWithinBatch {
    get {return _msg ?? Tendermint_Liquidity_V1beta1_MsgDepositWithinBatch()}
    set {_msg = newValue}
  }
  /// Returns true if `msg` has been explicitly set.
  var hasMsg: Bool {return self._msg != nil}
  /// Clears the value of `msg`. Subsequent reads from it will return its default value.
  mutating func clearMsg() {self._msg = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _msg: Tendermint_Liquidity_V1beta1_MsgDepositWithinBatch? = nil
}

/// WithdrawMsgState defines the state of the withdraw message that contains state information as the message is processed in the next batch or batches.
struct Tendermint_Liquidity_V1beta1_WithdrawMsgState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// height where this message is appended to the batch
  var msgHeight: Int64 = 0

  /// index of this withdraw message in this liquidity pool
  var msgIndex: UInt64 = 0

  /// true if executed on this batch, false if not executed 
  var executed: Bool = false

  /// true if executed successfully on this batch, false if failed
  var succeeded: Bool = false

  /// true if ready to be deleted on kvstore, false if not ready to be deleted
  var toBeDeleted: Bool = false

  /// MsgWithdrawWithinBatch
  var msg: Tendermint_Liquidity_V1beta1_MsgWithdrawWithinBatch {
    get {return _msg ?? Tendermint_Liquidity_V1beta1_MsgWithdrawWithinBatch()}
    set {_msg = newValue}
  }
  /// Returns true if `msg` has been explicitly set.
  var hasMsg: Bool {return self._msg != nil}
  /// Clears the value of `msg`. Subsequent reads from it will return its default value.
  mutating func clearMsg() {self._msg = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _msg: Tendermint_Liquidity_V1beta1_MsgWithdrawWithinBatch? = nil
}

/// SwapMsgState defines the state of the swap message that contains state information as the message is processed in the next batch or batches.
struct Tendermint_Liquidity_V1beta1_SwapMsgState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// height where this message is appended to the batch
  var msgHeight: Int64 {
    get {return _storage._msgHeight}
    set {_uniqueStorage()._msgHeight = newValue}
  }

  /// index of this swap message in this liquidity pool
  var msgIndex: UInt64 {
    get {return _storage._msgIndex}
    set {_uniqueStorage()._msgIndex = newValue}
  }

  /// true if executed on this batch, false if not executed 
  var executed: Bool {
    get {return _storage._executed}
    set {_uniqueStorage()._executed = newValue}
  }

  /// true if executed successfully on this batch, false if failed
  var succeeded: Bool {
    get {return _storage._succeeded}
    set {_uniqueStorage()._succeeded = newValue}
  }

  /// true if ready to be deleted on kvstore, false if not ready to be deleted
  var toBeDeleted: Bool {
    get {return _storage._toBeDeleted}
    set {_uniqueStorage()._toBeDeleted = newValue}
  }

  /// swap orders are cancelled when current height is equal to or higher than ExpiryHeight
  var orderExpiryHeight: Int64 {
    get {return _storage._orderExpiryHeight}
    set {_uniqueStorage()._orderExpiryHeight = newValue}
  }

  /// offer coin exchanged until now
  var exchangedOfferCoin: Cosmos_Base_V1beta1_Coin {
    get {return _storage._exchangedOfferCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._exchangedOfferCoin = newValue}
  }
  /// Returns true if `exchangedOfferCoin` has been explicitly set.
  var hasExchangedOfferCoin: Bool {return _storage._exchangedOfferCoin != nil}
  /// Clears the value of `exchangedOfferCoin`. Subsequent reads from it will return its default value.
  mutating func clearExchangedOfferCoin() {_uniqueStorage()._exchangedOfferCoin = nil}

  /// offer coin currently remaining to be exchanged
  var remainingOfferCoin: Cosmos_Base_V1beta1_Coin {
    get {return _storage._remainingOfferCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._remainingOfferCoin = newValue}
  }
  /// Returns true if `remainingOfferCoin` has been explicitly set.
  var hasRemainingOfferCoin: Bool {return _storage._remainingOfferCoin != nil}
  /// Clears the value of `remainingOfferCoin`. Subsequent reads from it will return its default value.
  mutating func clearRemainingOfferCoin() {_uniqueStorage()._remainingOfferCoin = nil}

  /// reserve fee for pays fee in half offer coin
  var reservedOfferCoinFee: Cosmos_Base_V1beta1_Coin {
    get {return _storage._reservedOfferCoinFee ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._reservedOfferCoinFee = newValue}
  }
  /// Returns true if `reservedOfferCoinFee` has been explicitly set.
  var hasReservedOfferCoinFee: Bool {return _storage._reservedOfferCoinFee != nil}
  /// Clears the value of `reservedOfferCoinFee`. Subsequent reads from it will return its default value.
  mutating func clearReservedOfferCoinFee() {_uniqueStorage()._reservedOfferCoinFee = nil}

  /// MsgSwapWithinBatch
  var msg: Tendermint_Liquidity_V1beta1_MsgSwapWithinBatch {
    get {return _storage._msg ?? Tendermint_Liquidity_V1beta1_MsgSwapWithinBatch()}
    set {_uniqueStorage()._msg = newValue}
  }
  /// Returns true if `msg` has been explicitly set.
  var hasMsg: Bool {return _storage._msg != nil}
  /// Clears the value of `msg`. Subsequent reads from it will return its default value.
  mutating func clearMsg() {_uniqueStorage()._msg = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tendermint.liquidity.v1beta1"

extension Tendermint_Liquidity_V1beta1_PoolType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "min_reserve_coin_num"),
    4: .standard(proto: "max_reserve_coin_num"),
    5: .same(proto: "description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.minReserveCoinNum) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.maxReserveCoinNum) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.minReserveCoinNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.minReserveCoinNum, fieldNumber: 3)
    }
    if self.maxReserveCoinNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxReserveCoinNum, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Liquidity_V1beta1_PoolType, rhs: Tendermint_Liquidity_V1beta1_PoolType) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.minReserveCoinNum != rhs.minReserveCoinNum {return false}
    if lhs.maxReserveCoinNum != rhs.maxReserveCoinNum {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Liquidity_V1beta1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_types"),
    2: .standard(proto: "min_init_deposit_amount"),
    3: .standard(proto: "init_pool_coin_mint_amount"),
    4: .standard(proto: "max_reserve_coin_amount"),
    5: .standard(proto: "pool_creation_fee"),
    6: .standard(proto: "swap_fee_rate"),
    7: .standard(proto: "withdraw_fee_rate"),
    8: .standard(proto: "max_order_amount_ratio"),
    9: .standard(proto: "unit_batch_height"),
    10: .standard(proto: "circuit_breaker_enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.poolTypes) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.minInitDepositAmount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.initPoolCoinMintAmount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.maxReserveCoinAmount) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.poolCreationFee) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.swapFeeRate) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.withdrawFeeRate) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.maxOrderAmountRatio) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.unitBatchHeight) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.circuitBreakerEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.poolTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.poolTypes, fieldNumber: 1)
    }
    if !self.minInitDepositAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.minInitDepositAmount, fieldNumber: 2)
    }
    if !self.initPoolCoinMintAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.initPoolCoinMintAmount, fieldNumber: 3)
    }
    if !self.maxReserveCoinAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.maxReserveCoinAmount, fieldNumber: 4)
    }
    if !self.poolCreationFee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.poolCreationFee, fieldNumber: 5)
    }
    if !self.swapFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.swapFeeRate, fieldNumber: 6)
    }
    if !self.withdrawFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.withdrawFeeRate, fieldNumber: 7)
    }
    if !self.maxOrderAmountRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.maxOrderAmountRatio, fieldNumber: 8)
    }
    if self.unitBatchHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.unitBatchHeight, fieldNumber: 9)
    }
    if self.circuitBreakerEnabled != false {
      try visitor.visitSingularBoolField(value: self.circuitBreakerEnabled, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Liquidity_V1beta1_Params, rhs: Tendermint_Liquidity_V1beta1_Params) -> Bool {
    if lhs.poolTypes != rhs.poolTypes {return false}
    if lhs.minInitDepositAmount != rhs.minInitDepositAmount {return false}
    if lhs.initPoolCoinMintAmount != rhs.initPoolCoinMintAmount {return false}
    if lhs.maxReserveCoinAmount != rhs.maxReserveCoinAmount {return false}
    if lhs.poolCreationFee != rhs.poolCreationFee {return false}
    if lhs.swapFeeRate != rhs.swapFeeRate {return false}
    if lhs.withdrawFeeRate != rhs.withdrawFeeRate {return false}
    if lhs.maxOrderAmountRatio != rhs.maxOrderAmountRatio {return false}
    if lhs.unitBatchHeight != rhs.unitBatchHeight {return false}
    if lhs.circuitBreakerEnabled != rhs.circuitBreakerEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Liquidity_V1beta1_Pool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pool"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "type_id"),
    3: .standard(proto: "reserve_coin_denoms"),
    4: .standard(proto: "reserve_account_address"),
    5: .standard(proto: "pool_coin_denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.typeID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.reserveCoinDenoms) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reserveAccountAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.poolCoinDenom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.typeID != 0 {
      try visitor.visitSingularUInt32Field(value: self.typeID, fieldNumber: 2)
    }
    if !self.reserveCoinDenoms.isEmpty {
      try visitor.visitRepeatedStringField(value: self.reserveCoinDenoms, fieldNumber: 3)
    }
    if !self.reserveAccountAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.reserveAccountAddress, fieldNumber: 4)
    }
    if !self.poolCoinDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.poolCoinDenom, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Liquidity_V1beta1_Pool, rhs: Tendermint_Liquidity_V1beta1_Pool) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.typeID != rhs.typeID {return false}
    if lhs.reserveCoinDenoms != rhs.reserveCoinDenoms {return false}
    if lhs.reserveAccountAddress != rhs.reserveAccountAddress {return false}
    if lhs.poolCoinDenom != rhs.poolCoinDenom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Liquidity_V1beta1_PoolMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .standard(proto: "pool_coin_total_supply"),
    3: .standard(proto: "reserve_coins"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._poolCoinTotalSupply) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.reserveCoins) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if let v = self._poolCoinTotalSupply {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.reserveCoins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reserveCoins, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Liquidity_V1beta1_PoolMetadata, rhs: Tendermint_Liquidity_V1beta1_PoolMetadata) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs._poolCoinTotalSupply != rhs._poolCoinTotalSupply {return false}
    if lhs.reserveCoins != rhs.reserveCoins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Liquidity_V1beta1_PoolBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolBatch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .same(proto: "index"),
    3: .standard(proto: "begin_height"),
    4: .standard(proto: "deposit_msg_index"),
    5: .standard(proto: "withdraw_msg_index"),
    6: .standard(proto: "swap_msg_index"),
    7: .same(proto: "executed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.beginHeight) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.depositMsgIndex) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.withdrawMsgIndex) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.swapMsgIndex) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.executed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 2)
    }
    if self.beginHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.beginHeight, fieldNumber: 3)
    }
    if self.depositMsgIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.depositMsgIndex, fieldNumber: 4)
    }
    if self.withdrawMsgIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.withdrawMsgIndex, fieldNumber: 5)
    }
    if self.swapMsgIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.swapMsgIndex, fieldNumber: 6)
    }
    if self.executed != false {
      try visitor.visitSingularBoolField(value: self.executed, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Liquidity_V1beta1_PoolBatch, rhs: Tendermint_Liquidity_V1beta1_PoolBatch) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.index != rhs.index {return false}
    if lhs.beginHeight != rhs.beginHeight {return false}
    if lhs.depositMsgIndex != rhs.depositMsgIndex {return false}
    if lhs.withdrawMsgIndex != rhs.withdrawMsgIndex {return false}
    if lhs.swapMsgIndex != rhs.swapMsgIndex {return false}
    if lhs.executed != rhs.executed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Liquidity_V1beta1_DepositMsgState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DepositMsgState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "msg_height"),
    2: .standard(proto: "msg_index"),
    3: .same(proto: "executed"),
    4: .same(proto: "succeeded"),
    5: .standard(proto: "to_be_deleted"),
    6: .same(proto: "msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.msgHeight) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.msgIndex) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.executed) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.succeeded) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.toBeDeleted) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._msg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.msgHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.msgHeight, fieldNumber: 1)
    }
    if self.msgIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.msgIndex, fieldNumber: 2)
    }
    if self.executed != false {
      try visitor.visitSingularBoolField(value: self.executed, fieldNumber: 3)
    }
    if self.succeeded != false {
      try visitor.visitSingularBoolField(value: self.succeeded, fieldNumber: 4)
    }
    if self.toBeDeleted != false {
      try visitor.visitSingularBoolField(value: self.toBeDeleted, fieldNumber: 5)
    }
    if let v = self._msg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Liquidity_V1beta1_DepositMsgState, rhs: Tendermint_Liquidity_V1beta1_DepositMsgState) -> Bool {
    if lhs.msgHeight != rhs.msgHeight {return false}
    if lhs.msgIndex != rhs.msgIndex {return false}
    if lhs.executed != rhs.executed {return false}
    if lhs.succeeded != rhs.succeeded {return false}
    if lhs.toBeDeleted != rhs.toBeDeleted {return false}
    if lhs._msg != rhs._msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Liquidity_V1beta1_WithdrawMsgState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WithdrawMsgState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "msg_height"),
    2: .standard(proto: "msg_index"),
    3: .same(proto: "executed"),
    4: .same(proto: "succeeded"),
    5: .standard(proto: "to_be_deleted"),
    6: .same(proto: "msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.msgHeight) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.msgIndex) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.executed) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.succeeded) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.toBeDeleted) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._msg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.msgHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.msgHeight, fieldNumber: 1)
    }
    if self.msgIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.msgIndex, fieldNumber: 2)
    }
    if self.executed != false {
      try visitor.visitSingularBoolField(value: self.executed, fieldNumber: 3)
    }
    if self.succeeded != false {
      try visitor.visitSingularBoolField(value: self.succeeded, fieldNumber: 4)
    }
    if self.toBeDeleted != false {
      try visitor.visitSingularBoolField(value: self.toBeDeleted, fieldNumber: 5)
    }
    if let v = self._msg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Liquidity_V1beta1_WithdrawMsgState, rhs: Tendermint_Liquidity_V1beta1_WithdrawMsgState) -> Bool {
    if lhs.msgHeight != rhs.msgHeight {return false}
    if lhs.msgIndex != rhs.msgIndex {return false}
    if lhs.executed != rhs.executed {return false}
    if lhs.succeeded != rhs.succeeded {return false}
    if lhs.toBeDeleted != rhs.toBeDeleted {return false}
    if lhs._msg != rhs._msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Liquidity_V1beta1_SwapMsgState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SwapMsgState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "msg_height"),
    2: .standard(proto: "msg_index"),
    3: .same(proto: "executed"),
    4: .same(proto: "succeeded"),
    5: .standard(proto: "to_be_deleted"),
    6: .standard(proto: "order_expiry_height"),
    7: .standard(proto: "exchanged_offer_coin"),
    8: .standard(proto: "remaining_offer_coin"),
    9: .standard(proto: "reserved_offer_coin_fee"),
    10: .same(proto: "msg"),
  ]

  fileprivate class _StorageClass {
    var _msgHeight: Int64 = 0
    var _msgIndex: UInt64 = 0
    var _executed: Bool = false
    var _succeeded: Bool = false
    var _toBeDeleted: Bool = false
    var _orderExpiryHeight: Int64 = 0
    var _exchangedOfferCoin: Cosmos_Base_V1beta1_Coin? = nil
    var _remainingOfferCoin: Cosmos_Base_V1beta1_Coin? = nil
    var _reservedOfferCoinFee: Cosmos_Base_V1beta1_Coin? = nil
    var _msg: Tendermint_Liquidity_V1beta1_MsgSwapWithinBatch? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _msgHeight = source._msgHeight
      _msgIndex = source._msgIndex
      _executed = source._executed
      _succeeded = source._succeeded
      _toBeDeleted = source._toBeDeleted
      _orderExpiryHeight = source._orderExpiryHeight
      _exchangedOfferCoin = source._exchangedOfferCoin
      _remainingOfferCoin = source._remainingOfferCoin
      _reservedOfferCoinFee = source._reservedOfferCoinFee
      _msg = source._msg
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._msgHeight) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._msgIndex) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._executed) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._succeeded) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._toBeDeleted) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._orderExpiryHeight) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._exchangedOfferCoin) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._remainingOfferCoin) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._reservedOfferCoinFee) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._msg) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._msgHeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._msgHeight, fieldNumber: 1)
      }
      if _storage._msgIndex != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._msgIndex, fieldNumber: 2)
      }
      if _storage._executed != false {
        try visitor.visitSingularBoolField(value: _storage._executed, fieldNumber: 3)
      }
      if _storage._succeeded != false {
        try visitor.visitSingularBoolField(value: _storage._succeeded, fieldNumber: 4)
      }
      if _storage._toBeDeleted != false {
        try visitor.visitSingularBoolField(value: _storage._toBeDeleted, fieldNumber: 5)
      }
      if _storage._orderExpiryHeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._orderExpiryHeight, fieldNumber: 6)
      }
      if let v = _storage._exchangedOfferCoin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._remainingOfferCoin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._reservedOfferCoinFee {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._msg {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Liquidity_V1beta1_SwapMsgState, rhs: Tendermint_Liquidity_V1beta1_SwapMsgState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._msgHeight != rhs_storage._msgHeight {return false}
        if _storage._msgIndex != rhs_storage._msgIndex {return false}
        if _storage._executed != rhs_storage._executed {return false}
        if _storage._succeeded != rhs_storage._succeeded {return false}
        if _storage._toBeDeleted != rhs_storage._toBeDeleted {return false}
        if _storage._orderExpiryHeight != rhs_storage._orderExpiryHeight {return false}
        if _storage._exchangedOfferCoin != rhs_storage._exchangedOfferCoin {return false}
        if _storage._remainingOfferCoin != rhs_storage._remainingOfferCoin {return false}
        if _storage._reservedOfferCoinFee != rhs_storage._reservedOfferCoinFee {return false}
        if _storage._msg != rhs_storage._msg {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
