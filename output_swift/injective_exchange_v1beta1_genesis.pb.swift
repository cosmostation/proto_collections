// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: injective/exchange/v1beta1/genesis.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// GenesisState defines the evm module's genesis state.
struct Injective_Exchange_V1beta1_GenesisState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// params defines all the parameters of related to exchange.
  var params: Injective_Exchange_V1beta1_Params {
    get {return _storage._params ?? Injective_Exchange_V1beta1_Params()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {_uniqueStorage()._params = nil}

  /// accounts is an array containing the genesis trade pairs
  var spotMarkets: [Injective_Exchange_V1beta1_SpotMarket] {
    get {return _storage._spotMarkets}
    set {_uniqueStorage()._spotMarkets = newValue}
  }

  /// accounts is an array containing the genesis derivative markets
  var derivativeMarkets: [Injective_Exchange_V1beta1_DerivativeMarket] {
    get {return _storage._derivativeMarkets}
    set {_uniqueStorage()._derivativeMarkets = newValue}
  }

  /// spot_orderbook defines the spot exchange limit orderbook active at genesis.
  var spotOrderbook: [Injective_Exchange_V1beta1_SpotOrderBook] {
    get {return _storage._spotOrderbook}
    set {_uniqueStorage()._spotOrderbook = newValue}
  }

  /// derivative_orderbook defines the derivative exchange limit orderbook active at genesis.
  var derivativeOrderbook: [Injective_Exchange_V1beta1_DerivativeOrderBook] {
    get {return _storage._derivativeOrderbook}
    set {_uniqueStorage()._derivativeOrderbook = newValue}
  }

  /// balances defines the exchange users balances active at genesis.
  var balances: [Injective_Exchange_V1beta1_Balance] {
    get {return _storage._balances}
    set {_uniqueStorage()._balances = newValue}
  }

  /// positions defines the exchange derivative positions at genesis
  var positions: [Injective_Exchange_V1beta1_DerivativePosition] {
    get {return _storage._positions}
    set {_uniqueStorage()._positions = newValue}
  }

  /// subaccount_trade_nonces defines the subaccount trade nonces for the subaccounts at genesis
  var subaccountTradeNonces: [Injective_Exchange_V1beta1_SubaccountNonce] {
    get {return _storage._subaccountTradeNonces}
    set {_uniqueStorage()._subaccountTradeNonces = newValue}
  }

  /// expiry_futures_market_info defines the market info for the expiry futures markets at genesis
  var expiryFuturesMarketInfoState: [Injective_Exchange_V1beta1_ExpiryFuturesMarketInfoState] {
    get {return _storage._expiryFuturesMarketInfoState}
    set {_uniqueStorage()._expiryFuturesMarketInfoState = newValue}
  }

  /// perpetual_market_info defines the market info for the perpetual derivative markets at genesis
  var perpetualMarketInfo: [Injective_Exchange_V1beta1_PerpetualMarketInfo] {
    get {return _storage._perpetualMarketInfo}
    set {_uniqueStorage()._perpetualMarketInfo = newValue}
  }

  /// perpetual_market_funding_state defines the funding state for the perpetual derivative markets at genesis
  var perpetualMarketFundingState: [Injective_Exchange_V1beta1_PerpetualMarketFundingState] {
    get {return _storage._perpetualMarketFundingState}
    set {_uniqueStorage()._perpetualMarketFundingState = newValue}
  }

  /// derivative_market_settlement_scheduled defines the scheduled markets for settlement at genesis
  var derivativeMarketSettlementScheduled: [Injective_Exchange_V1beta1_DerivativeMarketSettlementInfo] {
    get {return _storage._derivativeMarketSettlementScheduled}
    set {_uniqueStorage()._derivativeMarketSettlementScheduled = newValue}
  }

  var isSpotExchangeEnabled: Bool {
    get {return _storage._isSpotExchangeEnabled}
    set {_uniqueStorage()._isSpotExchangeEnabled = newValue}
  }

  var isDerivativesExchangeEnabled: Bool {
    get {return _storage._isDerivativesExchangeEnabled}
    set {_uniqueStorage()._isDerivativesExchangeEnabled = newValue}
  }

  var tradingRewardCampaignInfo: Injective_Exchange_V1beta1_TradingRewardCampaignInfo {
    get {return _storage._tradingRewardCampaignInfo ?? Injective_Exchange_V1beta1_TradingRewardCampaignInfo()}
    set {_uniqueStorage()._tradingRewardCampaignInfo = newValue}
  }
  /// Returns true if `tradingRewardCampaignInfo` has been explicitly set.
  var hasTradingRewardCampaignInfo: Bool {return _storage._tradingRewardCampaignInfo != nil}
  /// Clears the value of `tradingRewardCampaignInfo`. Subsequent reads from it will return its default value.
  mutating func clearTradingRewardCampaignInfo() {_uniqueStorage()._tradingRewardCampaignInfo = nil}

  var tradingRewardPoolCampaignSchedule: [Injective_Exchange_V1beta1_CampaignRewardPool] {
    get {return _storage._tradingRewardPoolCampaignSchedule}
    set {_uniqueStorage()._tradingRewardPoolCampaignSchedule = newValue}
  }

  var tradingRewardCampaignAccountPoints: [Injective_Exchange_V1beta1_TradingRewardCampaignAccountPoints] {
    get {return _storage._tradingRewardCampaignAccountPoints}
    set {_uniqueStorage()._tradingRewardCampaignAccountPoints = newValue}
  }

  var feeDiscountSchedule: Injective_Exchange_V1beta1_FeeDiscountSchedule {
    get {return _storage._feeDiscountSchedule ?? Injective_Exchange_V1beta1_FeeDiscountSchedule()}
    set {_uniqueStorage()._feeDiscountSchedule = newValue}
  }
  /// Returns true if `feeDiscountSchedule` has been explicitly set.
  var hasFeeDiscountSchedule: Bool {return _storage._feeDiscountSchedule != nil}
  /// Clears the value of `feeDiscountSchedule`. Subsequent reads from it will return its default value.
  mutating func clearFeeDiscountSchedule() {_uniqueStorage()._feeDiscountSchedule = nil}

  var feeDiscountAccountTierTtl: [Injective_Exchange_V1beta1_FeeDiscountAccountTierTTL] {
    get {return _storage._feeDiscountAccountTierTtl}
    set {_uniqueStorage()._feeDiscountAccountTierTtl = newValue}
  }

  var feeDiscountBucketFeesPaidAccounts: [Injective_Exchange_V1beta1_FeeDiscountBucketFeesPaidAccounts] {
    get {return _storage._feeDiscountBucketFeesPaidAccounts}
    set {_uniqueStorage()._feeDiscountBucketFeesPaidAccounts = newValue}
  }

  var isFirstFeeCycleFinished: Bool {
    get {return _storage._isFirstFeeCycleFinished}
    set {_uniqueStorage()._isFirstFeeCycleFinished = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Injective_Exchange_V1beta1_FeeDiscountAccountTierTTL {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var account: String = String()

  var tierTtl: Injective_Exchange_V1beta1_FeeDiscountTierTTL {
    get {return _tierTtl ?? Injective_Exchange_V1beta1_FeeDiscountTierTTL()}
    set {_tierTtl = newValue}
  }
  /// Returns true if `tierTtl` has been explicitly set.
  var hasTierTtl: Bool {return self._tierTtl != nil}
  /// Clears the value of `tierTtl`. Subsequent reads from it will return its default value.
  mutating func clearTierTtl() {self._tierTtl = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tierTtl: Injective_Exchange_V1beta1_FeeDiscountTierTTL? = nil
}

struct Injective_Exchange_V1beta1_FeeDiscountBucketFeesPaidAccounts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bucketStartTimestamp: Int64 = 0

  var accountFeesPaid: [Injective_Exchange_V1beta1_AccountFeesPaid] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_AccountFeesPaid {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var account: String = String()

  var feesPaid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_TradingRewardCampaignAccountPoints {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var account: String = String()

  var points: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Spot Exchange Limit Orderbook
struct Injective_Exchange_V1beta1_SpotOrderBook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var isBuySide: Bool = false

  var orders: [Injective_Exchange_V1beta1_SpotLimitOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Spot Exchange Limit Orderbook
struct Injective_Exchange_V1beta1_DerivativeOrderBook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var isBuySide: Bool = false

  var orders: [Injective_Exchange_V1beta1_DerivativeLimitOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_Balance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: String = String()

  var denom: String = String()

  var deposits: Injective_Exchange_V1beta1_Deposit {
    get {return _deposits ?? Injective_Exchange_V1beta1_Deposit()}
    set {_deposits = newValue}
  }
  /// Returns true if `deposits` has been explicitly set.
  var hasDeposits: Bool {return self._deposits != nil}
  /// Clears the value of `deposits`. Subsequent reads from it will return its default value.
  mutating func clearDeposits() {self._deposits = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deposits: Injective_Exchange_V1beta1_Deposit? = nil
}

struct Injective_Exchange_V1beta1_DerivativePosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: String = String()

  var marketID: String = String()

  var position: Injective_Exchange_V1beta1_Position {
    get {return _position ?? Injective_Exchange_V1beta1_Position()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: Injective_Exchange_V1beta1_Position? = nil
}

struct Injective_Exchange_V1beta1_SubaccountNonce {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: String = String()

  var subaccountTradeNonce: Injective_Exchange_V1beta1_SubaccountTradeNonce {
    get {return _subaccountTradeNonce ?? Injective_Exchange_V1beta1_SubaccountTradeNonce()}
    set {_subaccountTradeNonce = newValue}
  }
  /// Returns true if `subaccountTradeNonce` has been explicitly set.
  var hasSubaccountTradeNonce: Bool {return self._subaccountTradeNonce != nil}
  /// Clears the value of `subaccountTradeNonce`. Subsequent reads from it will return its default value.
  mutating func clearSubaccountTradeNonce() {self._subaccountTradeNonce = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _subaccountTradeNonce: Injective_Exchange_V1beta1_SubaccountTradeNonce? = nil
}

struct Injective_Exchange_V1beta1_ExpiryFuturesMarketInfoState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var marketInfo: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo {
    get {return _marketInfo ?? Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo()}
    set {_marketInfo = newValue}
  }
  /// Returns true if `marketInfo` has been explicitly set.
  var hasMarketInfo: Bool {return self._marketInfo != nil}
  /// Clears the value of `marketInfo`. Subsequent reads from it will return its default value.
  mutating func clearMarketInfo() {self._marketInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _marketInfo: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo? = nil
}

struct Injective_Exchange_V1beta1_PerpetualMarketFundingState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var funding: Injective_Exchange_V1beta1_PerpetualMarketFunding {
    get {return _funding ?? Injective_Exchange_V1beta1_PerpetualMarketFunding()}
    set {_funding = newValue}
  }
  /// Returns true if `funding` has been explicitly set.
  var hasFunding: Bool {return self._funding != nil}
  /// Clears the value of `funding`. Subsequent reads from it will return its default value.
  mutating func clearFunding() {self._funding = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _funding: Injective_Exchange_V1beta1_PerpetualMarketFunding? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "injective.exchange.v1beta1"

extension Injective_Exchange_V1beta1_GenesisState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenesisState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
    2: .standard(proto: "spot_markets"),
    3: .standard(proto: "derivative_markets"),
    4: .standard(proto: "spot_orderbook"),
    5: .standard(proto: "derivative_orderbook"),
    6: .same(proto: "balances"),
    7: .same(proto: "positions"),
    8: .standard(proto: "subaccount_trade_nonces"),
    9: .standard(proto: "expiry_futures_market_info_state"),
    10: .standard(proto: "perpetual_market_info"),
    11: .standard(proto: "perpetual_market_funding_state"),
    12: .standard(proto: "derivative_market_settlement_scheduled"),
    13: .standard(proto: "is_spot_exchange_enabled"),
    14: .standard(proto: "is_derivatives_exchange_enabled"),
    15: .standard(proto: "trading_reward_campaign_info"),
    16: .standard(proto: "trading_reward_pool_campaign_schedule"),
    17: .standard(proto: "trading_reward_campaign_account_points"),
    18: .standard(proto: "fee_discount_schedule"),
    19: .standard(proto: "fee_discount_account_tier_ttl"),
    20: .standard(proto: "fee_discount_bucket_fees_paid_accounts"),
    21: .standard(proto: "is_first_fee_cycle_finished"),
  ]

  fileprivate class _StorageClass {
    var _params: Injective_Exchange_V1beta1_Params? = nil
    var _spotMarkets: [Injective_Exchange_V1beta1_SpotMarket] = []
    var _derivativeMarkets: [Injective_Exchange_V1beta1_DerivativeMarket] = []
    var _spotOrderbook: [Injective_Exchange_V1beta1_SpotOrderBook] = []
    var _derivativeOrderbook: [Injective_Exchange_V1beta1_DerivativeOrderBook] = []
    var _balances: [Injective_Exchange_V1beta1_Balance] = []
    var _positions: [Injective_Exchange_V1beta1_DerivativePosition] = []
    var _subaccountTradeNonces: [Injective_Exchange_V1beta1_SubaccountNonce] = []
    var _expiryFuturesMarketInfoState: [Injective_Exchange_V1beta1_ExpiryFuturesMarketInfoState] = []
    var _perpetualMarketInfo: [Injective_Exchange_V1beta1_PerpetualMarketInfo] = []
    var _perpetualMarketFundingState: [Injective_Exchange_V1beta1_PerpetualMarketFundingState] = []
    var _derivativeMarketSettlementScheduled: [Injective_Exchange_V1beta1_DerivativeMarketSettlementInfo] = []
    var _isSpotExchangeEnabled: Bool = false
    var _isDerivativesExchangeEnabled: Bool = false
    var _tradingRewardCampaignInfo: Injective_Exchange_V1beta1_TradingRewardCampaignInfo? = nil
    var _tradingRewardPoolCampaignSchedule: [Injective_Exchange_V1beta1_CampaignRewardPool] = []
    var _tradingRewardCampaignAccountPoints: [Injective_Exchange_V1beta1_TradingRewardCampaignAccountPoints] = []
    var _feeDiscountSchedule: Injective_Exchange_V1beta1_FeeDiscountSchedule? = nil
    var _feeDiscountAccountTierTtl: [Injective_Exchange_V1beta1_FeeDiscountAccountTierTTL] = []
    var _feeDiscountBucketFeesPaidAccounts: [Injective_Exchange_V1beta1_FeeDiscountBucketFeesPaidAccounts] = []
    var _isFirstFeeCycleFinished: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _params = source._params
      _spotMarkets = source._spotMarkets
      _derivativeMarkets = source._derivativeMarkets
      _spotOrderbook = source._spotOrderbook
      _derivativeOrderbook = source._derivativeOrderbook
      _balances = source._balances
      _positions = source._positions
      _subaccountTradeNonces = source._subaccountTradeNonces
      _expiryFuturesMarketInfoState = source._expiryFuturesMarketInfoState
      _perpetualMarketInfo = source._perpetualMarketInfo
      _perpetualMarketFundingState = source._perpetualMarketFundingState
      _derivativeMarketSettlementScheduled = source._derivativeMarketSettlementScheduled
      _isSpotExchangeEnabled = source._isSpotExchangeEnabled
      _isDerivativesExchangeEnabled = source._isDerivativesExchangeEnabled
      _tradingRewardCampaignInfo = source._tradingRewardCampaignInfo
      _tradingRewardPoolCampaignSchedule = source._tradingRewardPoolCampaignSchedule
      _tradingRewardCampaignAccountPoints = source._tradingRewardCampaignAccountPoints
      _feeDiscountSchedule = source._feeDiscountSchedule
      _feeDiscountAccountTierTtl = source._feeDiscountAccountTierTtl
      _feeDiscountBucketFeesPaidAccounts = source._feeDiscountBucketFeesPaidAccounts
      _isFirstFeeCycleFinished = source._isFirstFeeCycleFinished
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._spotMarkets) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._derivativeMarkets) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._spotOrderbook) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._derivativeOrderbook) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._balances) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._positions) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._subaccountTradeNonces) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._expiryFuturesMarketInfoState) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._perpetualMarketInfo) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._perpetualMarketFundingState) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._derivativeMarketSettlementScheduled) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._isSpotExchangeEnabled) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._isDerivativesExchangeEnabled) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._tradingRewardCampaignInfo) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._tradingRewardPoolCampaignSchedule) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._tradingRewardCampaignAccountPoints) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._feeDiscountSchedule) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._feeDiscountAccountTierTtl) }()
        case 20: try { try decoder.decodeRepeatedMessageField(value: &_storage._feeDiscountBucketFeesPaidAccounts) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._isFirstFeeCycleFinished) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._spotMarkets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._spotMarkets, fieldNumber: 2)
      }
      if !_storage._derivativeMarkets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._derivativeMarkets, fieldNumber: 3)
      }
      if !_storage._spotOrderbook.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._spotOrderbook, fieldNumber: 4)
      }
      if !_storage._derivativeOrderbook.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._derivativeOrderbook, fieldNumber: 5)
      }
      if !_storage._balances.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._balances, fieldNumber: 6)
      }
      if !_storage._positions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._positions, fieldNumber: 7)
      }
      if !_storage._subaccountTradeNonces.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._subaccountTradeNonces, fieldNumber: 8)
      }
      if !_storage._expiryFuturesMarketInfoState.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._expiryFuturesMarketInfoState, fieldNumber: 9)
      }
      if !_storage._perpetualMarketInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._perpetualMarketInfo, fieldNumber: 10)
      }
      if !_storage._perpetualMarketFundingState.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._perpetualMarketFundingState, fieldNumber: 11)
      }
      if !_storage._derivativeMarketSettlementScheduled.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._derivativeMarketSettlementScheduled, fieldNumber: 12)
      }
      if _storage._isSpotExchangeEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._isSpotExchangeEnabled, fieldNumber: 13)
      }
      if _storage._isDerivativesExchangeEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._isDerivativesExchangeEnabled, fieldNumber: 14)
      }
      if let v = _storage._tradingRewardCampaignInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if !_storage._tradingRewardPoolCampaignSchedule.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tradingRewardPoolCampaignSchedule, fieldNumber: 16)
      }
      if !_storage._tradingRewardCampaignAccountPoints.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tradingRewardCampaignAccountPoints, fieldNumber: 17)
      }
      if let v = _storage._feeDiscountSchedule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if !_storage._feeDiscountAccountTierTtl.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._feeDiscountAccountTierTtl, fieldNumber: 19)
      }
      if !_storage._feeDiscountBucketFeesPaidAccounts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._feeDiscountBucketFeesPaidAccounts, fieldNumber: 20)
      }
      if _storage._isFirstFeeCycleFinished != false {
        try visitor.visitSingularBoolField(value: _storage._isFirstFeeCycleFinished, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_GenesisState, rhs: Injective_Exchange_V1beta1_GenesisState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._params != rhs_storage._params {return false}
        if _storage._spotMarkets != rhs_storage._spotMarkets {return false}
        if _storage._derivativeMarkets != rhs_storage._derivativeMarkets {return false}
        if _storage._spotOrderbook != rhs_storage._spotOrderbook {return false}
        if _storage._derivativeOrderbook != rhs_storage._derivativeOrderbook {return false}
        if _storage._balances != rhs_storage._balances {return false}
        if _storage._positions != rhs_storage._positions {return false}
        if _storage._subaccountTradeNonces != rhs_storage._subaccountTradeNonces {return false}
        if _storage._expiryFuturesMarketInfoState != rhs_storage._expiryFuturesMarketInfoState {return false}
        if _storage._perpetualMarketInfo != rhs_storage._perpetualMarketInfo {return false}
        if _storage._perpetualMarketFundingState != rhs_storage._perpetualMarketFundingState {return false}
        if _storage._derivativeMarketSettlementScheduled != rhs_storage._derivativeMarketSettlementScheduled {return false}
        if _storage._isSpotExchangeEnabled != rhs_storage._isSpotExchangeEnabled {return false}
        if _storage._isDerivativesExchangeEnabled != rhs_storage._isDerivativesExchangeEnabled {return false}
        if _storage._tradingRewardCampaignInfo != rhs_storage._tradingRewardCampaignInfo {return false}
        if _storage._tradingRewardPoolCampaignSchedule != rhs_storage._tradingRewardPoolCampaignSchedule {return false}
        if _storage._tradingRewardCampaignAccountPoints != rhs_storage._tradingRewardCampaignAccountPoints {return false}
        if _storage._feeDiscountSchedule != rhs_storage._feeDiscountSchedule {return false}
        if _storage._feeDiscountAccountTierTtl != rhs_storage._feeDiscountAccountTierTtl {return false}
        if _storage._feeDiscountBucketFeesPaidAccounts != rhs_storage._feeDiscountBucketFeesPaidAccounts {return false}
        if _storage._isFirstFeeCycleFinished != rhs_storage._isFirstFeeCycleFinished {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_FeeDiscountAccountTierTTL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeDiscountAccountTierTTL"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "tier_ttl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tierTtl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if let v = self._tierTtl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_FeeDiscountAccountTierTTL, rhs: Injective_Exchange_V1beta1_FeeDiscountAccountTierTTL) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs._tierTtl != rhs._tierTtl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_FeeDiscountBucketFeesPaidAccounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeDiscountBucketFeesPaidAccounts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bucket_start_timestamp"),
    2: .standard(proto: "account_fees_paid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.bucketStartTimestamp) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.accountFeesPaid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bucketStartTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.bucketStartTimestamp, fieldNumber: 1)
    }
    if !self.accountFeesPaid.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accountFeesPaid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_FeeDiscountBucketFeesPaidAccounts, rhs: Injective_Exchange_V1beta1_FeeDiscountBucketFeesPaidAccounts) -> Bool {
    if lhs.bucketStartTimestamp != rhs.bucketStartTimestamp {return false}
    if lhs.accountFeesPaid != rhs.accountFeesPaid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_AccountFeesPaid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountFeesPaid"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "fees_paid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.feesPaid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.feesPaid.isEmpty {
      try visitor.visitSingularStringField(value: self.feesPaid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_AccountFeesPaid, rhs: Injective_Exchange_V1beta1_AccountFeesPaid) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.feesPaid != rhs.feesPaid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TradingRewardCampaignAccountPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradingRewardCampaignAccountPoints"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.points) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.points.isEmpty {
      try visitor.visitSingularStringField(value: self.points, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TradingRewardCampaignAccountPoints, rhs: Injective_Exchange_V1beta1_TradingRewardCampaignAccountPoints) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.points != rhs.points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SpotOrderBook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpotOrderBook"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "isBuySide"),
    3: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isBuySide) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if self.isBuySide != false {
      try visitor.visitSingularBoolField(value: self.isBuySide, fieldNumber: 2)
    }
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SpotOrderBook, rhs: Injective_Exchange_V1beta1_SpotOrderBook) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.isBuySide != rhs.isBuySide {return false}
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeOrderBook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeOrderBook"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "isBuySide"),
    3: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isBuySide) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if self.isBuySide != false {
      try visitor.visitSingularBoolField(value: self.isBuySide, fieldNumber: 2)
    }
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeOrderBook, rhs: Injective_Exchange_V1beta1_DerivativeOrderBook) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.isBuySide != rhs.isBuySide {return false}
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_Balance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Balance"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .same(proto: "denom"),
    3: .same(proto: "deposits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._deposits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    if let v = self._deposits {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_Balance, rhs: Injective_Exchange_V1beta1_Balance) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs._deposits != rhs._deposits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativePosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativePosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .standard(proto: "market_id"),
    3: .same(proto: "position"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 2)
    }
    if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativePosition, rhs: Injective_Exchange_V1beta1_DerivativePosition) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs._position != rhs._position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SubaccountNonce: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubaccountNonce"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .standard(proto: "subaccount_trade_nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._subaccountTradeNonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    if let v = self._subaccountTradeNonce {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SubaccountNonce, rhs: Injective_Exchange_V1beta1_SubaccountNonce) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs._subaccountTradeNonce != rhs._subaccountTradeNonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_ExpiryFuturesMarketInfoState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpiryFuturesMarketInfoState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "market_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._marketInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if let v = self._marketInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfoState, rhs: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfoState) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs._marketInfo != rhs._marketInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_PerpetualMarketFundingState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PerpetualMarketFundingState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "funding"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._funding) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if let v = self._funding {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_PerpetualMarketFundingState, rhs: Injective_Exchange_V1beta1_PerpetualMarketFundingState) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs._funding != rhs._funding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
