// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: kava/cdp/v1beta1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// QueryParamsRequest defines the request type for the Query/Params RPC method.
struct Kava_Cdp_V1beta1_QueryParamsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryParamsResponse defines the response type for the Query/Params RPC method.
struct Kava_Cdp_V1beta1_QueryParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: Kava_Cdp_V1beta1_Params {
    get {return _params ?? Kava_Cdp_V1beta1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Kava_Cdp_V1beta1_Params? = nil
}

/// QueryAccountsRequest defines the request type for the Query/Accounts RPC method.
struct Kava_Cdp_V1beta1_QueryAccountsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAccountsResponse defines the response type for the Query/Accounts RPC method.
struct Kava_Cdp_V1beta1_QueryAccountsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accounts: [Cosmos_Auth_V1beta1_ModuleAccount] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCdpRequest defines the request type for the Query/Cdp RPC method.
struct Kava_Cdp_V1beta1_QueryCdpRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var collateralType: String = String()

  var owner: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCdpResponse defines the response type for the Query/Cdp RPC method.
struct Kava_Cdp_V1beta1_QueryCdpResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cdp: Kava_Cdp_V1beta1_CDPResponse {
    get {return _cdp ?? Kava_Cdp_V1beta1_CDPResponse()}
    set {_cdp = newValue}
  }
  /// Returns true if `cdp` has been explicitly set.
  var hasCdp: Bool {return self._cdp != nil}
  /// Clears the value of `cdp`. Subsequent reads from it will return its default value.
  mutating func clearCdp() {self._cdp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cdp: Kava_Cdp_V1beta1_CDPResponse? = nil
}

/// QueryCdpsRequest is the params for a filtered CDP query, the request type for the Query/Cdps RPC method.
struct Kava_Cdp_V1beta1_QueryCdpsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var collateralType: String = String()

  var owner: String = String()

  var id: UInt64 = 0

  /// sdk.Dec as a string
  var ratio: String = String()

  var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// QueryCdpsResponse defines the response type for the Query/Cdps RPC method.
struct Kava_Cdp_V1beta1_QueryCdpsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cdps: [Kava_Cdp_V1beta1_CDPResponse] = []

  var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  mutating func clearPagination() {self._pagination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// QueryDepositsRequest defines the request type for the Query/Deposits RPC method.
struct Kava_Cdp_V1beta1_QueryDepositsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var collateralType: String = String()

  var owner: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryDepositsResponse defines the response type for the Query/Deposits RPC method.
struct Kava_Cdp_V1beta1_QueryDepositsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deposits: [Kava_Cdp_V1beta1_Deposit] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTotalPrincipalRequest defines the request type for the Query/TotalPrincipal RPC method.
struct Kava_Cdp_V1beta1_QueryTotalPrincipalRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var collateralType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTotalPrincipalResponse defines the response type for the Query/TotalPrincipal RPC method.
struct Kava_Cdp_V1beta1_QueryTotalPrincipalResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var totalPrincipal: [Kava_Cdp_V1beta1_TotalPrincipal] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTotalCollateralRequest defines the request type for the Query/TotalCollateral RPC method.
struct Kava_Cdp_V1beta1_QueryTotalCollateralRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var collateralType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryTotalCollateralResponse defines the response type for the Query/TotalCollateral RPC method.
struct Kava_Cdp_V1beta1_QueryTotalCollateralResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var totalCollateral: [Kava_Cdp_V1beta1_TotalCollateral] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CDPResponse defines the state of a single collateralized debt position.
struct Kava_Cdp_V1beta1_CDPResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var owner: String = String()

  var type: String = String()

  var collateral: Cosmos_Base_V1beta1_Coin {
    get {return _collateral ?? Cosmos_Base_V1beta1_Coin()}
    set {_collateral = newValue}
  }
  /// Returns true if `collateral` has been explicitly set.
  var hasCollateral: Bool {return self._collateral != nil}
  /// Clears the value of `collateral`. Subsequent reads from it will return its default value.
  mutating func clearCollateral() {self._collateral = nil}

  var principal: Cosmos_Base_V1beta1_Coin {
    get {return _principal ?? Cosmos_Base_V1beta1_Coin()}
    set {_principal = newValue}
  }
  /// Returns true if `principal` has been explicitly set.
  var hasPrincipal: Bool {return self._principal != nil}
  /// Clears the value of `principal`. Subsequent reads from it will return its default value.
  mutating func clearPrincipal() {self._principal = nil}

  var accumulatedFees: Cosmos_Base_V1beta1_Coin {
    get {return _accumulatedFees ?? Cosmos_Base_V1beta1_Coin()}
    set {_accumulatedFees = newValue}
  }
  /// Returns true if `accumulatedFees` has been explicitly set.
  var hasAccumulatedFees: Bool {return self._accumulatedFees != nil}
  /// Clears the value of `accumulatedFees`. Subsequent reads from it will return its default value.
  mutating func clearAccumulatedFees() {self._accumulatedFees = nil}

  var feesUpdated: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _feesUpdated ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_feesUpdated = newValue}
  }
  /// Returns true if `feesUpdated` has been explicitly set.
  var hasFeesUpdated: Bool {return self._feesUpdated != nil}
  /// Clears the value of `feesUpdated`. Subsequent reads from it will return its default value.
  mutating func clearFeesUpdated() {self._feesUpdated = nil}

  var interestFactor: String = String()

  var collateralValue: Cosmos_Base_V1beta1_Coin {
    get {return _collateralValue ?? Cosmos_Base_V1beta1_Coin()}
    set {_collateralValue = newValue}
  }
  /// Returns true if `collateralValue` has been explicitly set.
  var hasCollateralValue: Bool {return self._collateralValue != nil}
  /// Clears the value of `collateralValue`. Subsequent reads from it will return its default value.
  mutating func clearCollateralValue() {self._collateralValue = nil}

  var collateralizationRatio: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _collateral: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _principal: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _accumulatedFees: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _feesUpdated: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _collateralValue: Cosmos_Base_V1beta1_Coin? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "kava.cdp.v1beta1"

extension Kava_Cdp_V1beta1_QueryParamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kava_Cdp_V1beta1_QueryParamsRequest, rhs: Kava_Cdp_V1beta1_QueryParamsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kava_Cdp_V1beta1_QueryParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kava_Cdp_V1beta1_QueryParamsResponse, rhs: Kava_Cdp_V1beta1_QueryParamsResponse) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kava_Cdp_V1beta1_QueryAccountsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAccountsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kava_Cdp_V1beta1_QueryAccountsRequest, rhs: Kava_Cdp_V1beta1_QueryAccountsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kava_Cdp_V1beta1_QueryAccountsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAccountsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accounts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kava_Cdp_V1beta1_QueryAccountsResponse, rhs: Kava_Cdp_V1beta1_QueryAccountsResponse) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kava_Cdp_V1beta1_QueryCdpRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCdpRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "collateral_type"),
    2: .same(proto: "owner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collateralType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collateralType.isEmpty {
      try visitor.visitSingularStringField(value: self.collateralType, fieldNumber: 1)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kava_Cdp_V1beta1_QueryCdpRequest, rhs: Kava_Cdp_V1beta1_QueryCdpRequest) -> Bool {
    if lhs.collateralType != rhs.collateralType {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kava_Cdp_V1beta1_QueryCdpResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCdpResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cdp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cdp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cdp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kava_Cdp_V1beta1_QueryCdpResponse, rhs: Kava_Cdp_V1beta1_QueryCdpResponse) -> Bool {
    if lhs._cdp != rhs._cdp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kava_Cdp_V1beta1_QueryCdpsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCdpsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "collateral_type"),
    2: .same(proto: "owner"),
    3: .same(proto: "id"),
    4: .same(proto: "ratio"),
    5: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collateralType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ratio) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collateralType.isEmpty {
      try visitor.visitSingularStringField(value: self.collateralType, fieldNumber: 1)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 2)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 3)
    }
    if !self.ratio.isEmpty {
      try visitor.visitSingularStringField(value: self.ratio, fieldNumber: 4)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kava_Cdp_V1beta1_QueryCdpsRequest, rhs: Kava_Cdp_V1beta1_QueryCdpsRequest) -> Bool {
    if lhs.collateralType != rhs.collateralType {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.id != rhs.id {return false}
    if lhs.ratio != rhs.ratio {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kava_Cdp_V1beta1_QueryCdpsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCdpsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cdps"),
    2: .same(proto: "pagination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cdps) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cdps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cdps, fieldNumber: 1)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kava_Cdp_V1beta1_QueryCdpsResponse, rhs: Kava_Cdp_V1beta1_QueryCdpsResponse) -> Bool {
    if lhs.cdps != rhs.cdps {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kava_Cdp_V1beta1_QueryDepositsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDepositsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "collateral_type"),
    2: .same(proto: "owner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collateralType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collateralType.isEmpty {
      try visitor.visitSingularStringField(value: self.collateralType, fieldNumber: 1)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kava_Cdp_V1beta1_QueryDepositsRequest, rhs: Kava_Cdp_V1beta1_QueryDepositsRequest) -> Bool {
    if lhs.collateralType != rhs.collateralType {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kava_Cdp_V1beta1_QueryDepositsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDepositsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deposits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.deposits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deposits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deposits, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kava_Cdp_V1beta1_QueryDepositsResponse, rhs: Kava_Cdp_V1beta1_QueryDepositsResponse) -> Bool {
    if lhs.deposits != rhs.deposits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kava_Cdp_V1beta1_QueryTotalPrincipalRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTotalPrincipalRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "collateral_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collateralType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collateralType.isEmpty {
      try visitor.visitSingularStringField(value: self.collateralType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kava_Cdp_V1beta1_QueryTotalPrincipalRequest, rhs: Kava_Cdp_V1beta1_QueryTotalPrincipalRequest) -> Bool {
    if lhs.collateralType != rhs.collateralType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kava_Cdp_V1beta1_QueryTotalPrincipalResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTotalPrincipalResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_principal"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.totalPrincipal) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.totalPrincipal.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.totalPrincipal, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kava_Cdp_V1beta1_QueryTotalPrincipalResponse, rhs: Kava_Cdp_V1beta1_QueryTotalPrincipalResponse) -> Bool {
    if lhs.totalPrincipal != rhs.totalPrincipal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kava_Cdp_V1beta1_QueryTotalCollateralRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTotalCollateralRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "collateral_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collateralType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collateralType.isEmpty {
      try visitor.visitSingularStringField(value: self.collateralType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kava_Cdp_V1beta1_QueryTotalCollateralRequest, rhs: Kava_Cdp_V1beta1_QueryTotalCollateralRequest) -> Bool {
    if lhs.collateralType != rhs.collateralType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kava_Cdp_V1beta1_QueryTotalCollateralResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryTotalCollateralResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_collateral"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.totalCollateral) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.totalCollateral.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.totalCollateral, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kava_Cdp_V1beta1_QueryTotalCollateralResponse, rhs: Kava_Cdp_V1beta1_QueryTotalCollateralResponse) -> Bool {
    if lhs.totalCollateral != rhs.totalCollateral {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kava_Cdp_V1beta1_CDPResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CDPResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "owner"),
    3: .same(proto: "type"),
    4: .same(proto: "collateral"),
    5: .same(proto: "principal"),
    6: .standard(proto: "accumulated_fees"),
    7: .standard(proto: "fees_updated"),
    8: .standard(proto: "interest_factor"),
    9: .standard(proto: "collateral_value"),
    10: .standard(proto: "collateralization_ratio"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._collateral) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._principal) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._accumulatedFees) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._feesUpdated) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.interestFactor) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._collateralValue) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.collateralizationRatio) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    if let v = self._collateral {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._principal {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._accumulatedFees {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._feesUpdated {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.interestFactor.isEmpty {
      try visitor.visitSingularStringField(value: self.interestFactor, fieldNumber: 8)
    }
    if let v = self._collateralValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if !self.collateralizationRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.collateralizationRatio, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kava_Cdp_V1beta1_CDPResponse, rhs: Kava_Cdp_V1beta1_CDPResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.type != rhs.type {return false}
    if lhs._collateral != rhs._collateral {return false}
    if lhs._principal != rhs._principal {return false}
    if lhs._accumulatedFees != rhs._accumulatedFees {return false}
    if lhs._feesUpdated != rhs._feesUpdated {return false}
    if lhs.interestFactor != rhs.interestFactor {return false}
    if lhs._collateralValue != rhs._collateralValue {return false}
    if lhs.collateralizationRatio != rhs.collateralizationRatio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
