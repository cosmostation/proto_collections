// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: gravity/v1/msgs.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MsgSendToEthereum submits a SendToEthereum attempt to bridge an asset over to
/// Ethereum. The SendToEthereum will be stored and then included in a batch and
/// then submitted to Ethereum.
struct Gravity_V1_MsgSendToEthereum {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var ethereumRecipient: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var bridgeFee: Cosmos_Base_V1beta1_Coin {
    get {return _bridgeFee ?? Cosmos_Base_V1beta1_Coin()}
    set {_bridgeFee = newValue}
  }
  /// Returns true if `bridgeFee` has been explicitly set.
  var hasBridgeFee: Bool {return self._bridgeFee != nil}
  /// Clears the value of `bridgeFee`. Subsequent reads from it will return its default value.
  mutating func clearBridgeFee() {self._bridgeFee = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _bridgeFee: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgSendToEthereumResponse returns the SendToEthereum transaction ID which
/// will be included in the batch tx.
struct Gravity_V1_MsgSendToEthereumResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCancelSendToEthereum allows the sender to cancel its own outgoing
/// SendToEthereum tx and recieve a refund of the tokens and bridge fees. This tx
/// will only succeed if the SendToEthereum tx hasn't been batched to be
/// processed and relayed to Ethereum.
struct Gravity_V1_MsgCancelSendToEthereum {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var sender: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Gravity_V1_MsgCancelSendToEthereumResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRequestBatchTx requests a batch of transactions with a given coin
/// denomination to send across the bridge to Ethereum.
struct Gravity_V1_MsgRequestBatchTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Gravity_V1_MsgRequestBatchTxResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgSubmitEthereumTxConfirmation submits an ethereum signature for a given
/// validator
struct Gravity_V1_MsgSubmitEthereumTxConfirmation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO: can we make this take an array?
  var confirmation: Google_Protobuf2_Any {
    get {return _confirmation ?? Google_Protobuf2_Any()}
    set {_confirmation = newValue}
  }
  /// Returns true if `confirmation` has been explicitly set.
  var hasConfirmation: Bool {return self._confirmation != nil}
  /// Clears the value of `confirmation`. Subsequent reads from it will return its default value.
  mutating func clearConfirmation() {self._confirmation = nil}

  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _confirmation: Google_Protobuf2_Any? = nil
}

/// ContractCallTxConfirmation is a signature on behalf of a validator for a
/// ContractCallTx.
struct Gravity_V1_ContractCallTxConfirmation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var invalidationScope: Data = Data()

  var invalidationNonce: UInt64 = 0

  var ethereumSigner: String = String()

  var signature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BatchTxConfirmation is a signature on behalf of a validator for a BatchTx.
struct Gravity_V1_BatchTxConfirmation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tokenContract: String = String()

  var batchNonce: UInt64 = 0

  var ethereumSigner: String = String()

  var signature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SignerSetTxConfirmation is a signature on behalf of a validator for a
/// SignerSetTx
struct Gravity_V1_SignerSetTxConfirmation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signerSetNonce: UInt64 = 0

  var ethereumSigner: String = String()

  var signature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Gravity_V1_MsgSubmitEthereumTxConfirmationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgSubmitEthereumEvent
struct Gravity_V1_MsgSubmitEthereumEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var event: Google_Protobuf2_Any {
    get {return _event ?? Google_Protobuf2_Any()}
    set {_event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  var hasEvent: Bool {return self._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  mutating func clearEvent() {self._event = nil}

  var signer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _event: Google_Protobuf2_Any? = nil
}

struct Gravity_V1_MsgSubmitEthereumEventResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDelegateKey allows validators to delegate their voting responsibilities
/// to a given orchestrator address. This key is then used as an optional
/// authentication method for attesting events from Ethereum.
struct Gravity_V1_MsgDelegateKeys {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var validatorAddress: String = String()

  var orchestratorAddress: String = String()

  var ethereumAddress: String = String()

  var ethSignature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Gravity_V1_MsgDelegateKeysResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DelegateKeysSignMsg defines the message structure an operator is expected to
/// sign when submitting a MsgDelegateKeys message. The resulting signature should
/// populate the eth_signature field.
struct Gravity_V1_DelegateKeysSignMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var validatorAddress: String = String()

  var nonce: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SendToCosmosEvent is submitted when the SendToCosmosEvent is emitted by they
/// gravity contract. ERC20 representation coins are minted to the cosmosreceiver
/// address.
struct Gravity_V1_SendToCosmosEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventNonce: UInt64 = 0

  var tokenContract: String = String()

  var amount: String = String()

  var ethereumSender: String = String()

  var cosmosReceiver: String = String()

  var ethereumHeight: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BatchExecutedEvent claims that a batch of BatchTxExecutedal operations on the
/// bridge contract was executed successfully on ETH
struct Gravity_V1_BatchExecutedEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tokenContract: String = String()

  var eventNonce: UInt64 = 0

  var ethereumHeight: UInt64 = 0

  var batchNonce: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// NOTE: bytes.HexBytes is supposed to "help" with json encoding/decoding
/// investigate?
struct Gravity_V1_ContractCallExecutedEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventNonce: UInt64 = 0

  var invalidationScope: Data = Data()

  var invalidationNonce: UInt64 = 0

  var ethereumHeight: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ERC20DeployedEvent is submitted when an ERC20 contract
/// for a Cosmos SDK coin has been deployed on Ethereum.
struct Gravity_V1_ERC20DeployedEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventNonce: UInt64 = 0

  var cosmosDenom: String = String()

  var tokenContract: String = String()

  var erc20Name: String = String()

  var erc20Symbol: String = String()

  var erc20Decimals: UInt64 = 0

  var ethereumHeight: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// This informs the Cosmos module that a validator
/// set has been updated.
struct Gravity_V1_SignerSetTxExecutedEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventNonce: UInt64 = 0

  var signerSetTxNonce: UInt64 = 0

  var ethereumHeight: UInt64 = 0

  var members: [Gravity_V1_EthereumSigner] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "gravity.v1"

extension Gravity_V1_MsgSendToEthereum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSendToEthereum"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "ethereum_recipient"),
    3: .same(proto: "amount"),
    4: .standard(proto: "bridge_fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ethereumRecipient) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._bridgeFee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.ethereumRecipient.isEmpty {
      try visitor.visitSingularStringField(value: self.ethereumRecipient, fieldNumber: 2)
    }
    if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._bridgeFee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgSendToEthereum, rhs: Gravity_V1_MsgSendToEthereum) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.ethereumRecipient != rhs.ethereumRecipient {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs._bridgeFee != rhs._bridgeFee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgSendToEthereumResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSendToEthereumResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgSendToEthereumResponse, rhs: Gravity_V1_MsgSendToEthereumResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgCancelSendToEthereum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelSendToEthereum"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "sender"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgCancelSendToEthereum, rhs: Gravity_V1_MsgCancelSendToEthereum) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgCancelSendToEthereumResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelSendToEthereumResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgCancelSendToEthereumResponse, rhs: Gravity_V1_MsgCancelSendToEthereumResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgRequestBatchTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRequestBatchTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgRequestBatchTx, rhs: Gravity_V1_MsgRequestBatchTx) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgRequestBatchTxResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRequestBatchTxResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgRequestBatchTxResponse, rhs: Gravity_V1_MsgRequestBatchTxResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgSubmitEthereumTxConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSubmitEthereumTxConfirmation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "confirmation"),
    2: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._confirmation) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._confirmation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgSubmitEthereumTxConfirmation, rhs: Gravity_V1_MsgSubmitEthereumTxConfirmation) -> Bool {
    if lhs._confirmation != rhs._confirmation {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_ContractCallTxConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractCallTxConfirmation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "invalidation_scope"),
    2: .standard(proto: "invalidation_nonce"),
    3: .standard(proto: "ethereum_signer"),
    4: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.invalidationScope) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.invalidationNonce) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ethereumSigner) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.invalidationScope.isEmpty {
      try visitor.visitSingularBytesField(value: self.invalidationScope, fieldNumber: 1)
    }
    if self.invalidationNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.invalidationNonce, fieldNumber: 2)
    }
    if !self.ethereumSigner.isEmpty {
      try visitor.visitSingularStringField(value: self.ethereumSigner, fieldNumber: 3)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_ContractCallTxConfirmation, rhs: Gravity_V1_ContractCallTxConfirmation) -> Bool {
    if lhs.invalidationScope != rhs.invalidationScope {return false}
    if lhs.invalidationNonce != rhs.invalidationNonce {return false}
    if lhs.ethereumSigner != rhs.ethereumSigner {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_BatchTxConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchTxConfirmation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_contract"),
    2: .standard(proto: "batch_nonce"),
    3: .standard(proto: "ethereum_signer"),
    4: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenContract) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.batchNonce) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ethereumSigner) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenContract.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenContract, fieldNumber: 1)
    }
    if self.batchNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.batchNonce, fieldNumber: 2)
    }
    if !self.ethereumSigner.isEmpty {
      try visitor.visitSingularStringField(value: self.ethereumSigner, fieldNumber: 3)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_BatchTxConfirmation, rhs: Gravity_V1_BatchTxConfirmation) -> Bool {
    if lhs.tokenContract != rhs.tokenContract {return false}
    if lhs.batchNonce != rhs.batchNonce {return false}
    if lhs.ethereumSigner != rhs.ethereumSigner {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_SignerSetTxConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignerSetTxConfirmation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signer_set_nonce"),
    2: .standard(proto: "ethereum_signer"),
    3: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.signerSetNonce) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ethereumSigner) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.signerSetNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.signerSetNonce, fieldNumber: 1)
    }
    if !self.ethereumSigner.isEmpty {
      try visitor.visitSingularStringField(value: self.ethereumSigner, fieldNumber: 2)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_SignerSetTxConfirmation, rhs: Gravity_V1_SignerSetTxConfirmation) -> Bool {
    if lhs.signerSetNonce != rhs.signerSetNonce {return false}
    if lhs.ethereumSigner != rhs.ethereumSigner {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgSubmitEthereumTxConfirmationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSubmitEthereumTxConfirmationResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgSubmitEthereumTxConfirmationResponse, rhs: Gravity_V1_MsgSubmitEthereumTxConfirmationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgSubmitEthereumEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSubmitEthereumEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "event"),
    2: .same(proto: "signer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgSubmitEthereumEvent, rhs: Gravity_V1_MsgSubmitEthereumEvent) -> Bool {
    if lhs._event != rhs._event {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgSubmitEthereumEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSubmitEthereumEventResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgSubmitEthereumEventResponse, rhs: Gravity_V1_MsgSubmitEthereumEventResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgDelegateKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDelegateKeys"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "validator_address"),
    2: .standard(proto: "orchestrator_address"),
    3: .standard(proto: "ethereum_address"),
    4: .standard(proto: "eth_signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.validatorAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.orchestratorAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ethereumAddress) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.ethSignature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddress, fieldNumber: 1)
    }
    if !self.orchestratorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.orchestratorAddress, fieldNumber: 2)
    }
    if !self.ethereumAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ethereumAddress, fieldNumber: 3)
    }
    if !self.ethSignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.ethSignature, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgDelegateKeys, rhs: Gravity_V1_MsgDelegateKeys) -> Bool {
    if lhs.validatorAddress != rhs.validatorAddress {return false}
    if lhs.orchestratorAddress != rhs.orchestratorAddress {return false}
    if lhs.ethereumAddress != rhs.ethereumAddress {return false}
    if lhs.ethSignature != rhs.ethSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgDelegateKeysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDelegateKeysResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgDelegateKeysResponse, rhs: Gravity_V1_MsgDelegateKeysResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_DelegateKeysSignMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DelegateKeysSignMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "validator_address"),
    2: .same(proto: "nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.validatorAddress) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddress, fieldNumber: 1)
    }
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_DelegateKeysSignMsg, rhs: Gravity_V1_DelegateKeysSignMsg) -> Bool {
    if lhs.validatorAddress != rhs.validatorAddress {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_SendToCosmosEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendToCosmosEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_nonce"),
    2: .standard(proto: "token_contract"),
    3: .same(proto: "amount"),
    4: .standard(proto: "ethereum_sender"),
    5: .standard(proto: "cosmos_receiver"),
    6: .standard(proto: "ethereum_height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.eventNonce) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenContract) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ethereumSender) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.cosmosReceiver) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.ethereumHeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventNonce, fieldNumber: 1)
    }
    if !self.tokenContract.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenContract, fieldNumber: 2)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 3)
    }
    if !self.ethereumSender.isEmpty {
      try visitor.visitSingularStringField(value: self.ethereumSender, fieldNumber: 4)
    }
    if !self.cosmosReceiver.isEmpty {
      try visitor.visitSingularStringField(value: self.cosmosReceiver, fieldNumber: 5)
    }
    if self.ethereumHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.ethereumHeight, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_SendToCosmosEvent, rhs: Gravity_V1_SendToCosmosEvent) -> Bool {
    if lhs.eventNonce != rhs.eventNonce {return false}
    if lhs.tokenContract != rhs.tokenContract {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.ethereumSender != rhs.ethereumSender {return false}
    if lhs.cosmosReceiver != rhs.cosmosReceiver {return false}
    if lhs.ethereumHeight != rhs.ethereumHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_BatchExecutedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchExecutedEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_contract"),
    2: .standard(proto: "event_nonce"),
    3: .standard(proto: "ethereum_height"),
    4: .standard(proto: "batch_nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenContract) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.eventNonce) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.ethereumHeight) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.batchNonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenContract.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenContract, fieldNumber: 1)
    }
    if self.eventNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventNonce, fieldNumber: 2)
    }
    if self.ethereumHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.ethereumHeight, fieldNumber: 3)
    }
    if self.batchNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.batchNonce, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_BatchExecutedEvent, rhs: Gravity_V1_BatchExecutedEvent) -> Bool {
    if lhs.tokenContract != rhs.tokenContract {return false}
    if lhs.eventNonce != rhs.eventNonce {return false}
    if lhs.ethereumHeight != rhs.ethereumHeight {return false}
    if lhs.batchNonce != rhs.batchNonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_ContractCallExecutedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractCallExecutedEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_nonce"),
    2: .standard(proto: "invalidation_scope"),
    3: .standard(proto: "invalidation_nonce"),
    4: .standard(proto: "ethereum_height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.eventNonce) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.invalidationScope) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.invalidationNonce) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.ethereumHeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventNonce, fieldNumber: 1)
    }
    if !self.invalidationScope.isEmpty {
      try visitor.visitSingularBytesField(value: self.invalidationScope, fieldNumber: 2)
    }
    if self.invalidationNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.invalidationNonce, fieldNumber: 3)
    }
    if self.ethereumHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.ethereumHeight, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_ContractCallExecutedEvent, rhs: Gravity_V1_ContractCallExecutedEvent) -> Bool {
    if lhs.eventNonce != rhs.eventNonce {return false}
    if lhs.invalidationScope != rhs.invalidationScope {return false}
    if lhs.invalidationNonce != rhs.invalidationNonce {return false}
    if lhs.ethereumHeight != rhs.ethereumHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_ERC20DeployedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ERC20DeployedEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_nonce"),
    2: .standard(proto: "cosmos_denom"),
    3: .standard(proto: "token_contract"),
    4: .standard(proto: "erc20_name"),
    5: .standard(proto: "erc20_symbol"),
    6: .standard(proto: "erc20_decimals"),
    7: .standard(proto: "ethereum_height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.eventNonce) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cosmosDenom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tokenContract) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.erc20Name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.erc20Symbol) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.erc20Decimals) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.ethereumHeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventNonce, fieldNumber: 1)
    }
    if !self.cosmosDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.cosmosDenom, fieldNumber: 2)
    }
    if !self.tokenContract.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenContract, fieldNumber: 3)
    }
    if !self.erc20Name.isEmpty {
      try visitor.visitSingularStringField(value: self.erc20Name, fieldNumber: 4)
    }
    if !self.erc20Symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.erc20Symbol, fieldNumber: 5)
    }
    if self.erc20Decimals != 0 {
      try visitor.visitSingularUInt64Field(value: self.erc20Decimals, fieldNumber: 6)
    }
    if self.ethereumHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.ethereumHeight, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_ERC20DeployedEvent, rhs: Gravity_V1_ERC20DeployedEvent) -> Bool {
    if lhs.eventNonce != rhs.eventNonce {return false}
    if lhs.cosmosDenom != rhs.cosmosDenom {return false}
    if lhs.tokenContract != rhs.tokenContract {return false}
    if lhs.erc20Name != rhs.erc20Name {return false}
    if lhs.erc20Symbol != rhs.erc20Symbol {return false}
    if lhs.erc20Decimals != rhs.erc20Decimals {return false}
    if lhs.ethereumHeight != rhs.ethereumHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_SignerSetTxExecutedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignerSetTxExecutedEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_nonce"),
    2: .standard(proto: "signer_set_tx_nonce"),
    3: .standard(proto: "ethereum_height"),
    4: .same(proto: "members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.eventNonce) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.signerSetTxNonce) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.ethereumHeight) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventNonce, fieldNumber: 1)
    }
    if self.signerSetTxNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.signerSetTxNonce, fieldNumber: 2)
    }
    if self.ethereumHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.ethereumHeight, fieldNumber: 3)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_SignerSetTxExecutedEvent, rhs: Gravity_V1_SignerSetTxExecutedEvent) -> Bool {
    if lhs.eventNonce != rhs.eventNonce {return false}
    if lhs.signerSetTxNonce != rhs.signerSetTxNonce {return false}
    if lhs.ethereumHeight != rhs.ethereumHeight {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
