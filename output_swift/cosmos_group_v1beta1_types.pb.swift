// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cosmos/group/v1beta1/types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Choice defines available types of choices for voting.
enum Cosmos_Group_V1beta1_Choice: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// CHOICE_UNSPECIFIED defines a no-op voting choice.
  case unspecified // = 0

  /// CHOICE_NO defines a no voting choice.
  case no // = 1

  /// CHOICE_YES defines a yes voting choice.
  case yes // = 2

  /// CHOICE_ABSTAIN defines an abstaining voting choice.
  case abstain // = 3

  /// CHOICE_VETO defines a voting choice with veto.
  case veto // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .no
    case 2: self = .yes
    case 3: self = .abstain
    case 4: self = .veto
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .no: return 1
    case .yes: return 2
    case .abstain: return 3
    case .veto: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Cosmos_Group_V1beta1_Choice: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Cosmos_Group_V1beta1_Choice] = [
    .unspecified,
    .no,
    .yes,
    .abstain,
    .veto,
  ]
}

#endif  // swift(>=4.2)

/// Member represents a group member with an account address,
/// non-zero weight and metadata.
struct Cosmos_Group_V1beta1_Member {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address is the member's account address.
  var address: String = String()

  /// weight is the member's voting weight that should be greater than 0.
  var weight: String = String()

  /// metadata is any arbitrary metadata to attached to the member.
  var metadata: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Members defines a repeated slice of Member objects.
struct Cosmos_Group_V1beta1_Members {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// members is the list of members.
  var members: [Cosmos_Group_V1beta1_Member] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ThresholdDecisionPolicy implements the DecisionPolicy interface
struct Cosmos_Group_V1beta1_ThresholdDecisionPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// threshold is the minimum weighted sum of yes votes that must be met or exceeded for a proposal to succeed.
  var threshold: String = String()

  /// timeout is the duration from submission of a proposal to the end of voting period
  /// Within this times votes and exec messages can be submitted.
  var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  mutating func clearTimeout() {self._timeout = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// GroupInfo represents the high-level on-chain information for a group.
struct Cosmos_Group_V1beta1_GroupInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group_id is the unique ID of the group.
  var groupID: UInt64 = 0

  /// admin is the account address of the group's admin.
  var admin: String = String()

  /// metadata is any arbitrary metadata to attached to the group.
  var metadata: Data = Data()

  /// version is used to track changes to a group's membership structure that
  /// would break existing proposals. Whenever any members weight is changed,
  /// or any member is added or removed this version is incremented and will
  /// cause proposals based on older versions of this group to fail
  var version: UInt64 = 0

  /// total_weight is the sum of the group members' weights.
  var totalWeight: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GroupMember represents the relationship between a group and a member.
struct Cosmos_Group_V1beta1_GroupMember {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group_id is the unique ID of the group.
  var groupID: UInt64 = 0

  /// member is the member data.
  var member: Cosmos_Group_V1beta1_Member {
    get {return _member ?? Cosmos_Group_V1beta1_Member()}
    set {_member = newValue}
  }
  /// Returns true if `member` has been explicitly set.
  var hasMember: Bool {return self._member != nil}
  /// Clears the value of `member`. Subsequent reads from it will return its default value.
  mutating func clearMember() {self._member = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _member: Cosmos_Group_V1beta1_Member? = nil
}

/// GroupAccountInfo represents the high-level on-chain information for a group account.
struct Cosmos_Group_V1beta1_GroupAccountInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address is the group account address.
  var address: String = String()

  /// group_id is the unique ID of the group.
  var groupID: UInt64 = 0

  /// admin is the account address of the group admin.
  var admin: String = String()

  /// metadata is any arbitrary metadata to attached to the group account.
  var metadata: Data = Data()

  /// version is used to track changes to a group's GroupAccountInfo structure that
  /// would create a different result on a running proposal.
  var version: UInt64 = 0

  /// decision_policy specifies the group account's decision policy.
  var decisionPolicy: Google_Protobuf_Any {
    get {return _decisionPolicy ?? Google_Protobuf_Any()}
    set {_decisionPolicy = newValue}
  }
  /// Returns true if `decisionPolicy` has been explicitly set.
  var hasDecisionPolicy: Bool {return self._decisionPolicy != nil}
  /// Clears the value of `decisionPolicy`. Subsequent reads from it will return its default value.
  mutating func clearDecisionPolicy() {self._decisionPolicy = nil}

  /// derivation_key is the "derivation" key of the group account,
  /// which is needed to derive the group root module key and execute proposals.
  var derivationKey: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _decisionPolicy: Google_Protobuf_Any? = nil
}

/// Proposal defines a group proposal. Any member of a group can submit a proposal
/// for a group account to decide upon.
/// A proposal consists of a set of `sdk.Msg`s that will be executed if the proposal
/// passes as well as some optional metadata associated with the proposal.
struct Cosmos_Group_V1beta1_Proposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// proposal_id is the unique id of the proposal.
  var proposalID: UInt64 {
    get {return _storage._proposalID}
    set {_uniqueStorage()._proposalID = newValue}
  }

  /// address is the group account address.
  var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// metadata is any arbitrary metadata to attached to the proposal.
  var metadata: Data {
    get {return _storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  /// proposers are the account addresses of the proposers.
  var proposers: [String] {
    get {return _storage._proposers}
    set {_uniqueStorage()._proposers = newValue}
  }

  /// submitted_at is a timestamp specifying when a proposal was submitted.
  var submittedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._submittedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._submittedAt = newValue}
  }
  /// Returns true if `submittedAt` has been explicitly set.
  var hasSubmittedAt: Bool {return _storage._submittedAt != nil}
  /// Clears the value of `submittedAt`. Subsequent reads from it will return its default value.
  mutating func clearSubmittedAt() {_uniqueStorage()._submittedAt = nil}

  /// group_version tracks the version of the group that this proposal corresponds to.
  /// When group membership is changed, existing proposals from previous group versions will become invalid.
  var groupVersion: UInt64 {
    get {return _storage._groupVersion}
    set {_uniqueStorage()._groupVersion = newValue}
  }

  /// group_account_version tracks the version of the group account that this proposal corresponds to.
  /// When a decision policy is changed, existing proposals from previous policy versions will become invalid.
  var groupAccountVersion: UInt64 {
    get {return _storage._groupAccountVersion}
    set {_uniqueStorage()._groupAccountVersion = newValue}
  }

  /// Status represents the high level position in the life cycle of the proposal. Initial value is Submitted.
  var status: Cosmos_Group_V1beta1_Proposal.Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// result is the final result based on the votes and election rule. Initial value is unfinalized.
  /// The result is persisted so that clients can always rely on this state and not have to replicate the logic.
  var result: Cosmos_Group_V1beta1_Proposal.Result {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  /// vote_state contains the sums of all weighted votes for this proposal.
  var voteState: Cosmos_Group_V1beta1_Tally {
    get {return _storage._voteState ?? Cosmos_Group_V1beta1_Tally()}
    set {_uniqueStorage()._voteState = newValue}
  }
  /// Returns true if `voteState` has been explicitly set.
  var hasVoteState: Bool {return _storage._voteState != nil}
  /// Clears the value of `voteState`. Subsequent reads from it will return its default value.
  mutating func clearVoteState() {_uniqueStorage()._voteState = nil}

  /// timeout is the timestamp of the block where the proposal execution times out. Header times of the votes and
  /// execution messages must be before this end time to be included in the election. After the timeout timestamp the
  /// proposal can not be executed anymore and should be considered pending delete.
  var timeout: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timeout ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  var hasTimeout: Bool {return _storage._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  mutating func clearTimeout() {_uniqueStorage()._timeout = nil}

  /// executor_result is the final result based on the votes and election rule. Initial value is NotRun.
  var executorResult: Cosmos_Group_V1beta1_Proposal.ExecutorResult {
    get {return _storage._executorResult}
    set {_uniqueStorage()._executorResult = newValue}
  }

  /// msgs is a list of Msgs that will be executed if the proposal passes.
  var msgs: [Google_Protobuf_Any] {
    get {return _storage._msgs}
    set {_uniqueStorage()._msgs = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Status defines proposal statuses.
  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// An empty value is invalid and not allowed.
    case unspecified // = 0

    /// Initial status of a proposal when persisted.
    case submitted // = 1

    /// Final status of a proposal when the final tally was executed.
    case closed // = 2

    /// Final status of a proposal when the group was modified before the final tally.
    case aborted // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .submitted
      case 2: self = .closed
      case 3: self = .aborted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .submitted: return 1
      case .closed: return 2
      case .aborted: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Result defines types of proposal results.
  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// An empty value is invalid and not allowed
    case unspecified // = 0

    /// Until a final tally has happened the status is unfinalized
    case unfinalized // = 1

    /// Final result of the tally
    case accepted // = 2

    /// Final result of the tally
    case rejected // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .unfinalized
      case 2: self = .accepted
      case 3: self = .rejected
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .unfinalized: return 1
      case .accepted: return 2
      case .rejected: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// ExecutorResult defines types of proposal executor results.
  enum ExecutorResult: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// An empty value is not allowed.
    case unspecified // = 0

    /// We have not yet run the executor.
    case notRun // = 1

    /// The executor was successful and proposed action updated state.
    case success // = 2

    /// The executor returned an error and proposed action didn't update state.
    case failure // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .notRun
      case 2: self = .success
      case 3: self = .failure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .notRun: return 1
      case .success: return 2
      case .failure: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Cosmos_Group_V1beta1_Proposal.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Cosmos_Group_V1beta1_Proposal.Status] = [
    .unspecified,
    .submitted,
    .closed,
    .aborted,
  ]
}

extension Cosmos_Group_V1beta1_Proposal.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Cosmos_Group_V1beta1_Proposal.Result] = [
    .unspecified,
    .unfinalized,
    .accepted,
    .rejected,
  ]
}

extension Cosmos_Group_V1beta1_Proposal.ExecutorResult: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Cosmos_Group_V1beta1_Proposal.ExecutorResult] = [
    .unspecified,
    .notRun,
    .success,
    .failure,
  ]
}

#endif  // swift(>=4.2)

/// Tally represents the sum of weighted votes.
struct Cosmos_Group_V1beta1_Tally {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// yes_count is the weighted sum of yes votes.
  var yesCount: String = String()

  /// no_count is the weighted sum of no votes.
  var noCount: String = String()

  /// abstain_count is the weighted sum of abstainers
  var abstainCount: String = String()

  /// veto_count is the weighted sum of vetoes.
  var vetoCount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Vote represents a vote for a proposal.
struct Cosmos_Group_V1beta1_Vote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// proposal is the unique ID of the proposal.
  var proposalID: UInt64 = 0

  /// voter is the account address of the voter.
  var voter: String = String()

  /// choice is the voter's choice on the proposal.
  var choice: Cosmos_Group_V1beta1_Choice = .unspecified

  /// metadata is any arbitrary metadata to attached to the vote.
  var metadata: Data = Data()

  /// submitted_at is the timestamp when the vote was submitted.
  var submittedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _submittedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_submittedAt = newValue}
  }
  /// Returns true if `submittedAt` has been explicitly set.
  var hasSubmittedAt: Bool {return self._submittedAt != nil}
  /// Clears the value of `submittedAt`. Subsequent reads from it will return its default value.
  mutating func clearSubmittedAt() {self._submittedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _submittedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cosmos.group.v1beta1"

extension Cosmos_Group_V1beta1_Choice: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHOICE_UNSPECIFIED"),
    1: .same(proto: "CHOICE_NO"),
    2: .same(proto: "CHOICE_YES"),
    3: .same(proto: "CHOICE_ABSTAIN"),
    4: .same(proto: "CHOICE_VETO"),
  ]
}

extension Cosmos_Group_V1beta1_Member: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Member"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "weight"),
    3: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.weight) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.weight.isEmpty {
      try visitor.visitSingularStringField(value: self.weight, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1beta1_Member, rhs: Cosmos_Group_V1beta1_Member) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Group_V1beta1_Members: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Members"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1beta1_Members, rhs: Cosmos_Group_V1beta1_Members) -> Bool {
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Group_V1beta1_ThresholdDecisionPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThresholdDecisionPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threshold"),
    2: .same(proto: "timeout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.threshold) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timeout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.threshold.isEmpty {
      try visitor.visitSingularStringField(value: self.threshold, fieldNumber: 1)
    }
    if let v = self._timeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1beta1_ThresholdDecisionPolicy, rhs: Cosmos_Group_V1beta1_ThresholdDecisionPolicy) -> Bool {
    if lhs.threshold != rhs.threshold {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Group_V1beta1_GroupInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .same(proto: "admin"),
    3: .same(proto: "metadata"),
    4: .same(proto: "version"),
    5: .standard(proto: "total_weight"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.admin) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.version) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.totalWeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularUInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if !self.admin.isEmpty {
      try visitor.visitSingularStringField(value: self.admin, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 3)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt64Field(value: self.version, fieldNumber: 4)
    }
    if !self.totalWeight.isEmpty {
      try visitor.visitSingularStringField(value: self.totalWeight, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1beta1_GroupInfo, rhs: Cosmos_Group_V1beta1_GroupInfo) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.admin != rhs.admin {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.version != rhs.version {return false}
    if lhs.totalWeight != rhs.totalWeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Group_V1beta1_GroupMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupMember"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .same(proto: "member"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularUInt64Field(value: self.groupID, fieldNumber: 1)
    }
    if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1beta1_GroupMember, rhs: Cosmos_Group_V1beta1_GroupMember) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._member != rhs._member {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Group_V1beta1_GroupAccountInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupAccountInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "group_id"),
    3: .same(proto: "admin"),
    4: .same(proto: "metadata"),
    5: .same(proto: "version"),
    6: .standard(proto: "decision_policy"),
    7: .standard(proto: "derivation_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.admin) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.version) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._decisionPolicy) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.derivationKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.groupID != 0 {
      try visitor.visitSingularUInt64Field(value: self.groupID, fieldNumber: 2)
    }
    if !self.admin.isEmpty {
      try visitor.visitSingularStringField(value: self.admin, fieldNumber: 3)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 4)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt64Field(value: self.version, fieldNumber: 5)
    }
    if let v = self._decisionPolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.derivationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.derivationKey, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1beta1_GroupAccountInfo, rhs: Cosmos_Group_V1beta1_GroupAccountInfo) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.admin != rhs.admin {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.version != rhs.version {return false}
    if lhs._decisionPolicy != rhs._decisionPolicy {return false}
    if lhs.derivationKey != rhs.derivationKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Group_V1beta1_Proposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Proposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "proposal_id"),
    2: .same(proto: "address"),
    3: .same(proto: "metadata"),
    4: .same(proto: "proposers"),
    5: .standard(proto: "submitted_at"),
    6: .standard(proto: "group_version"),
    7: .standard(proto: "group_account_version"),
    8: .same(proto: "status"),
    9: .same(proto: "result"),
    10: .standard(proto: "vote_state"),
    11: .same(proto: "timeout"),
    12: .standard(proto: "executor_result"),
    13: .same(proto: "msgs"),
  ]

  fileprivate class _StorageClass {
    var _proposalID: UInt64 = 0
    var _address: String = String()
    var _metadata: Data = Data()
    var _proposers: [String] = []
    var _submittedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _groupVersion: UInt64 = 0
    var _groupAccountVersion: UInt64 = 0
    var _status: Cosmos_Group_V1beta1_Proposal.Status = .unspecified
    var _result: Cosmos_Group_V1beta1_Proposal.Result = .unspecified
    var _voteState: Cosmos_Group_V1beta1_Tally? = nil
    var _timeout: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _executorResult: Cosmos_Group_V1beta1_Proposal.ExecutorResult = .unspecified
    var _msgs: [Google_Protobuf_Any] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _proposalID = source._proposalID
      _address = source._address
      _metadata = source._metadata
      _proposers = source._proposers
      _submittedAt = source._submittedAt
      _groupVersion = source._groupVersion
      _groupAccountVersion = source._groupAccountVersion
      _status = source._status
      _result = source._result
      _voteState = source._voteState
      _timeout = source._timeout
      _executorResult = source._executorResult
      _msgs = source._msgs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._proposalID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._address) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._metadata) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._proposers) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._submittedAt) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._groupVersion) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._groupAccountVersion) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._result) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._voteState) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._timeout) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._executorResult) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._msgs) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._proposalID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._proposalID, fieldNumber: 1)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 2)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._metadata, fieldNumber: 3)
      }
      if !_storage._proposers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._proposers, fieldNumber: 4)
      }
      if let v = _storage._submittedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if _storage._groupVersion != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._groupVersion, fieldNumber: 6)
      }
      if _storage._groupAccountVersion != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._groupAccountVersion, fieldNumber: 7)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 8)
      }
      if _storage._result != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._result, fieldNumber: 9)
      }
      if let v = _storage._voteState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._timeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if _storage._executorResult != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._executorResult, fieldNumber: 12)
      }
      if !_storage._msgs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._msgs, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1beta1_Proposal, rhs: Cosmos_Group_V1beta1_Proposal) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._proposalID != rhs_storage._proposalID {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._proposers != rhs_storage._proposers {return false}
        if _storage._submittedAt != rhs_storage._submittedAt {return false}
        if _storage._groupVersion != rhs_storage._groupVersion {return false}
        if _storage._groupAccountVersion != rhs_storage._groupAccountVersion {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._result != rhs_storage._result {return false}
        if _storage._voteState != rhs_storage._voteState {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._executorResult != rhs_storage._executorResult {return false}
        if _storage._msgs != rhs_storage._msgs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Group_V1beta1_Proposal.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "STATUS_SUBMITTED"),
    2: .same(proto: "STATUS_CLOSED"),
    3: .same(proto: "STATUS_ABORTED"),
  ]
}

extension Cosmos_Group_V1beta1_Proposal.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_UNSPECIFIED"),
    1: .same(proto: "RESULT_UNFINALIZED"),
    2: .same(proto: "RESULT_ACCEPTED"),
    3: .same(proto: "RESULT_REJECTED"),
  ]
}

extension Cosmos_Group_V1beta1_Proposal.ExecutorResult: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXECUTOR_RESULT_UNSPECIFIED"),
    1: .same(proto: "EXECUTOR_RESULT_NOT_RUN"),
    2: .same(proto: "EXECUTOR_RESULT_SUCCESS"),
    3: .same(proto: "EXECUTOR_RESULT_FAILURE"),
  ]
}

extension Cosmos_Group_V1beta1_Tally: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Tally"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "yes_count"),
    2: .standard(proto: "no_count"),
    3: .standard(proto: "abstain_count"),
    4: .standard(proto: "veto_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.yesCount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.noCount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.abstainCount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.vetoCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.yesCount.isEmpty {
      try visitor.visitSingularStringField(value: self.yesCount, fieldNumber: 1)
    }
    if !self.noCount.isEmpty {
      try visitor.visitSingularStringField(value: self.noCount, fieldNumber: 2)
    }
    if !self.abstainCount.isEmpty {
      try visitor.visitSingularStringField(value: self.abstainCount, fieldNumber: 3)
    }
    if !self.vetoCount.isEmpty {
      try visitor.visitSingularStringField(value: self.vetoCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1beta1_Tally, rhs: Cosmos_Group_V1beta1_Tally) -> Bool {
    if lhs.yesCount != rhs.yesCount {return false}
    if lhs.noCount != rhs.noCount {return false}
    if lhs.abstainCount != rhs.abstainCount {return false}
    if lhs.vetoCount != rhs.vetoCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Group_V1beta1_Vote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Vote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "proposal_id"),
    2: .same(proto: "voter"),
    3: .same(proto: "choice"),
    4: .same(proto: "metadata"),
    5: .standard(proto: "submitted_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.proposalID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.voter) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.choice) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._submittedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.proposalID != 0 {
      try visitor.visitSingularUInt64Field(value: self.proposalID, fieldNumber: 1)
    }
    if !self.voter.isEmpty {
      try visitor.visitSingularStringField(value: self.voter, fieldNumber: 2)
    }
    if self.choice != .unspecified {
      try visitor.visitSingularEnumField(value: self.choice, fieldNumber: 3)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 4)
    }
    if let v = self._submittedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1beta1_Vote, rhs: Cosmos_Group_V1beta1_Vote) -> Bool {
    if lhs.proposalID != rhs.proposalID {return false}
    if lhs.voter != rhs.voter {return false}
    if lhs.choice != rhs.choice {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs._submittedAt != rhs._submittedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
