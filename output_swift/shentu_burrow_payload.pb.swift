// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: shentu/burrow/payload.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Any encodes a sum type for which only one should be set
struct Payload_Any {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var callTx: Payload_CallTx {
    get {return _storage._callTx ?? Payload_CallTx()}
    set {_uniqueStorage()._callTx = newValue}
  }
  /// Returns true if `callTx` has been explicitly set.
  var hasCallTx: Bool {return _storage._callTx != nil}
  /// Clears the value of `callTx`. Subsequent reads from it will return its default value.
  mutating func clearCallTx() {_uniqueStorage()._callTx = nil}

  var sendTx: Payload_SendTx {
    get {return _storage._sendTx ?? Payload_SendTx()}
    set {_uniqueStorage()._sendTx = newValue}
  }
  /// Returns true if `sendTx` has been explicitly set.
  var hasSendTx: Bool {return _storage._sendTx != nil}
  /// Clears the value of `sendTx`. Subsequent reads from it will return its default value.
  mutating func clearSendTx() {_uniqueStorage()._sendTx = nil}

  var nameTx: Payload_NameTx {
    get {return _storage._nameTx ?? Payload_NameTx()}
    set {_uniqueStorage()._nameTx = newValue}
  }
  /// Returns true if `nameTx` has been explicitly set.
  var hasNameTx: Bool {return _storage._nameTx != nil}
  /// Clears the value of `nameTx`. Subsequent reads from it will return its default value.
  mutating func clearNameTx() {_uniqueStorage()._nameTx = nil}

  var permsTx: Payload_PermsTx {
    get {return _storage._permsTx ?? Payload_PermsTx()}
    set {_uniqueStorage()._permsTx = newValue}
  }
  /// Returns true if `permsTx` has been explicitly set.
  var hasPermsTx: Bool {return _storage._permsTx != nil}
  /// Clears the value of `permsTx`. Subsequent reads from it will return its default value.
  mutating func clearPermsTx() {_uniqueStorage()._permsTx = nil}

  var govTx: Payload_GovTx {
    get {return _storage._govTx ?? Payload_GovTx()}
    set {_uniqueStorage()._govTx = newValue}
  }
  /// Returns true if `govTx` has been explicitly set.
  var hasGovTx: Bool {return _storage._govTx != nil}
  /// Clears the value of `govTx`. Subsequent reads from it will return its default value.
  mutating func clearGovTx() {_uniqueStorage()._govTx = nil}

  var bondTx: Payload_BondTx {
    get {return _storage._bondTx ?? Payload_BondTx()}
    set {_uniqueStorage()._bondTx = newValue}
  }
  /// Returns true if `bondTx` has been explicitly set.
  var hasBondTx: Bool {return _storage._bondTx != nil}
  /// Clears the value of `bondTx`. Subsequent reads from it will return its default value.
  mutating func clearBondTx() {_uniqueStorage()._bondTx = nil}

  var unbondTx: Payload_UnbondTx {
    get {return _storage._unbondTx ?? Payload_UnbondTx()}
    set {_uniqueStorage()._unbondTx = newValue}
  }
  /// Returns true if `unbondTx` has been explicitly set.
  var hasUnbondTx: Bool {return _storage._unbondTx != nil}
  /// Clears the value of `unbondTx`. Subsequent reads from it will return its default value.
  mutating func clearUnbondTx() {_uniqueStorage()._unbondTx = nil}

  var batchTx: Payload_BatchTx {
    get {return _storage._batchTx ?? Payload_BatchTx()}
    set {_uniqueStorage()._batchTx = newValue}
  }
  /// Returns true if `batchTx` has been explicitly set.
  var hasBatchTx: Bool {return _storage._batchTx != nil}
  /// Clears the value of `batchTx`. Subsequent reads from it will return its default value.
  mutating func clearBatchTx() {_uniqueStorage()._batchTx = nil}

  var proposalTx: Payload_ProposalTx {
    get {return _storage._proposalTx ?? Payload_ProposalTx()}
    set {_uniqueStorage()._proposalTx = newValue}
  }
  /// Returns true if `proposalTx` has been explicitly set.
  var hasProposalTx: Bool {return _storage._proposalTx != nil}
  /// Clears the value of `proposalTx`. Subsequent reads from it will return its default value.
  mutating func clearProposalTx() {_uniqueStorage()._proposalTx = nil}

  var identifyTx: Payload_IdentifyTx {
    get {return _storage._identifyTx ?? Payload_IdentifyTx()}
    set {_uniqueStorage()._identifyTx = newValue}
  }
  /// Returns true if `identifyTx` has been explicitly set.
  var hasIdentifyTx: Bool {return _storage._identifyTx != nil}
  /// Clears the value of `identifyTx`. Subsequent reads from it will return its default value.
  mutating func clearIdentifyTx() {_uniqueStorage()._identifyTx = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// An input to a transaction that may carry an Amount as a charge and whose sequence number must be one greater than
/// that associated with the account at Address at the time of being received
struct Payload_TxInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The address from which this input flows
  var address: Data = Data()

  /// The amount of native token to transfer from the input address
  var amount: UInt64 = 0

  /// The sequence number that this transaction will induce (i.e. one greater than the input account's current sequence)
  var sequence: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An output from a transaction that may carry an amount as a charge
struct Payload_TxOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The address to which this output flows
  var address: Data = Data()

  /// The amount of native token to transfer to the output address
  var amount: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A instruction to run smart contract code in the EVM
struct Payload_CallTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The caller's input
  var input: Payload_TxInput {
    get {return _input ?? Payload_TxInput()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  /// The contract address to call or nil if we are creating a contract
  var address: Data = Data()

  /// The upper bound on the amount of gas (and therefore EVM execution steps) this CallTx may generate
  var gasLimit: UInt64 = 0

  /// Fee to offer validators for processing transaction
  var fee: UInt64 = 0

  /// EVM bytecode
  var data: Data = Data()

  /// WASM bytecode
  var wasm: Data = Data()

  /// Set of contracts this code will deploy
  var contractMeta: [Payload_ContractMeta] = []

  /// The upper bound on the price per unit of gas
  var gasPrice: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _input: Payload_TxInput? = nil
}

struct Payload_ContractMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var codeHash: Data = Data()

  var meta: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A payment between two sets of parties
struct Payload_SendTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The payers
  var inputs: [Payload_TxInput] = []

  /// The payees
  var outputs: [Payload_TxOutput] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An update to the on-chain permissions
struct Payload_PermsTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The permission moderator
  var input: Payload_TxInput {
    get {return _input ?? Payload_TxInput()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  /// The modified permissions
  var permArgs: Permission_PermArgs {
    get {return _permArgs ?? Permission_PermArgs()}
    set {_permArgs = newValue}
  }
  /// Returns true if `permArgs` has been explicitly set.
  var hasPermArgs: Bool {return self._permArgs != nil}
  /// Clears the value of `permArgs`. Subsequent reads from it will return its default value.
  mutating func clearPermArgs() {self._permArgs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _input: Payload_TxInput? = nil
  fileprivate var _permArgs: Permission_PermArgs? = nil
}

/// A request to claim a globally unique name across the entire chain with some optional data storage leased for a fee
struct Payload_NameTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name updater
  var input: Payload_TxInput {
    get {return _input ?? Payload_TxInput()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  /// The name to update or create
  var name: String = String()

  /// The data to store against the name
  var data: String = String()

  /// The fee to provide that will determine the length of the name lease
  var fee: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _input: Payload_TxInput? = nil
}

struct Payload_BondTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Input must be the validator that desires to bond
  var input: Payload_TxInput {
    get {return _input ?? Payload_TxInput()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _input: Payload_TxInput? = nil
}

struct Payload_UnbondTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var input: Payload_TxInput {
    get {return _input ?? Payload_TxInput()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  /// Account to unbond
  var output: Payload_TxOutput {
    get {return _output ?? Payload_TxOutput()}
    set {_output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  var hasOutput: Bool {return self._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  mutating func clearOutput() {self._output = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _input: Payload_TxInput? = nil
  fileprivate var _output: Payload_TxOutput? = nil
}

struct Payload_GovTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inputs: [Payload_TxInput] = []

  var accountUpdates: [Spec_TemplateAccount] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Payload_ProposalTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var input: Payload_TxInput {
    get {return _input ?? Payload_TxInput()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  var votingWeight: Int64 = 0

  var proposalHash: Data = Data()

  var proposal: Payload_Proposal {
    get {return _proposal ?? Payload_Proposal()}
    set {_proposal = newValue}
  }
  /// Returns true if `proposal` has been explicitly set.
  var hasProposal: Bool {return self._proposal != nil}
  /// Clears the value of `proposal`. Subsequent reads from it will return its default value.
  mutating func clearProposal() {self._proposal = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _input: Payload_TxInput? = nil
  fileprivate var _proposal: Payload_Proposal? = nil
}

struct Payload_IdentifyTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Senders
  var inputs: [Payload_TxInput] = []

  /// Node to register
  var node: Registry_NodeIdentity {
    get {return _node ?? Registry_NodeIdentity()}
    set {_node = newValue}
  }
  /// Returns true if `node` has been explicitly set.
  var hasNode: Bool {return self._node != nil}
  /// Clears the value of `node`. Subsequent reads from it will return its default value.
  mutating func clearNode() {self._node = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _node: Registry_NodeIdentity? = nil
}

struct Payload_BatchTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inputs: [Payload_TxInput] = []

  var txs: [Payload_Any] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Payload_Vote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: Data = Data()

  var votingWeight: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Payload_Proposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var description_p: String = String()

  var batchTx: Payload_BatchTx {
    get {return _batchTx ?? Payload_BatchTx()}
    set {_batchTx = newValue}
  }
  /// Returns true if `batchTx` has been explicitly set.
  var hasBatchTx: Bool {return self._batchTx != nil}
  /// Clears the value of `batchTx`. Subsequent reads from it will return its default value.
  mutating func clearBatchTx() {self._batchTx = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _batchTx: Payload_BatchTx? = nil
}

struct Payload_Ballot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var proposal: Payload_Proposal {
    get {return _proposal ?? Payload_Proposal()}
    set {_proposal = newValue}
  }
  /// Returns true if `proposal` has been explicitly set.
  var hasProposal: Bool {return self._proposal != nil}
  /// Clears the value of `proposal`. Subsequent reads from it will return its default value.
  mutating func clearProposal() {self._proposal = nil}

  var finalizingTx: Data = Data()

  var proposalState: Payload_Ballot.ProposalState = .proposed

  var votes: [Payload_Vote] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ProposalState: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// PROPOSED might be expired, if sequence number of any of the input accounts are out of date
    case proposed // = 0
    case executed // = 1
    case failed // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .proposed
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .proposed
      case 1: self = .executed
      case 2: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .proposed: return 0
      case .executed: return 1
      case .failed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _proposal: Payload_Proposal? = nil
}

#if swift(>=4.2)

extension Payload_Ballot.ProposalState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Payload_Ballot.ProposalState] = [
    .proposed,
    .executed,
    .failed,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "payload"

extension Payload_Any: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Any"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CallTx"),
    2: .same(proto: "SendTx"),
    3: .same(proto: "NameTx"),
    4: .same(proto: "PermsTx"),
    5: .same(proto: "GovTx"),
    6: .same(proto: "BondTx"),
    7: .same(proto: "UnbondTx"),
    8: .same(proto: "BatchTx"),
    9: .same(proto: "ProposalTx"),
    10: .same(proto: "IdentifyTx"),
  ]

  fileprivate class _StorageClass {
    var _callTx: Payload_CallTx? = nil
    var _sendTx: Payload_SendTx? = nil
    var _nameTx: Payload_NameTx? = nil
    var _permsTx: Payload_PermsTx? = nil
    var _govTx: Payload_GovTx? = nil
    var _bondTx: Payload_BondTx? = nil
    var _unbondTx: Payload_UnbondTx? = nil
    var _batchTx: Payload_BatchTx? = nil
    var _proposalTx: Payload_ProposalTx? = nil
    var _identifyTx: Payload_IdentifyTx? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _callTx = source._callTx
      _sendTx = source._sendTx
      _nameTx = source._nameTx
      _permsTx = source._permsTx
      _govTx = source._govTx
      _bondTx = source._bondTx
      _unbondTx = source._unbondTx
      _batchTx = source._batchTx
      _proposalTx = source._proposalTx
      _identifyTx = source._identifyTx
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._callTx) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._sendTx) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._nameTx) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._permsTx) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._govTx) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._bondTx) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._unbondTx) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._batchTx) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._proposalTx) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._identifyTx) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._callTx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._sendTx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._nameTx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._permsTx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._govTx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._bondTx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._unbondTx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._batchTx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._proposalTx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._identifyTx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_Any, rhs: Payload_Any) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._callTx != rhs_storage._callTx {return false}
        if _storage._sendTx != rhs_storage._sendTx {return false}
        if _storage._nameTx != rhs_storage._nameTx {return false}
        if _storage._permsTx != rhs_storage._permsTx {return false}
        if _storage._govTx != rhs_storage._govTx {return false}
        if _storage._bondTx != rhs_storage._bondTx {return false}
        if _storage._unbondTx != rhs_storage._unbondTx {return false}
        if _storage._batchTx != rhs_storage._batchTx {return false}
        if _storage._proposalTx != rhs_storage._proposalTx {return false}
        if _storage._identifyTx != rhs_storage._identifyTx {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_TxInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Address"),
    2: .same(proto: "Amount"),
    3: .same(proto: "Sequence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.sequence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 2)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequence, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_TxInput, rhs: Payload_TxInput) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_TxOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxOutput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Address"),
    2: .same(proto: "Amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_TxOutput, rhs: Payload_TxOutput) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_CallTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Input"),
    2: .same(proto: "Address"),
    3: .same(proto: "GasLimit"),
    4: .same(proto: "Fee"),
    5: .same(proto: "Data"),
    6: .same(proto: "WASM"),
    7: .same(proto: "ContractMeta"),
    8: .same(proto: "GasPrice"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.gasLimit) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.fee) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.wasm) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.contractMeta) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.gasPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 2)
    }
    if self.gasLimit != 0 {
      try visitor.visitSingularUInt64Field(value: self.gasLimit, fieldNumber: 3)
    }
    if self.fee != 0 {
      try visitor.visitSingularUInt64Field(value: self.fee, fieldNumber: 4)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 5)
    }
    if !self.wasm.isEmpty {
      try visitor.visitSingularBytesField(value: self.wasm, fieldNumber: 6)
    }
    if !self.contractMeta.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contractMeta, fieldNumber: 7)
    }
    if self.gasPrice != 0 {
      try visitor.visitSingularUInt64Field(value: self.gasPrice, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_CallTx, rhs: Payload_CallTx) -> Bool {
    if lhs._input != rhs._input {return false}
    if lhs.address != rhs.address {return false}
    if lhs.gasLimit != rhs.gasLimit {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.data != rhs.data {return false}
    if lhs.wasm != rhs.wasm {return false}
    if lhs.contractMeta != rhs.contractMeta {return false}
    if lhs.gasPrice != rhs.gasPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_ContractMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractMeta"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CodeHash"),
    2: .same(proto: "Meta"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.codeHash) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.meta) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.codeHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.codeHash, fieldNumber: 1)
    }
    if !self.meta.isEmpty {
      try visitor.visitSingularStringField(value: self.meta, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_ContractMeta, rhs: Payload_ContractMeta) -> Bool {
    if lhs.codeHash != rhs.codeHash {return false}
    if lhs.meta != rhs.meta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_SendTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Inputs"),
    2: .same(proto: "Outputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_SendTx, rhs: Payload_SendTx) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_PermsTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PermsTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Input"),
    2: .same(proto: "PermArgs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._permArgs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._permArgs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_PermsTx, rhs: Payload_PermsTx) -> Bool {
    if lhs._input != rhs._input {return false}
    if lhs._permArgs != rhs._permArgs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_NameTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NameTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Input"),
    2: .same(proto: "Name"),
    3: .same(proto: "Data"),
    4: .same(proto: "Fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.data) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.fee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 3)
    }
    if self.fee != 0 {
      try visitor.visitSingularUInt64Field(value: self.fee, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_NameTx, rhs: Payload_NameTx) -> Bool {
    if lhs._input != rhs._input {return false}
    if lhs.name != rhs.name {return false}
    if lhs.data != rhs.data {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_BondTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BondTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Input"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_BondTx, rhs: Payload_BondTx) -> Bool {
    if lhs._input != rhs._input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_UnbondTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnbondTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Input"),
    2: .same(proto: "Output"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._output) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._output {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_UnbondTx, rhs: Payload_UnbondTx) -> Bool {
    if lhs._input != rhs._input {return false}
    if lhs._output != rhs._output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_GovTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GovTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Inputs"),
    2: .same(proto: "AccountUpdates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.accountUpdates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    if !self.accountUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accountUpdates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_GovTx, rhs: Payload_GovTx) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.accountUpdates != rhs.accountUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_ProposalTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProposalTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Input"),
    2: .same(proto: "VotingWeight"),
    3: .same(proto: "ProposalHash"),
    4: .same(proto: "Proposal"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.votingWeight) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.proposalHash) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._proposal) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.votingWeight != 0 {
      try visitor.visitSingularInt64Field(value: self.votingWeight, fieldNumber: 2)
    }
    if !self.proposalHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.proposalHash, fieldNumber: 3)
    }
    if let v = self._proposal {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_ProposalTx, rhs: Payload_ProposalTx) -> Bool {
    if lhs._input != rhs._input {return false}
    if lhs.votingWeight != rhs.votingWeight {return false}
    if lhs.proposalHash != rhs.proposalHash {return false}
    if lhs._proposal != rhs._proposal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_IdentifyTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IdentifyTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Inputs"),
    2: .same(proto: "Node"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._node) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    if let v = self._node {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_IdentifyTx, rhs: Payload_IdentifyTx) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs._node != rhs._node {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_BatchTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Inputs"),
    2: .same(proto: "Txs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.txs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    if !self.txs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.txs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_BatchTx, rhs: Payload_BatchTx) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.txs != rhs.txs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_Vote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Vote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Address"),
    2: .same(proto: "VotingWeight"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.votingWeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if self.votingWeight != 0 {
      try visitor.visitSingularInt64Field(value: self.votingWeight, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_Vote, rhs: Payload_Vote) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.votingWeight != rhs.votingWeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_Proposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Proposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "Description"),
    3: .same(proto: "BatchTx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._batchTx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if let v = self._batchTx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_Proposal, rhs: Payload_Proposal) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._batchTx != rhs._batchTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_Ballot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Ballot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Proposal"),
    2: .same(proto: "FinalizingTx"),
    4: .same(proto: "proposalState"),
    5: .same(proto: "Votes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._proposal) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.finalizingTx) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.proposalState) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.votes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._proposal {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.finalizingTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.finalizingTx, fieldNumber: 2)
    }
    if self.proposalState != .proposed {
      try visitor.visitSingularEnumField(value: self.proposalState, fieldNumber: 4)
    }
    if !self.votes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.votes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_Ballot, rhs: Payload_Ballot) -> Bool {
    if lhs._proposal != rhs._proposal {return false}
    if lhs.finalizingTx != rhs.finalizingTx {return false}
    if lhs.proposalState != rhs.proposalState {return false}
    if lhs.votes != rhs.votes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_Ballot.ProposalState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROPOSED"),
    1: .same(proto: "EXECUTED"),
    2: .same(proto: "FAILED"),
  ]
}
