// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: provenance/metadata/v1/events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// EventTxCompleted is an event message indicating that a TX has completed.
struct Provenance_Metadata_V1_EventTxCompleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// module is the module the TX belongs to.
  var module: String = String()

  /// endpoint is the rpc endpoint that was just completed.
  var endpoint: String = String()

  /// signers are the bech32 address strings of the signers of this TX.
  var signers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventScopeCreated is an event message indicating a scope has been created.
struct Provenance_Metadata_V1_EventScopeCreated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope_addr is the bech32 address string of the scope id that was created.
  var scopeAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventScopeUpdated is an event message indicating a scope has been updated.
struct Provenance_Metadata_V1_EventScopeUpdated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope_addr is the bech32 address string of the scope id that was updated.
  var scopeAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventScopeDeleted is an event message indicating a scope has been deleted.
struct Provenance_Metadata_V1_EventScopeDeleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope_addr is the bech32 address string of the scope id that was deleted.
  var scopeAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventSessionCreated is an event message indicating a session has been created.
struct Provenance_Metadata_V1_EventSessionCreated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// session_addr is the bech32 address string of the session id that was created.
  var sessionAddr: String = String()

  /// scope_addr is the bech32 address string of the scope id this session belongs to.
  var scopeAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventSessionUpdated is an event message indicating a session has been updated.
struct Provenance_Metadata_V1_EventSessionUpdated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// session_addr is the bech32 address string of the session id that was updated.
  var sessionAddr: String = String()

  /// scope_addr is the bech32 address string of the scope id this session belongs to.
  var scopeAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventSessionDeleted is an event message indicating a session has been deleted.
struct Provenance_Metadata_V1_EventSessionDeleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// session_addr is the bech32 address string of the session id that was deleted.
  var sessionAddr: String = String()

  /// scope_addr is the bech32 address string of the scope id this session belongs to.
  var scopeAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventRecordCreated is an event message indicating a record has been created.
struct Provenance_Metadata_V1_EventRecordCreated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// record_addr is the bech32 address string of the record id that was created.
  var recordAddr: String = String()

  /// session_addr is the bech32 address string of the session id this record belongs to.
  var sessionAddr: String = String()

  /// scope_addr is the bech32 address string of the scope id this record belongs to.
  var scopeAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventRecordUpdated is an event message indicating a record has been updated.
struct Provenance_Metadata_V1_EventRecordUpdated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// record_addr is the bech32 address string of the record id that was updated.
  var recordAddr: String = String()

  /// session_addr is the bech32 address string of the session id this record belongs to.
  var sessionAddr: String = String()

  /// scope_addr is the bech32 address string of the scope id this record belongs to.
  var scopeAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventRecordDeleted is an event message indicating a record has been deleted.
struct Provenance_Metadata_V1_EventRecordDeleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// record is the bech32 address string of the record id that was deleted.
  var recordAddr: String = String()

  /// scope_addr is the bech32 address string of the scope id this record belonged to.
  var scopeAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventScopeSpecificationCreated is an event message indicating a scope specification has been created.
struct Provenance_Metadata_V1_EventScopeSpecificationCreated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope_specification_addr is the bech32 address string of the specification id of the scope specification that was
  /// created.
  var scopeSpecificationAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventScopeSpecificationUpdated is an event message indicating a scope specification has been updated.
struct Provenance_Metadata_V1_EventScopeSpecificationUpdated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope_specification_addr is the bech32 address string of the specification id of the scope specification that was
  /// updated.
  var scopeSpecificationAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventScopeSpecificationDeleted is an event message indicating a scope specification has been deleted.
struct Provenance_Metadata_V1_EventScopeSpecificationDeleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// scope_specification_addr is the bech32 address string of the specification id of the scope specification that was
  /// deleted.
  var scopeSpecificationAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventContractSpecificationCreated is an event message indicating a contract specification has been created.
struct Provenance_Metadata_V1_EventContractSpecificationCreated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// contract_specification_addr is the bech32 address string of the specification id of the contract specification that
  /// was created.
  var contractSpecificationAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventContractSpecificationUpdated is an event message indicating a contract specification has been updated.
struct Provenance_Metadata_V1_EventContractSpecificationUpdated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// contract_specification_addr is the bech32 address string of the specification id of the contract specification that
  /// was updated.
  var contractSpecificationAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventContractSpecificationDeleted is an event message indicating a contract specification has been deleted.
struct Provenance_Metadata_V1_EventContractSpecificationDeleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// contract_specification_addr is the bech32 address string of the specification id of the contract specification that
  /// was deleted.
  var contractSpecificationAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventRecordSpecificationCreated is an event message indicating a record specification has been created.
struct Provenance_Metadata_V1_EventRecordSpecificationCreated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// record_specification_addr is the bech32 address string of the specification id of the record specification that was
  /// created.
  var recordSpecificationAddr: String = String()

  /// contract_specification_addr is the bech32 address string of the contract specification id this record specification
  /// belongs to.
  var contractSpecificationAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventRecordSpecificationUpdated is an event message indicating a record specification has been updated.
struct Provenance_Metadata_V1_EventRecordSpecificationUpdated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// record_specification_addr is the bech32 address string of the specification id of the record specification that was
  /// updated.
  var recordSpecificationAddr: String = String()

  /// contract_specification_addr is the bech32 address string of the contract specification id this record specification
  /// belongs to.
  var contractSpecificationAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventRecordSpecificationDeleted is an event message indicating a record specification has been deleted.
struct Provenance_Metadata_V1_EventRecordSpecificationDeleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// record_specification_addr is the bech32 address string of the specification id of the record specification that was
  /// deleted.
  var recordSpecificationAddr: String = String()

  /// contract_specification_addr is the bech32 address string of the contract specification id this record specification
  /// belongs to.
  var contractSpecificationAddr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventOSLocatorCreated is an event message indicating an object store locator has been created.
struct Provenance_Metadata_V1_EventOSLocatorCreated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// owner is the owner in the object store locator that was created.
  var owner: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventOSLocatorUpdated is an event message indicating an object store locator has been updated.
struct Provenance_Metadata_V1_EventOSLocatorUpdated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// owner is the owner in the object store locator that was updated.
  var owner: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventOSLocatorDeleted is an event message indicating an object store locator has been deleted.
struct Provenance_Metadata_V1_EventOSLocatorDeleted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// owner is the owner in the object store locator that was deleted.
  var owner: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "provenance.metadata.v1"

extension Provenance_Metadata_V1_EventTxCompleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventTxCompleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "module"),
    2: .same(proto: "endpoint"),
    3: .same(proto: "signers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.module) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.signers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.module.isEmpty {
      try visitor.visitSingularStringField(value: self.module, fieldNumber: 1)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 2)
    }
    if !self.signers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.signers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventTxCompleted, rhs: Provenance_Metadata_V1_EventTxCompleted) -> Bool {
    if lhs.module != rhs.module {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.signers != rhs.signers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventScopeCreated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventScopeCreated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scopeAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeAddr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventScopeCreated, rhs: Provenance_Metadata_V1_EventScopeCreated) -> Bool {
    if lhs.scopeAddr != rhs.scopeAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventScopeUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventScopeUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scopeAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeAddr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventScopeUpdated, rhs: Provenance_Metadata_V1_EventScopeUpdated) -> Bool {
    if lhs.scopeAddr != rhs.scopeAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventScopeDeleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventScopeDeleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scopeAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeAddr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventScopeDeleted, rhs: Provenance_Metadata_V1_EventScopeDeleted) -> Bool {
    if lhs.scopeAddr != rhs.scopeAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventSessionCreated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSessionCreated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_addr"),
    2: .standard(proto: "scope_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionAddr) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scopeAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionAddr, fieldNumber: 1)
    }
    if !self.scopeAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeAddr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventSessionCreated, rhs: Provenance_Metadata_V1_EventSessionCreated) -> Bool {
    if lhs.sessionAddr != rhs.sessionAddr {return false}
    if lhs.scopeAddr != rhs.scopeAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventSessionUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSessionUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_addr"),
    2: .standard(proto: "scope_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionAddr) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scopeAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionAddr, fieldNumber: 1)
    }
    if !self.scopeAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeAddr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventSessionUpdated, rhs: Provenance_Metadata_V1_EventSessionUpdated) -> Bool {
    if lhs.sessionAddr != rhs.sessionAddr {return false}
    if lhs.scopeAddr != rhs.scopeAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventSessionDeleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSessionDeleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_addr"),
    2: .standard(proto: "scope_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionAddr) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scopeAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionAddr, fieldNumber: 1)
    }
    if !self.scopeAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeAddr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventSessionDeleted, rhs: Provenance_Metadata_V1_EventSessionDeleted) -> Bool {
    if lhs.sessionAddr != rhs.sessionAddr {return false}
    if lhs.scopeAddr != rhs.scopeAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventRecordCreated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventRecordCreated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_addr"),
    2: .standard(proto: "session_addr"),
    3: .standard(proto: "scope_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recordAddr) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionAddr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.scopeAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recordAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.recordAddr, fieldNumber: 1)
    }
    if !self.sessionAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionAddr, fieldNumber: 2)
    }
    if !self.scopeAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeAddr, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventRecordCreated, rhs: Provenance_Metadata_V1_EventRecordCreated) -> Bool {
    if lhs.recordAddr != rhs.recordAddr {return false}
    if lhs.sessionAddr != rhs.sessionAddr {return false}
    if lhs.scopeAddr != rhs.scopeAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventRecordUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventRecordUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_addr"),
    2: .standard(proto: "session_addr"),
    3: .standard(proto: "scope_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recordAddr) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionAddr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.scopeAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recordAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.recordAddr, fieldNumber: 1)
    }
    if !self.sessionAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionAddr, fieldNumber: 2)
    }
    if !self.scopeAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeAddr, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventRecordUpdated, rhs: Provenance_Metadata_V1_EventRecordUpdated) -> Bool {
    if lhs.recordAddr != rhs.recordAddr {return false}
    if lhs.sessionAddr != rhs.sessionAddr {return false}
    if lhs.scopeAddr != rhs.scopeAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventRecordDeleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventRecordDeleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_addr"),
    3: .standard(proto: "scope_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recordAddr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.scopeAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recordAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.recordAddr, fieldNumber: 1)
    }
    if !self.scopeAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeAddr, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventRecordDeleted, rhs: Provenance_Metadata_V1_EventRecordDeleted) -> Bool {
    if lhs.recordAddr != rhs.recordAddr {return false}
    if lhs.scopeAddr != rhs.scopeAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventScopeSpecificationCreated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventScopeSpecificationCreated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_specification_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scopeSpecificationAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeSpecificationAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeSpecificationAddr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventScopeSpecificationCreated, rhs: Provenance_Metadata_V1_EventScopeSpecificationCreated) -> Bool {
    if lhs.scopeSpecificationAddr != rhs.scopeSpecificationAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventScopeSpecificationUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventScopeSpecificationUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_specification_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scopeSpecificationAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeSpecificationAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeSpecificationAddr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventScopeSpecificationUpdated, rhs: Provenance_Metadata_V1_EventScopeSpecificationUpdated) -> Bool {
    if lhs.scopeSpecificationAddr != rhs.scopeSpecificationAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventScopeSpecificationDeleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventScopeSpecificationDeleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_specification_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scopeSpecificationAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeSpecificationAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.scopeSpecificationAddr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventScopeSpecificationDeleted, rhs: Provenance_Metadata_V1_EventScopeSpecificationDeleted) -> Bool {
    if lhs.scopeSpecificationAddr != rhs.scopeSpecificationAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventContractSpecificationCreated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventContractSpecificationCreated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_specification_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contractSpecificationAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contractSpecificationAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.contractSpecificationAddr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventContractSpecificationCreated, rhs: Provenance_Metadata_V1_EventContractSpecificationCreated) -> Bool {
    if lhs.contractSpecificationAddr != rhs.contractSpecificationAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventContractSpecificationUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventContractSpecificationUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_specification_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contractSpecificationAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contractSpecificationAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.contractSpecificationAddr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventContractSpecificationUpdated, rhs: Provenance_Metadata_V1_EventContractSpecificationUpdated) -> Bool {
    if lhs.contractSpecificationAddr != rhs.contractSpecificationAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventContractSpecificationDeleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventContractSpecificationDeleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_specification_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contractSpecificationAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contractSpecificationAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.contractSpecificationAddr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventContractSpecificationDeleted, rhs: Provenance_Metadata_V1_EventContractSpecificationDeleted) -> Bool {
    if lhs.contractSpecificationAddr != rhs.contractSpecificationAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventRecordSpecificationCreated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventRecordSpecificationCreated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_specification_addr"),
    2: .standard(proto: "contract_specification_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recordSpecificationAddr) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contractSpecificationAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recordSpecificationAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.recordSpecificationAddr, fieldNumber: 1)
    }
    if !self.contractSpecificationAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.contractSpecificationAddr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventRecordSpecificationCreated, rhs: Provenance_Metadata_V1_EventRecordSpecificationCreated) -> Bool {
    if lhs.recordSpecificationAddr != rhs.recordSpecificationAddr {return false}
    if lhs.contractSpecificationAddr != rhs.contractSpecificationAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventRecordSpecificationUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventRecordSpecificationUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_specification_addr"),
    2: .standard(proto: "contract_specification_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recordSpecificationAddr) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contractSpecificationAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recordSpecificationAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.recordSpecificationAddr, fieldNumber: 1)
    }
    if !self.contractSpecificationAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.contractSpecificationAddr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventRecordSpecificationUpdated, rhs: Provenance_Metadata_V1_EventRecordSpecificationUpdated) -> Bool {
    if lhs.recordSpecificationAddr != rhs.recordSpecificationAddr {return false}
    if lhs.contractSpecificationAddr != rhs.contractSpecificationAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventRecordSpecificationDeleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventRecordSpecificationDeleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "record_specification_addr"),
    2: .standard(proto: "contract_specification_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recordSpecificationAddr) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contractSpecificationAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recordSpecificationAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.recordSpecificationAddr, fieldNumber: 1)
    }
    if !self.contractSpecificationAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.contractSpecificationAddr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventRecordSpecificationDeleted, rhs: Provenance_Metadata_V1_EventRecordSpecificationDeleted) -> Bool {
    if lhs.recordSpecificationAddr != rhs.recordSpecificationAddr {return false}
    if lhs.contractSpecificationAddr != rhs.contractSpecificationAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventOSLocatorCreated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventOSLocatorCreated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventOSLocatorCreated, rhs: Provenance_Metadata_V1_EventOSLocatorCreated) -> Bool {
    if lhs.owner != rhs.owner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventOSLocatorUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventOSLocatorUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventOSLocatorUpdated, rhs: Provenance_Metadata_V1_EventOSLocatorUpdated) -> Bool {
    if lhs.owner != rhs.owner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_EventOSLocatorDeleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventOSLocatorDeleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_EventOSLocatorDeleted, rhs: Provenance_Metadata_V1_EventOSLocatorDeleted) -> Bool {
    if lhs.owner != rhs.owner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
