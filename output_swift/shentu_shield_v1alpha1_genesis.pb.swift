// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: shentu/shield/v1alpha1/genesis.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// GenesisState defines the shield genesis state.
struct Shentu_Shield_V1alpha1_GenesisState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var shieldAdmin: String {
    get {return _storage._shieldAdmin}
    set {_uniqueStorage()._shieldAdmin = newValue}
  }

  var nextPoolID: UInt64 {
    get {return _storage._nextPoolID}
    set {_uniqueStorage()._nextPoolID = newValue}
  }

  var nextPurchaseID: UInt64 {
    get {return _storage._nextPurchaseID}
    set {_uniqueStorage()._nextPurchaseID = newValue}
  }

  var poolParams: Shentu_Shield_V1alpha1_PoolParams {
    get {return _storage._poolParams ?? Shentu_Shield_V1alpha1_PoolParams()}
    set {_uniqueStorage()._poolParams = newValue}
  }
  /// Returns true if `poolParams` has been explicitly set.
  var hasPoolParams: Bool {return _storage._poolParams != nil}
  /// Clears the value of `poolParams`. Subsequent reads from it will return its default value.
  mutating func clearPoolParams() {_uniqueStorage()._poolParams = nil}

  var claimProposalParams: Shentu_Shield_V1alpha1_ClaimProposalParams {
    get {return _storage._claimProposalParams ?? Shentu_Shield_V1alpha1_ClaimProposalParams()}
    set {_uniqueStorage()._claimProposalParams = newValue}
  }
  /// Returns true if `claimProposalParams` has been explicitly set.
  var hasClaimProposalParams: Bool {return _storage._claimProposalParams != nil}
  /// Clears the value of `claimProposalParams`. Subsequent reads from it will return its default value.
  mutating func clearClaimProposalParams() {_uniqueStorage()._claimProposalParams = nil}

  var totalCollateral: String {
    get {return _storage._totalCollateral}
    set {_uniqueStorage()._totalCollateral = newValue}
  }

  var totalWithdrawing: String {
    get {return _storage._totalWithdrawing}
    set {_uniqueStorage()._totalWithdrawing = newValue}
  }

  var totalShield: String {
    get {return _storage._totalShield}
    set {_uniqueStorage()._totalShield = newValue}
  }

  var totalClaimed: String {
    get {return _storage._totalClaimed}
    set {_uniqueStorage()._totalClaimed = newValue}
  }

  var serviceFees: Shentu_Shield_V1alpha1_MixedDecCoins {
    get {return _storage._serviceFees ?? Shentu_Shield_V1alpha1_MixedDecCoins()}
    set {_uniqueStorage()._serviceFees = newValue}
  }
  /// Returns true if `serviceFees` has been explicitly set.
  var hasServiceFees: Bool {return _storage._serviceFees != nil}
  /// Clears the value of `serviceFees`. Subsequent reads from it will return its default value.
  mutating func clearServiceFees() {_uniqueStorage()._serviceFees = nil}

  var remainingServiceFees: Shentu_Shield_V1alpha1_MixedDecCoins {
    get {return _storage._remainingServiceFees ?? Shentu_Shield_V1alpha1_MixedDecCoins()}
    set {_uniqueStorage()._remainingServiceFees = newValue}
  }
  /// Returns true if `remainingServiceFees` has been explicitly set.
  var hasRemainingServiceFees: Bool {return _storage._remainingServiceFees != nil}
  /// Clears the value of `remainingServiceFees`. Subsequent reads from it will return its default value.
  mutating func clearRemainingServiceFees() {_uniqueStorage()._remainingServiceFees = nil}

  var pools: [Shentu_Shield_V1alpha1_Pool] {
    get {return _storage._pools}
    set {_uniqueStorage()._pools = newValue}
  }

  var providers: [Shentu_Shield_V1alpha1_Provider] {
    get {return _storage._providers}
    set {_uniqueStorage()._providers = newValue}
  }

  var purchaseLists: [Shentu_Shield_V1alpha1_PurchaseList] {
    get {return _storage._purchaseLists}
    set {_uniqueStorage()._purchaseLists = newValue}
  }

  var withdraws: [Shentu_Shield_V1alpha1_Withdraw] {
    get {return _storage._withdraws}
    set {_uniqueStorage()._withdraws = newValue}
  }

  var lastUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastUpdateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastUpdateTime = newValue}
  }
  /// Returns true if `lastUpdateTime` has been explicitly set.
  var hasLastUpdateTime: Bool {return _storage._lastUpdateTime != nil}
  /// Clears the value of `lastUpdateTime`. Subsequent reads from it will return its default value.
  mutating func clearLastUpdateTime() {_uniqueStorage()._lastUpdateTime = nil}

  var shieldStakingRate: String {
    get {return _storage._shieldStakingRate}
    set {_uniqueStorage()._shieldStakingRate = newValue}
  }

  var globalStakingPool: String {
    get {return _storage._globalStakingPool}
    set {_uniqueStorage()._globalStakingPool = newValue}
  }

  var stakeForShields: [Shentu_Shield_V1alpha1_ShieldStaking] {
    get {return _storage._stakeForShields}
    set {_uniqueStorage()._stakeForShields = newValue}
  }

  var originalStakings: [Shentu_Shield_V1alpha1_OriginalStaking] {
    get {return _storage._originalStakings}
    set {_uniqueStorage()._originalStakings = newValue}
  }

  var proposalIDReimbursementPairs: [Shentu_Shield_V1alpha1_ProposalIDReimbursementPair] {
    get {return _storage._proposalIDReimbursementPairs}
    set {_uniqueStorage()._proposalIDReimbursementPairs = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Shentu_Shield_V1alpha1_OriginalStaking {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var purchaseID: UInt64 = 0

  var amount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Shentu_Shield_V1alpha1_ProposalIDReimbursementPair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var proposalID: UInt64 = 0

  var reimbursement: Shentu_Shield_V1alpha1_Reimbursement {
    get {return _reimbursement ?? Shentu_Shield_V1alpha1_Reimbursement()}
    set {_reimbursement = newValue}
  }
  /// Returns true if `reimbursement` has been explicitly set.
  var hasReimbursement: Bool {return self._reimbursement != nil}
  /// Clears the value of `reimbursement`. Subsequent reads from it will return its default value.
  mutating func clearReimbursement() {self._reimbursement = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _reimbursement: Shentu_Shield_V1alpha1_Reimbursement? = nil
}

struct Shentu_Shield_V1alpha1_Reimbursement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: [Cosmos_Base_V1beta1_Coin] = []

  var beneficiary: String = String()

  var payoutTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _payoutTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_payoutTime = newValue}
  }
  /// Returns true if `payoutTime` has been explicitly set.
  var hasPayoutTime: Bool {return self._payoutTime != nil}
  /// Clears the value of `payoutTime`. Subsequent reads from it will return its default value.
  mutating func clearPayoutTime() {self._payoutTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payoutTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// PoolParams defines the parameters for the shield pool.
struct Shentu_Shield_V1alpha1_PoolParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var protectionPeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _protectionPeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_protectionPeriod = newValue}
  }
  /// Returns true if `protectionPeriod` has been explicitly set.
  var hasProtectionPeriod: Bool {return self._protectionPeriod != nil}
  /// Clears the value of `protectionPeriod`. Subsequent reads from it will return its default value.
  mutating func clearProtectionPeriod() {self._protectionPeriod = nil}

  var shieldFeesRate: String = String()

  var withdrawPeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _withdrawPeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_withdrawPeriod = newValue}
  }
  /// Returns true if `withdrawPeriod` has been explicitly set.
  var hasWithdrawPeriod: Bool {return self._withdrawPeriod != nil}
  /// Clears the value of `withdrawPeriod`. Subsequent reads from it will return its default value.
  mutating func clearWithdrawPeriod() {self._withdrawPeriod = nil}

  var poolShieldLimit: String = String()

  var minShieldPurchase: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _protectionPeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _withdrawPeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// ClaimProposalParams defines the parameters for the shield claim proposals.
struct Shentu_Shield_V1alpha1_ClaimProposalParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var claimPeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _claimPeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_claimPeriod = newValue}
  }
  /// Returns true if `claimPeriod` has been explicitly set.
  var hasClaimPeriod: Bool {return self._claimPeriod != nil}
  /// Clears the value of `claimPeriod`. Subsequent reads from it will return its default value.
  mutating func clearClaimPeriod() {self._claimPeriod = nil}

  var payoutPeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _payoutPeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_payoutPeriod = newValue}
  }
  /// Returns true if `payoutPeriod` has been explicitly set.
  var hasPayoutPeriod: Bool {return self._payoutPeriod != nil}
  /// Clears the value of `payoutPeriod`. Subsequent reads from it will return its default value.
  mutating func clearPayoutPeriod() {self._payoutPeriod = nil}

  var minDeposit: [Cosmos_Base_V1beta1_Coin] = []

  var depositRate: String = String()

  var feesRate: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _claimPeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _payoutPeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "shentu.shield.v1alpha1"

extension Shentu_Shield_V1alpha1_GenesisState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenesisState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "shield_admin"),
    2: .standard(proto: "next_pool_id"),
    3: .standard(proto: "next_purchase_id"),
    4: .standard(proto: "pool_params"),
    5: .standard(proto: "claim_proposal_params"),
    6: .standard(proto: "total_collateral"),
    7: .standard(proto: "total_withdrawing"),
    8: .standard(proto: "total_shield"),
    9: .standard(proto: "total_claimed"),
    10: .standard(proto: "service_fees"),
    11: .standard(proto: "remaining_service_fees"),
    12: .same(proto: "pools"),
    13: .same(proto: "providers"),
    14: .standard(proto: "purchase_lists"),
    15: .same(proto: "withdraws"),
    16: .standard(proto: "last_update_time"),
    17: .standard(proto: "shield_staking_rate"),
    18: .standard(proto: "global_staking_pool"),
    19: .standard(proto: "stake_for_shields"),
    20: .standard(proto: "original_stakings"),
    21: .standard(proto: "proposalID_reimbursement_pairs"),
  ]

  fileprivate class _StorageClass {
    var _shieldAdmin: String = String()
    var _nextPoolID: UInt64 = 0
    var _nextPurchaseID: UInt64 = 0
    var _poolParams: Shentu_Shield_V1alpha1_PoolParams? = nil
    var _claimProposalParams: Shentu_Shield_V1alpha1_ClaimProposalParams? = nil
    var _totalCollateral: String = String()
    var _totalWithdrawing: String = String()
    var _totalShield: String = String()
    var _totalClaimed: String = String()
    var _serviceFees: Shentu_Shield_V1alpha1_MixedDecCoins? = nil
    var _remainingServiceFees: Shentu_Shield_V1alpha1_MixedDecCoins? = nil
    var _pools: [Shentu_Shield_V1alpha1_Pool] = []
    var _providers: [Shentu_Shield_V1alpha1_Provider] = []
    var _purchaseLists: [Shentu_Shield_V1alpha1_PurchaseList] = []
    var _withdraws: [Shentu_Shield_V1alpha1_Withdraw] = []
    var _lastUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _shieldStakingRate: String = String()
    var _globalStakingPool: String = String()
    var _stakeForShields: [Shentu_Shield_V1alpha1_ShieldStaking] = []
    var _originalStakings: [Shentu_Shield_V1alpha1_OriginalStaking] = []
    var _proposalIDReimbursementPairs: [Shentu_Shield_V1alpha1_ProposalIDReimbursementPair] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _shieldAdmin = source._shieldAdmin
      _nextPoolID = source._nextPoolID
      _nextPurchaseID = source._nextPurchaseID
      _poolParams = source._poolParams
      _claimProposalParams = source._claimProposalParams
      _totalCollateral = source._totalCollateral
      _totalWithdrawing = source._totalWithdrawing
      _totalShield = source._totalShield
      _totalClaimed = source._totalClaimed
      _serviceFees = source._serviceFees
      _remainingServiceFees = source._remainingServiceFees
      _pools = source._pools
      _providers = source._providers
      _purchaseLists = source._purchaseLists
      _withdraws = source._withdraws
      _lastUpdateTime = source._lastUpdateTime
      _shieldStakingRate = source._shieldStakingRate
      _globalStakingPool = source._globalStakingPool
      _stakeForShields = source._stakeForShields
      _originalStakings = source._originalStakings
      _proposalIDReimbursementPairs = source._proposalIDReimbursementPairs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._shieldAdmin) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._nextPoolID) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._nextPurchaseID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._poolParams) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._claimProposalParams) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._totalCollateral) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._totalWithdrawing) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._totalShield) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._totalClaimed) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._serviceFees) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._remainingServiceFees) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._pools) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._providers) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._purchaseLists) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._withdraws) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._lastUpdateTime) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._shieldStakingRate) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._globalStakingPool) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._stakeForShields) }()
        case 20: try { try decoder.decodeRepeatedMessageField(value: &_storage._originalStakings) }()
        case 21: try { try decoder.decodeRepeatedMessageField(value: &_storage._proposalIDReimbursementPairs) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._shieldAdmin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._shieldAdmin, fieldNumber: 1)
      }
      if _storage._nextPoolID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._nextPoolID, fieldNumber: 2)
      }
      if _storage._nextPurchaseID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._nextPurchaseID, fieldNumber: 3)
      }
      if let v = _storage._poolParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._claimProposalParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._totalCollateral.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalCollateral, fieldNumber: 6)
      }
      if !_storage._totalWithdrawing.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalWithdrawing, fieldNumber: 7)
      }
      if !_storage._totalShield.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalShield, fieldNumber: 8)
      }
      if !_storage._totalClaimed.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalClaimed, fieldNumber: 9)
      }
      if let v = _storage._serviceFees {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._remainingServiceFees {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if !_storage._pools.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pools, fieldNumber: 12)
      }
      if !_storage._providers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._providers, fieldNumber: 13)
      }
      if !_storage._purchaseLists.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._purchaseLists, fieldNumber: 14)
      }
      if !_storage._withdraws.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._withdraws, fieldNumber: 15)
      }
      if let v = _storage._lastUpdateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if !_storage._shieldStakingRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._shieldStakingRate, fieldNumber: 17)
      }
      if !_storage._globalStakingPool.isEmpty {
        try visitor.visitSingularStringField(value: _storage._globalStakingPool, fieldNumber: 18)
      }
      if !_storage._stakeForShields.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stakeForShields, fieldNumber: 19)
      }
      if !_storage._originalStakings.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._originalStakings, fieldNumber: 20)
      }
      if !_storage._proposalIDReimbursementPairs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._proposalIDReimbursementPairs, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Shentu_Shield_V1alpha1_GenesisState, rhs: Shentu_Shield_V1alpha1_GenesisState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._shieldAdmin != rhs_storage._shieldAdmin {return false}
        if _storage._nextPoolID != rhs_storage._nextPoolID {return false}
        if _storage._nextPurchaseID != rhs_storage._nextPurchaseID {return false}
        if _storage._poolParams != rhs_storage._poolParams {return false}
        if _storage._claimProposalParams != rhs_storage._claimProposalParams {return false}
        if _storage._totalCollateral != rhs_storage._totalCollateral {return false}
        if _storage._totalWithdrawing != rhs_storage._totalWithdrawing {return false}
        if _storage._totalShield != rhs_storage._totalShield {return false}
        if _storage._totalClaimed != rhs_storage._totalClaimed {return false}
        if _storage._serviceFees != rhs_storage._serviceFees {return false}
        if _storage._remainingServiceFees != rhs_storage._remainingServiceFees {return false}
        if _storage._pools != rhs_storage._pools {return false}
        if _storage._providers != rhs_storage._providers {return false}
        if _storage._purchaseLists != rhs_storage._purchaseLists {return false}
        if _storage._withdraws != rhs_storage._withdraws {return false}
        if _storage._lastUpdateTime != rhs_storage._lastUpdateTime {return false}
        if _storage._shieldStakingRate != rhs_storage._shieldStakingRate {return false}
        if _storage._globalStakingPool != rhs_storage._globalStakingPool {return false}
        if _storage._stakeForShields != rhs_storage._stakeForShields {return false}
        if _storage._originalStakings != rhs_storage._originalStakings {return false}
        if _storage._proposalIDReimbursementPairs != rhs_storage._proposalIDReimbursementPairs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Shentu_Shield_V1alpha1_OriginalStaking: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OriginalStaking"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "purchase_id"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.purchaseID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.purchaseID != 0 {
      try visitor.visitSingularUInt64Field(value: self.purchaseID, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Shentu_Shield_V1alpha1_OriginalStaking, rhs: Shentu_Shield_V1alpha1_OriginalStaking) -> Bool {
    if lhs.purchaseID != rhs.purchaseID {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Shentu_Shield_V1alpha1_ProposalIDReimbursementPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProposalIDReimbursementPair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "proposal_id"),
    2: .same(proto: "reimbursement"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.proposalID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._reimbursement) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.proposalID != 0 {
      try visitor.visitSingularUInt64Field(value: self.proposalID, fieldNumber: 1)
    }
    if let v = self._reimbursement {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Shentu_Shield_V1alpha1_ProposalIDReimbursementPair, rhs: Shentu_Shield_V1alpha1_ProposalIDReimbursementPair) -> Bool {
    if lhs.proposalID != rhs.proposalID {return false}
    if lhs._reimbursement != rhs._reimbursement {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Shentu_Shield_V1alpha1_Reimbursement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Reimbursement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "beneficiary"),
    3: .standard(proto: "payout_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.amount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.beneficiary) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._payoutTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amount, fieldNumber: 1)
    }
    if !self.beneficiary.isEmpty {
      try visitor.visitSingularStringField(value: self.beneficiary, fieldNumber: 2)
    }
    if let v = self._payoutTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Shentu_Shield_V1alpha1_Reimbursement, rhs: Shentu_Shield_V1alpha1_Reimbursement) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.beneficiary != rhs.beneficiary {return false}
    if lhs._payoutTime != rhs._payoutTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Shentu_Shield_V1alpha1_PoolParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "protection_period"),
    2: .standard(proto: "shield_fees_rate"),
    3: .standard(proto: "withdraw_period"),
    4: .standard(proto: "pool_shield_limit"),
    5: .standard(proto: "min_shield_purchase"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._protectionPeriod) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.shieldFeesRate) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._withdrawPeriod) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.poolShieldLimit) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.minShieldPurchase) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._protectionPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.shieldFeesRate.isEmpty {
      try visitor.visitSingularStringField(value: self.shieldFeesRate, fieldNumber: 2)
    }
    if let v = self._withdrawPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.poolShieldLimit.isEmpty {
      try visitor.visitSingularStringField(value: self.poolShieldLimit, fieldNumber: 4)
    }
    if !self.minShieldPurchase.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.minShieldPurchase, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Shentu_Shield_V1alpha1_PoolParams, rhs: Shentu_Shield_V1alpha1_PoolParams) -> Bool {
    if lhs._protectionPeriod != rhs._protectionPeriod {return false}
    if lhs.shieldFeesRate != rhs.shieldFeesRate {return false}
    if lhs._withdrawPeriod != rhs._withdrawPeriod {return false}
    if lhs.poolShieldLimit != rhs.poolShieldLimit {return false}
    if lhs.minShieldPurchase != rhs.minShieldPurchase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Shentu_Shield_V1alpha1_ClaimProposalParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClaimProposalParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "claim_period"),
    2: .standard(proto: "payout_period"),
    3: .standard(proto: "min_deposit"),
    4: .standard(proto: "deposit_rate"),
    5: .standard(proto: "fees_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._claimPeriod) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._payoutPeriod) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.minDeposit) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.depositRate) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.feesRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._claimPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._payoutPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.minDeposit.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.minDeposit, fieldNumber: 3)
    }
    if !self.depositRate.isEmpty {
      try visitor.visitSingularStringField(value: self.depositRate, fieldNumber: 4)
    }
    if !self.feesRate.isEmpty {
      try visitor.visitSingularStringField(value: self.feesRate, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Shentu_Shield_V1alpha1_ClaimProposalParams, rhs: Shentu_Shield_V1alpha1_ClaimProposalParams) -> Bool {
    if lhs._claimPeriod != rhs._claimPeriod {return false}
    if lhs._payoutPeriod != rhs._payoutPeriod {return false}
    if lhs.minDeposit != rhs.minDeposit {return false}
    if lhs.depositRate != rhs.depositRate {return false}
    if lhs.feesRate != rhs.feesRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
