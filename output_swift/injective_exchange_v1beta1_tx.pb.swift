// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: injective/exchange/v1beta1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Injective_Exchange_V1beta1_ExchangeType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case exchangeUnspecified // = 0
  case spot // = 1
  case derivatives // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .exchangeUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .exchangeUnspecified
    case 1: self = .spot
    case 2: self = .derivatives
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .exchangeUnspecified: return 0
    case .spot: return 1
    case .derivatives: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Injective_Exchange_V1beta1_ExchangeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Injective_Exchange_V1beta1_ExchangeType] = [
    .exchangeUnspecified,
    .spot,
    .derivatives,
  ]
}

#endif  // swift(>=4.2)

/// MsgDeposit defines a SDK message for transferring coins from the sender's bank balance into the subaccount's exchange deposits
struct Injective_Exchange_V1beta1_MsgDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  /// (Optional) bytes32 subaccount ID to deposit funds into. If empty, the coin will be deposited to the sender's default
  /// subaccount address.
  var subaccountID: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgDepositResponse defines the Msg/Deposit response type.
struct Injective_Exchange_V1beta1_MsgDepositResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgWithdraw defines a SDK message for withdrawing coins from a subaccount's deposits to the user's bank balance
struct Injective_Exchange_V1beta1_MsgWithdraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  /// bytes32 subaccount ID to withdraw funds from
  var subaccountID: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgWithdraw defines the Msg/Withdraw response type.
struct Injective_Exchange_V1beta1_MsgWithdrawResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCreateSpotLimitOrder defines a SDK message for creating a new spot limit order.
struct Injective_Exchange_V1beta1_MsgCreateSpotLimitOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var order: Injective_Exchange_V1beta1_SpotOrder {
    get {return _order ?? Injective_Exchange_V1beta1_SpotOrder()}
    set {_order = newValue}
  }
  /// Returns true if `order` has been explicitly set.
  var hasOrder: Bool {return self._order != nil}
  /// Clears the value of `order`. Subsequent reads from it will return its default value.
  mutating func clearOrder() {self._order = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _order: Injective_Exchange_V1beta1_SpotOrder? = nil
}

/// MsgCreateSpotLimitOrderResponse defines the Msg/CreateSpotOrder response type.
struct Injective_Exchange_V1beta1_MsgCreateSpotLimitOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBatchCreateSpotLimitOrders defines a SDK message for creating a new batch of spot limit orders.
struct Injective_Exchange_V1beta1_MsgBatchCreateSpotLimitOrders {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var orders: [Injective_Exchange_V1beta1_SpotOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBatchCreateSpotLimitOrdersResponse defines the Msg/BatchCreateSpotLimitOrders response type.
struct Injective_Exchange_V1beta1_MsgBatchCreateSpotLimitOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderHashes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgInstantSpotMarketLaunch defines a SDK message for creating a new spot market by paying listing fee without governance
struct Injective_Exchange_V1beta1_MsgInstantSpotMarketLaunch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  /// Ticker for the spot market.
  var ticker: String = String()

  /// type of coin to use as the base currency
  var baseDenom: String = String()

  /// type of coin to use as the quote currency
  var quoteDenom: String = String()

  /// min_price_tick_size defines the minimum tick size of the order's price
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the order's quantity
  var minQuantityTickSize: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgInstantSpotMarketLaunchResponse defines the Msg/InstantSpotMarketLaunch response type.
struct Injective_Exchange_V1beta1_MsgInstantSpotMarketLaunchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgInstantPerpetualMarketLaunch defines a SDK message for creating a new perpetual futures market by paying listing fee without governance
struct Injective_Exchange_V1beta1_MsgInstantPerpetualMarketLaunch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  /// Ticker for the derivative market.
  var ticker: String = String()

  /// type of coin to use as the base currency
  var quoteDenom: String = String()

  /// Oracle base currency
  var oracleBase: String = String()

  /// Oracle quote currency
  var oracleQuote: String = String()

  /// Scale factor for oracle prices.
  var oracleScaleFactor: UInt32 = 0

  /// Oracle type
  var oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified

  /// maker_fee_rate defines the trade fee rate for makers on the perpetual market
  var makerFeeRate: String = String()

  /// taker_fee_rate defines the trade fee rate for takers on the perpetual market
  var takerFeeRate: String = String()

  /// initial_margin_ratio defines the initial margin ratio for the perpetual market
  var initialMarginRatio: String = String()

  /// maintenance_margin_ratio defines the maintenance margin ratio for the perpetual market
  var maintenanceMarginRatio: String = String()

  /// min_price_tick_size defines the minimum tick size of the order's price and margin
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the order's quantity
  var minQuantityTickSize: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgInstantPerpetualMarketLaunchResponse defines the Msg/InstantPerpetualMarketLaunchResponse response type.
struct Injective_Exchange_V1beta1_MsgInstantPerpetualMarketLaunchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgInstantExpiryFuturesMarketLaunch defines a SDK message for creating a new expiry futures market by paying listing fee without governance
struct Injective_Exchange_V1beta1_MsgInstantExpiryFuturesMarketLaunch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  /// Ticker for the derivative market.
  var ticker: String = String()

  /// type of coin to use as the quote currency
  var quoteDenom: String = String()

  /// Oracle base currency
  var oracleBase: String = String()

  /// Oracle quote currency
  var oracleQuote: String = String()

  /// Oracle type
  var oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified

  /// Scale factor for oracle prices.
  var oracleScaleFactor: UInt32 = 0

  /// Expiration time of the market
  var expiry: Int64 = 0

  /// maker_fee_rate defines the trade fee rate for makers on the expiry futures market
  var makerFeeRate: String = String()

  /// taker_fee_rate defines the trade fee rate for takers on the expiry futures market
  var takerFeeRate: String = String()

  /// initial_margin_ratio defines the initial margin ratio for the derivative market
  var initialMarginRatio: String = String()

  /// maintenance_margin_ratio defines the maintenance margin ratio for the derivative market
  var maintenanceMarginRatio: String = String()

  /// min_price_tick_size defines the minimum tick size of the order's price and margin
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the order's quantity
  var minQuantityTickSize: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgInstantExpiryFuturesMarketLaunchResponse defines the Msg/InstantExpiryFuturesMarketLaunch response type.
struct Injective_Exchange_V1beta1_MsgInstantExpiryFuturesMarketLaunchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCreateSpotMarketOrder defines a SDK message for creating a new spot market order.
struct Injective_Exchange_V1beta1_MsgCreateSpotMarketOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var order: Injective_Exchange_V1beta1_SpotOrder {
    get {return _order ?? Injective_Exchange_V1beta1_SpotOrder()}
    set {_order = newValue}
  }
  /// Returns true if `order` has been explicitly set.
  var hasOrder: Bool {return self._order != nil}
  /// Clears the value of `order`. Subsequent reads from it will return its default value.
  mutating func clearOrder() {self._order = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _order: Injective_Exchange_V1beta1_SpotOrder? = nil
}

/// MsgCreateSpotMarketOrderResponse defines the Msg/CreateSpotMarketLimitOrder response type.
struct Injective_Exchange_V1beta1_MsgCreateSpotMarketOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Cosmos-SDK MsgCreateDerivativeLimitOrder
struct Injective_Exchange_V1beta1_MsgCreateDerivativeLimitOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var order: Injective_Exchange_V1beta1_DerivativeOrder {
    get {return _order ?? Injective_Exchange_V1beta1_DerivativeOrder()}
    set {_order = newValue}
  }
  /// Returns true if `order` has been explicitly set.
  var hasOrder: Bool {return self._order != nil}
  /// Clears the value of `order`. Subsequent reads from it will return its default value.
  mutating func clearOrder() {self._order = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _order: Injective_Exchange_V1beta1_DerivativeOrder? = nil
}

/// MsgCreateDerivativeLimitOrderResponse defines the Msg/CreateDerivativeMarketOrder response type.
struct Injective_Exchange_V1beta1_MsgCreateDerivativeLimitOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Cosmos-SDK MsgBatchCreateDerivativeLimitOrders
struct Injective_Exchange_V1beta1_MsgBatchCreateDerivativeLimitOrders {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var orders: [Injective_Exchange_V1beta1_DerivativeOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBatchCreateDerivativeLimitOrdersResponse defines the Msg/BatchCreateDerivativeLimitOrders response type.
struct Injective_Exchange_V1beta1_MsgBatchCreateDerivativeLimitOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderHashes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCancelSpotOrder defines the Msg/CancelSpotOrder response type.
struct Injective_Exchange_V1beta1_MsgCancelSpotOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var marketID: String = String()

  var subaccountID: String = String()

  var orderHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCancelSpotOrderResponse defines the Msg/CancelSpotOrder response type.
struct Injective_Exchange_V1beta1_MsgCancelSpotOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBatchCancelSpotOrders defines the Msg/BatchCancelSpotOrders response type.
struct Injective_Exchange_V1beta1_MsgBatchCancelSpotOrders {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var data: [Injective_Exchange_V1beta1_OrderData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBatchCancelSpotOrdersResponse defines the Msg/BatchCancelSpotOrders response type.
struct Injective_Exchange_V1beta1_MsgBatchCancelSpotOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: [Bool] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Cosmos-SDK MsgCreateDerivativeMarketOrder
struct Injective_Exchange_V1beta1_MsgCreateDerivativeMarketOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var order: Injective_Exchange_V1beta1_DerivativeOrder {
    get {return _order ?? Injective_Exchange_V1beta1_DerivativeOrder()}
    set {_order = newValue}
  }
  /// Returns true if `order` has been explicitly set.
  var hasOrder: Bool {return self._order != nil}
  /// Clears the value of `order`. Subsequent reads from it will return its default value.
  mutating func clearOrder() {self._order = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _order: Injective_Exchange_V1beta1_DerivativeOrder? = nil
}

/// MsgCreateDerivativeMarketOrderResponse defines the Msg/CreateDerivativeMarketOrder response type.
struct Injective_Exchange_V1beta1_MsgCreateDerivativeMarketOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCancelDerivativeOrder defines the Msg/CancelDerivativeOrder response type.
struct Injective_Exchange_V1beta1_MsgCancelDerivativeOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var marketID: String = String()

  var subaccountID: String = String()

  var orderHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCancelDerivativeOrderResponse defines the Msg/CancelDerivativeOrderResponse response type.
struct Injective_Exchange_V1beta1_MsgCancelDerivativeOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_OrderData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var subaccountID: String = String()

  var orderHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBatchCancelDerivativeOrders defines the Msg/CancelDerivativeOrders response type.
struct Injective_Exchange_V1beta1_MsgBatchCancelDerivativeOrders {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var data: [Injective_Exchange_V1beta1_OrderData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBatchCancelDerivativeOrdersResponse defines the Msg/CancelDerivativeOrderResponse response type.
struct Injective_Exchange_V1beta1_MsgBatchCancelDerivativeOrdersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: [Bool] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Cosmos-SDK MsgSubaccountTransfer
struct Injective_Exchange_V1beta1_MsgSubaccountTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var sourceSubaccountID: String = String()

  var destinationSubaccountID: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgSubaccountTransferResponse defines the Msg/SubaccountTransfer response type.
struct Injective_Exchange_V1beta1_MsgSubaccountTransferResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Cosmos-SDK MsgExternalTransfer
struct Injective_Exchange_V1beta1_MsgExternalTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var sourceSubaccountID: String = String()

  var destinationSubaccountID: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgExternalTransferResponse defines the Msg/ExternalTransfer response type.
struct Injective_Exchange_V1beta1_MsgExternalTransferResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Cosmos-SDK MsgLiquidatePosition
struct Injective_Exchange_V1beta1_MsgLiquidatePosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var subaccountID: String = String()

  var marketID: String = String()

  /// optional order to provide for liquidation
  var order: Injective_Exchange_V1beta1_DerivativeOrder {
    get {return _order ?? Injective_Exchange_V1beta1_DerivativeOrder()}
    set {_order = newValue}
  }
  /// Returns true if `order` has been explicitly set.
  var hasOrder: Bool {return self._order != nil}
  /// Clears the value of `order`. Subsequent reads from it will return its default value.
  mutating func clearOrder() {self._order = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _order: Injective_Exchange_V1beta1_DerivativeOrder? = nil
}

/// MsgLiquidatePositionResponse defines the Msg/LiquidatePosition response type.
struct Injective_Exchange_V1beta1_MsgLiquidatePositionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Cosmos-SDK MsgIncreasePositionMargin
struct Injective_Exchange_V1beta1_MsgIncreasePositionMargin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var sourceSubaccountID: String = String()

  var destinationSubaccountID: String = String()

  var marketID: String = String()

  /// amount defines the amount of margin to add to the position
  var amount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgIncreasePositionMarginResponse defines the Msg/IncreasePositionMargin response type.
struct Injective_Exchange_V1beta1_MsgIncreasePositionMarginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_SpotMarketParamUpdateProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var marketID: String = String()

  /// maker_fee_rate defines the trade fee rate for makers on the spot market
  var makerFeeRate: String = String()

  /// taker_fee_rate defines the trade fee rate for takers on the spot market
  var takerFeeRate: String = String()

  /// relayer_fee_share_rate defines the relayer fee share rate for the spot market
  var relayerFeeShareRate: String = String()

  /// min_price_tick_size defines the minimum tick size of the order's price and margin
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the order's quantity
  var minQuantityTickSize: String = String()

  var status: Injective_Exchange_V1beta1_MarketStatus = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_ExchangeEnableProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var exchangeType: Injective_Exchange_V1beta1_ExchangeType = .exchangeUnspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_BatchExchangeModificationProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var spotMarketParamUpdateProposals: [Injective_Exchange_V1beta1_SpotMarketParamUpdateProposal] {
    get {return _storage._spotMarketParamUpdateProposals}
    set {_uniqueStorage()._spotMarketParamUpdateProposals = newValue}
  }

  var derivativeMarketParamUpdateProposals: [Injective_Exchange_V1beta1_DerivativeMarketParamUpdateProposal] {
    get {return _storage._derivativeMarketParamUpdateProposals}
    set {_uniqueStorage()._derivativeMarketParamUpdateProposals = newValue}
  }

  var spotMarketLaunchProposals: [Injective_Exchange_V1beta1_SpotMarketLaunchProposal] {
    get {return _storage._spotMarketLaunchProposals}
    set {_uniqueStorage()._spotMarketLaunchProposals = newValue}
  }

  var perpetualMarketLaunchProposals: [Injective_Exchange_V1beta1_PerpetualMarketLaunchProposal] {
    get {return _storage._perpetualMarketLaunchProposals}
    set {_uniqueStorage()._perpetualMarketLaunchProposals = newValue}
  }

  var expiryFuturesMarketLaunchProposals: [Injective_Exchange_V1beta1_ExpiryFuturesMarketLaunchProposal] {
    get {return _storage._expiryFuturesMarketLaunchProposals}
    set {_uniqueStorage()._expiryFuturesMarketLaunchProposals = newValue}
  }

  var tradingRewardCampaignUpdateProposal: Injective_Exchange_V1beta1_TradingRewardCampaignUpdateProposal {
    get {return _storage._tradingRewardCampaignUpdateProposal ?? Injective_Exchange_V1beta1_TradingRewardCampaignUpdateProposal()}
    set {_uniqueStorage()._tradingRewardCampaignUpdateProposal = newValue}
  }
  /// Returns true if `tradingRewardCampaignUpdateProposal` has been explicitly set.
  var hasTradingRewardCampaignUpdateProposal: Bool {return _storage._tradingRewardCampaignUpdateProposal != nil}
  /// Clears the value of `tradingRewardCampaignUpdateProposal`. Subsequent reads from it will return its default value.
  mutating func clearTradingRewardCampaignUpdateProposal() {_uniqueStorage()._tradingRewardCampaignUpdateProposal = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SpotMarketLaunchProposal defines a SDK message for proposing a new spot market through governance
struct Injective_Exchange_V1beta1_SpotMarketLaunchProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  /// Ticker for the spot market.
  var ticker: String = String()

  /// type of coin to use as the base currency
  var baseDenom: String = String()

  /// type of coin to use as the quote currency
  var quoteDenom: String = String()

  /// min_price_tick_size defines the minimum tick size of the order's price
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the order's quantity
  var minQuantityTickSize: String = String()

  /// maker_fee_rate defines the fee percentage makers pay when trading
  var makerFeeRate: String = String()

  /// taker_fee_rate defines the fee percentage takers pay when trading
  var takerFeeRate: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PerpetualMarketLaunchProposal defines a SDK message for proposing a new perpetual futures market through governance
struct Injective_Exchange_V1beta1_PerpetualMarketLaunchProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  /// Ticker for the derivative market.
  var ticker: String = String()

  /// type of coin to use as the base currency
  var quoteDenom: String = String()

  /// Oracle base currency
  var oracleBase: String = String()

  /// Oracle quote currency
  var oracleQuote: String = String()

  /// Scale factor for oracle prices.
  var oracleScaleFactor: UInt32 = 0

  /// Oracle type
  var oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified

  /// initial_margin_ratio defines the initial margin ratio for the derivative market
  var initialMarginRatio: String = String()

  /// maintenance_margin_ratio defines the maintenance margin ratio for the derivative market
  var maintenanceMarginRatio: String = String()

  /// maker_fee_rate defines the exchange trade fee for makers for the derivative market
  var makerFeeRate: String = String()

  /// taker_fee_rate defines the exchange trade fee for takers for the derivative market
  var takerFeeRate: String = String()

  /// min_price_tick_size defines the minimum tick size of the order's price and margin
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the order's quantity
  var minQuantityTickSize: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ExpiryFuturesMarketLaunchProposal defines a SDK message for proposing a new expiry futures market through governance
struct Injective_Exchange_V1beta1_ExpiryFuturesMarketLaunchProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  /// Ticker for the derivative market.
  var ticker: String = String()

  /// type of coin to use as the quote currency
  var quoteDenom: String = String()

  /// Oracle base currency
  var oracleBase: String = String()

  /// Oracle quote currency
  var oracleQuote: String = String()

  /// Scale factor for oracle prices.
  var oracleScaleFactor: UInt32 = 0

  /// Oracle type
  var oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified

  /// Expiration time of the market
  var expiry: Int64 = 0

  /// initial_margin_ratio defines the initial margin ratio for the derivative market
  var initialMarginRatio: String = String()

  /// maintenance_margin_ratio defines the maintenance margin ratio for the derivative market
  var maintenanceMarginRatio: String = String()

  /// maker_fee_rate defines the exchange trade fee for makers for the derivative market
  var makerFeeRate: String = String()

  /// taker_fee_rate defines the exchange trade fee for takers for the derivative market
  var takerFeeRate: String = String()

  /// min_price_tick_size defines the minimum tick size of the order's price and margin
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the order's quantity
  var minQuantityTickSize: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_DerivativeMarketParamUpdateProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var marketID: String {
    get {return _storage._marketID}
    set {_uniqueStorage()._marketID = newValue}
  }

  /// initial_margin_ratio defines the initial margin ratio for the derivative market
  var initialMarginRatio: String {
    get {return _storage._initialMarginRatio}
    set {_uniqueStorage()._initialMarginRatio = newValue}
  }

  /// maintenance_margin_ratio defines the maintenance margin ratio for the derivative market
  var maintenanceMarginRatio: String {
    get {return _storage._maintenanceMarginRatio}
    set {_uniqueStorage()._maintenanceMarginRatio = newValue}
  }

  /// maker_fee_rate defines the exchange trade fee for makers for the derivative market
  var makerFeeRate: String {
    get {return _storage._makerFeeRate}
    set {_uniqueStorage()._makerFeeRate = newValue}
  }

  /// taker_fee_rate defines the exchange trade fee for takers for the derivative market
  var takerFeeRate: String {
    get {return _storage._takerFeeRate}
    set {_uniqueStorage()._takerFeeRate = newValue}
  }

  /// relayer_fee_share_rate defines the relayer fee share rate for the derivative market
  var relayerFeeShareRate: String {
    get {return _storage._relayerFeeShareRate}
    set {_uniqueStorage()._relayerFeeShareRate = newValue}
  }

  /// min_price_tick_size defines the minimum tick size of the order's price and margin
  var minPriceTickSize: String {
    get {return _storage._minPriceTickSize}
    set {_uniqueStorage()._minPriceTickSize = newValue}
  }

  /// min_quantity_tick_size defines the minimum tick size of the order's quantity
  var minQuantityTickSize: String {
    get {return _storage._minQuantityTickSize}
    set {_uniqueStorage()._minQuantityTickSize = newValue}
  }

  /// hourly_interest_rate defines the hourly interest rate
  var hourlyInterestRate: String {
    get {return _storage._hourlyInterestRate}
    set {_uniqueStorage()._hourlyInterestRate = newValue}
  }

  /// hourly_funding_rate_cap defines the maximum absolute value of the hourly funding rate
  var hourlyFundingRateCap: String {
    get {return _storage._hourlyFundingRateCap}
    set {_uniqueStorage()._hourlyFundingRateCap = newValue}
  }

  var status: Injective_Exchange_V1beta1_MarketStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var oracleParams: Injective_Exchange_V1beta1_OracleParams {
    get {return _storage._oracleParams ?? Injective_Exchange_V1beta1_OracleParams()}
    set {_uniqueStorage()._oracleParams = newValue}
  }
  /// Returns true if `oracleParams` has been explicitly set.
  var hasOracleParams: Bool {return _storage._oracleParams != nil}
  /// Clears the value of `oracleParams`. Subsequent reads from it will return its default value.
  mutating func clearOracleParams() {_uniqueStorage()._oracleParams = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Injective_Exchange_V1beta1_OracleParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Oracle base currency
  var oracleBase: String = String()

  /// Oracle quote currency
  var oracleQuote: String = String()

  /// Scale factor for oracle prices.
  var oracleScaleFactor: UInt32 = 0

  /// Oracle type
  var oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_TradingRewardCampaignLaunchProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var campaignInfo: Injective_Exchange_V1beta1_TradingRewardCampaignInfo {
    get {return _campaignInfo ?? Injective_Exchange_V1beta1_TradingRewardCampaignInfo()}
    set {_campaignInfo = newValue}
  }
  /// Returns true if `campaignInfo` has been explicitly set.
  var hasCampaignInfo: Bool {return self._campaignInfo != nil}
  /// Clears the value of `campaignInfo`. Subsequent reads from it will return its default value.
  mutating func clearCampaignInfo() {self._campaignInfo = nil}

  var campaignRewardPools: [Injective_Exchange_V1beta1_CampaignRewardPool] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _campaignInfo: Injective_Exchange_V1beta1_TradingRewardCampaignInfo? = nil
}

struct Injective_Exchange_V1beta1_TradingRewardCampaignUpdateProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var campaignInfo: Injective_Exchange_V1beta1_TradingRewardCampaignInfo {
    get {return _campaignInfo ?? Injective_Exchange_V1beta1_TradingRewardCampaignInfo()}
    set {_campaignInfo = newValue}
  }
  /// Returns true if `campaignInfo` has been explicitly set.
  var hasCampaignInfo: Bool {return self._campaignInfo != nil}
  /// Clears the value of `campaignInfo`. Subsequent reads from it will return its default value.
  mutating func clearCampaignInfo() {self._campaignInfo = nil}

  var campaignRewardPoolsAdditions: [Injective_Exchange_V1beta1_CampaignRewardPool] = []

  var campaignRewardPoolsUpdates: [Injective_Exchange_V1beta1_CampaignRewardPool] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _campaignInfo: Injective_Exchange_V1beta1_TradingRewardCampaignInfo? = nil
}

struct Injective_Exchange_V1beta1_FeeDiscountProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var schedule: Injective_Exchange_V1beta1_FeeDiscountSchedule {
    get {return _schedule ?? Injective_Exchange_V1beta1_FeeDiscountSchedule()}
    set {_schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  var hasSchedule: Bool {return self._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  mutating func clearSchedule() {self._schedule = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _schedule: Injective_Exchange_V1beta1_FeeDiscountSchedule? = nil
}

struct Injective_Exchange_V1beta1_BatchCommunityPoolSpendProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var proposals: [Cosmos_Distribution_V1beta1_CommunityPoolSpendProposal] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "injective.exchange.v1beta1"

extension Injective_Exchange_V1beta1_ExchangeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXCHANGE_UNSPECIFIED"),
    1: .same(proto: "SPOT"),
    2: .same(proto: "DERIVATIVES"),
  ]
}

extension Injective_Exchange_V1beta1_MsgDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "subaccount_id"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 2)
    }
    if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgDeposit, rhs: Injective_Exchange_V1beta1_MsgDeposit) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgDepositResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDepositResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgDepositResponse, rhs: Injective_Exchange_V1beta1_MsgDepositResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgWithdraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdraw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "subaccount_id"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 2)
    }
    if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgWithdraw, rhs: Injective_Exchange_V1beta1_MsgWithdraw) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgWithdrawResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgWithdrawResponse, rhs: Injective_Exchange_V1beta1_MsgWithdrawResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateSpotLimitOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateSpotLimitOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if let v = self._order {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateSpotLimitOrder, rhs: Injective_Exchange_V1beta1_MsgCreateSpotLimitOrder) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs._order != rhs._order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateSpotLimitOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateSpotLimitOrderResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateSpotLimitOrderResponse, rhs: Injective_Exchange_V1beta1_MsgCreateSpotLimitOrderResponse) -> Bool {
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchCreateSpotLimitOrders: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchCreateSpotLimitOrders"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchCreateSpotLimitOrders, rhs: Injective_Exchange_V1beta1_MsgBatchCreateSpotLimitOrders) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchCreateSpotLimitOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchCreateSpotLimitOrdersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_hashes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.orderHashes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.orderHashes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchCreateSpotLimitOrdersResponse, rhs: Injective_Exchange_V1beta1_MsgBatchCreateSpotLimitOrdersResponse) -> Bool {
    if lhs.orderHashes != rhs.orderHashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgInstantSpotMarketLaunch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInstantSpotMarketLaunch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "base_denom"),
    4: .standard(proto: "quote_denom"),
    5: .standard(proto: "min_price_tick_size"),
    6: .standard(proto: "min_quantity_tick_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.baseDenom) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.quoteDenom) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 2)
    }
    if !self.baseDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.baseDenom, fieldNumber: 3)
    }
    if !self.quoteDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteDenom, fieldNumber: 4)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 5)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgInstantSpotMarketLaunch, rhs: Injective_Exchange_V1beta1_MsgInstantSpotMarketLaunch) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.baseDenom != rhs.baseDenom {return false}
    if lhs.quoteDenom != rhs.quoteDenom {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgInstantSpotMarketLaunchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInstantSpotMarketLaunchResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgInstantSpotMarketLaunchResponse, rhs: Injective_Exchange_V1beta1_MsgInstantSpotMarketLaunchResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgInstantPerpetualMarketLaunch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInstantPerpetualMarketLaunch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "quote_denom"),
    4: .standard(proto: "oracle_base"),
    5: .standard(proto: "oracle_quote"),
    6: .standard(proto: "oracle_scale_factor"),
    7: .standard(proto: "oracle_type"),
    8: .standard(proto: "maker_fee_rate"),
    9: .standard(proto: "taker_fee_rate"),
    10: .standard(proto: "initial_margin_ratio"),
    11: .standard(proto: "maintenance_margin_ratio"),
    12: .standard(proto: "min_price_tick_size"),
    13: .standard(proto: "min_quantity_tick_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.quoteDenom) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.oracleBase) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.oracleQuote) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.oracleScaleFactor) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.oracleType) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.makerFeeRate) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.takerFeeRate) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.initialMarginRatio) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.maintenanceMarginRatio) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 2)
    }
    if !self.quoteDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteDenom, fieldNumber: 3)
    }
    if !self.oracleBase.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleBase, fieldNumber: 4)
    }
    if !self.oracleQuote.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleQuote, fieldNumber: 5)
    }
    if self.oracleScaleFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.oracleScaleFactor, fieldNumber: 6)
    }
    if self.oracleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracleType, fieldNumber: 7)
    }
    if !self.makerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerFeeRate, fieldNumber: 8)
    }
    if !self.takerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerFeeRate, fieldNumber: 9)
    }
    if !self.initialMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.initialMarginRatio, fieldNumber: 10)
    }
    if !self.maintenanceMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.maintenanceMarginRatio, fieldNumber: 11)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 12)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgInstantPerpetualMarketLaunch, rhs: Injective_Exchange_V1beta1_MsgInstantPerpetualMarketLaunch) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.quoteDenom != rhs.quoteDenom {return false}
    if lhs.oracleBase != rhs.oracleBase {return false}
    if lhs.oracleQuote != rhs.oracleQuote {return false}
    if lhs.oracleScaleFactor != rhs.oracleScaleFactor {return false}
    if lhs.oracleType != rhs.oracleType {return false}
    if lhs.makerFeeRate != rhs.makerFeeRate {return false}
    if lhs.takerFeeRate != rhs.takerFeeRate {return false}
    if lhs.initialMarginRatio != rhs.initialMarginRatio {return false}
    if lhs.maintenanceMarginRatio != rhs.maintenanceMarginRatio {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgInstantPerpetualMarketLaunchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInstantPerpetualMarketLaunchResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgInstantPerpetualMarketLaunchResponse, rhs: Injective_Exchange_V1beta1_MsgInstantPerpetualMarketLaunchResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgInstantExpiryFuturesMarketLaunch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInstantExpiryFuturesMarketLaunch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "quote_denom"),
    4: .standard(proto: "oracle_base"),
    5: .standard(proto: "oracle_quote"),
    6: .standard(proto: "oracle_type"),
    7: .standard(proto: "oracle_scale_factor"),
    8: .same(proto: "expiry"),
    9: .standard(proto: "maker_fee_rate"),
    10: .standard(proto: "taker_fee_rate"),
    11: .standard(proto: "initial_margin_ratio"),
    12: .standard(proto: "maintenance_margin_ratio"),
    13: .standard(proto: "min_price_tick_size"),
    14: .standard(proto: "min_quantity_tick_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.quoteDenom) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.oracleBase) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.oracleQuote) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.oracleType) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.oracleScaleFactor) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.expiry) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.makerFeeRate) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.takerFeeRate) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.initialMarginRatio) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.maintenanceMarginRatio) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 2)
    }
    if !self.quoteDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteDenom, fieldNumber: 3)
    }
    if !self.oracleBase.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleBase, fieldNumber: 4)
    }
    if !self.oracleQuote.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleQuote, fieldNumber: 5)
    }
    if self.oracleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracleType, fieldNumber: 6)
    }
    if self.oracleScaleFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.oracleScaleFactor, fieldNumber: 7)
    }
    if self.expiry != 0 {
      try visitor.visitSingularInt64Field(value: self.expiry, fieldNumber: 8)
    }
    if !self.makerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerFeeRate, fieldNumber: 9)
    }
    if !self.takerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerFeeRate, fieldNumber: 10)
    }
    if !self.initialMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.initialMarginRatio, fieldNumber: 11)
    }
    if !self.maintenanceMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.maintenanceMarginRatio, fieldNumber: 12)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 13)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgInstantExpiryFuturesMarketLaunch, rhs: Injective_Exchange_V1beta1_MsgInstantExpiryFuturesMarketLaunch) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.quoteDenom != rhs.quoteDenom {return false}
    if lhs.oracleBase != rhs.oracleBase {return false}
    if lhs.oracleQuote != rhs.oracleQuote {return false}
    if lhs.oracleType != rhs.oracleType {return false}
    if lhs.oracleScaleFactor != rhs.oracleScaleFactor {return false}
    if lhs.expiry != rhs.expiry {return false}
    if lhs.makerFeeRate != rhs.makerFeeRate {return false}
    if lhs.takerFeeRate != rhs.takerFeeRate {return false}
    if lhs.initialMarginRatio != rhs.initialMarginRatio {return false}
    if lhs.maintenanceMarginRatio != rhs.maintenanceMarginRatio {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgInstantExpiryFuturesMarketLaunchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgInstantExpiryFuturesMarketLaunchResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgInstantExpiryFuturesMarketLaunchResponse, rhs: Injective_Exchange_V1beta1_MsgInstantExpiryFuturesMarketLaunchResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateSpotMarketOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateSpotMarketOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if let v = self._order {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateSpotMarketOrder, rhs: Injective_Exchange_V1beta1_MsgCreateSpotMarketOrder) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs._order != rhs._order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateSpotMarketOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateSpotMarketOrderResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateSpotMarketOrderResponse, rhs: Injective_Exchange_V1beta1_MsgCreateSpotMarketOrderResponse) -> Bool {
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateDerivativeLimitOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateDerivativeLimitOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if let v = self._order {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateDerivativeLimitOrder, rhs: Injective_Exchange_V1beta1_MsgCreateDerivativeLimitOrder) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs._order != rhs._order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateDerivativeLimitOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateDerivativeLimitOrderResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateDerivativeLimitOrderResponse, rhs: Injective_Exchange_V1beta1_MsgCreateDerivativeLimitOrderResponse) -> Bool {
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchCreateDerivativeLimitOrders: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchCreateDerivativeLimitOrders"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchCreateDerivativeLimitOrders, rhs: Injective_Exchange_V1beta1_MsgBatchCreateDerivativeLimitOrders) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchCreateDerivativeLimitOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchCreateDerivativeLimitOrdersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_hashes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.orderHashes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderHashes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.orderHashes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchCreateDerivativeLimitOrdersResponse, rhs: Injective_Exchange_V1beta1_MsgBatchCreateDerivativeLimitOrdersResponse) -> Bool {
    if lhs.orderHashes != rhs.orderHashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCancelSpotOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelSpotOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "market_id"),
    3: .standard(proto: "subaccount_id"),
    4: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 2)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 3)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCancelSpotOrder, rhs: Injective_Exchange_V1beta1_MsgCancelSpotOrder) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCancelSpotOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelSpotOrderResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCancelSpotOrderResponse, rhs: Injective_Exchange_V1beta1_MsgCancelSpotOrderResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchCancelSpotOrders: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchCancelSpotOrders"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchCancelSpotOrders, rhs: Injective_Exchange_V1beta1_MsgBatchCancelSpotOrders) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchCancelSpotOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchCancelSpotOrdersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.success.isEmpty {
      try visitor.visitPackedBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchCancelSpotOrdersResponse, rhs: Injective_Exchange_V1beta1_MsgBatchCancelSpotOrdersResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateDerivativeMarketOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateDerivativeMarketOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if let v = self._order {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateDerivativeMarketOrder, rhs: Injective_Exchange_V1beta1_MsgCreateDerivativeMarketOrder) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs._order != rhs._order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCreateDerivativeMarketOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateDerivativeMarketOrderResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCreateDerivativeMarketOrderResponse, rhs: Injective_Exchange_V1beta1_MsgCreateDerivativeMarketOrderResponse) -> Bool {
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCancelDerivativeOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelDerivativeOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "market_id"),
    3: .standard(proto: "subaccount_id"),
    4: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 2)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 3)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCancelDerivativeOrder, rhs: Injective_Exchange_V1beta1_MsgCancelDerivativeOrder) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgCancelDerivativeOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelDerivativeOrderResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgCancelDerivativeOrderResponse, rhs: Injective_Exchange_V1beta1_MsgCancelDerivativeOrderResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_OrderData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "subaccount_id"),
    3: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 2)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularStringField(value: self.orderHash, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_OrderData, rhs: Injective_Exchange_V1beta1_OrderData) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchCancelDerivativeOrders: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchCancelDerivativeOrders"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchCancelDerivativeOrders, rhs: Injective_Exchange_V1beta1_MsgBatchCancelDerivativeOrders) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgBatchCancelDerivativeOrdersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBatchCancelDerivativeOrdersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.success.isEmpty {
      try visitor.visitPackedBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgBatchCancelDerivativeOrdersResponse, rhs: Injective_Exchange_V1beta1_MsgBatchCancelDerivativeOrdersResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgSubaccountTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSubaccountTransfer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "source_subaccount_id"),
    3: .standard(proto: "destination_subaccount_id"),
    4: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceSubaccountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.destinationSubaccountID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.sourceSubaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceSubaccountID, fieldNumber: 2)
    }
    if !self.destinationSubaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationSubaccountID, fieldNumber: 3)
    }
    if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgSubaccountTransfer, rhs: Injective_Exchange_V1beta1_MsgSubaccountTransfer) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.sourceSubaccountID != rhs.sourceSubaccountID {return false}
    if lhs.destinationSubaccountID != rhs.destinationSubaccountID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgSubaccountTransferResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSubaccountTransferResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgSubaccountTransferResponse, rhs: Injective_Exchange_V1beta1_MsgSubaccountTransferResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgExternalTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgExternalTransfer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "source_subaccount_id"),
    3: .standard(proto: "destination_subaccount_id"),
    4: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceSubaccountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.destinationSubaccountID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.sourceSubaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceSubaccountID, fieldNumber: 2)
    }
    if !self.destinationSubaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationSubaccountID, fieldNumber: 3)
    }
    if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgExternalTransfer, rhs: Injective_Exchange_V1beta1_MsgExternalTransfer) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.sourceSubaccountID != rhs.sourceSubaccountID {return false}
    if lhs.destinationSubaccountID != rhs.destinationSubaccountID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgExternalTransferResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgExternalTransferResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgExternalTransferResponse, rhs: Injective_Exchange_V1beta1_MsgExternalTransferResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgLiquidatePosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgLiquidatePosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "subaccount_id"),
    3: .standard(proto: "market_id"),
    4: .same(proto: "order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 2)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 3)
    }
    if let v = self._order {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgLiquidatePosition, rhs: Injective_Exchange_V1beta1_MsgLiquidatePosition) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs._order != rhs._order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgLiquidatePositionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgLiquidatePositionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgLiquidatePositionResponse, rhs: Injective_Exchange_V1beta1_MsgLiquidatePositionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgIncreasePositionMargin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgIncreasePositionMargin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "source_subaccount_id"),
    3: .standard(proto: "destination_subaccount_id"),
    4: .standard(proto: "market_id"),
    5: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceSubaccountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.destinationSubaccountID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.sourceSubaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceSubaccountID, fieldNumber: 2)
    }
    if !self.destinationSubaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationSubaccountID, fieldNumber: 3)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 4)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgIncreasePositionMargin, rhs: Injective_Exchange_V1beta1_MsgIncreasePositionMargin) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.sourceSubaccountID != rhs.sourceSubaccountID {return false}
    if lhs.destinationSubaccountID != rhs.destinationSubaccountID {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MsgIncreasePositionMarginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgIncreasePositionMarginResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MsgIncreasePositionMarginResponse, rhs: Injective_Exchange_V1beta1_MsgIncreasePositionMarginResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SpotMarketParamUpdateProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpotMarketParamUpdateProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "market_id"),
    4: .standard(proto: "maker_fee_rate"),
    5: .standard(proto: "taker_fee_rate"),
    6: .standard(proto: "relayer_fee_share_rate"),
    7: .standard(proto: "min_price_tick_size"),
    8: .standard(proto: "min_quantity_tick_size"),
    9: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.makerFeeRate) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.takerFeeRate) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.relayerFeeShareRate) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 3)
    }
    if !self.makerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerFeeRate, fieldNumber: 4)
    }
    if !self.takerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerFeeRate, fieldNumber: 5)
    }
    if !self.relayerFeeShareRate.isEmpty {
      try visitor.visitSingularStringField(value: self.relayerFeeShareRate, fieldNumber: 6)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 7)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 8)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SpotMarketParamUpdateProposal, rhs: Injective_Exchange_V1beta1_SpotMarketParamUpdateProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.makerFeeRate != rhs.makerFeeRate {return false}
    if lhs.takerFeeRate != rhs.takerFeeRate {return false}
    if lhs.relayerFeeShareRate != rhs.relayerFeeShareRate {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_ExchangeEnableProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExchangeEnableProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "exchangeType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.exchangeType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if self.exchangeType != .exchangeUnspecified {
      try visitor.visitSingularEnumField(value: self.exchangeType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_ExchangeEnableProposal, rhs: Injective_Exchange_V1beta1_ExchangeEnableProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.exchangeType != rhs.exchangeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_BatchExchangeModificationProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchExchangeModificationProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "spot_market_param_update_proposals"),
    4: .standard(proto: "derivative_market_param_update_proposals"),
    5: .standard(proto: "spot_market_launch_proposals"),
    6: .standard(proto: "perpetual_market_launch_proposals"),
    7: .standard(proto: "expiry_futures_market_launch_proposals"),
    8: .standard(proto: "trading_reward_campaign_update_proposal"),
  ]

  fileprivate class _StorageClass {
    var _title: String = String()
    var _description_p: String = String()
    var _spotMarketParamUpdateProposals: [Injective_Exchange_V1beta1_SpotMarketParamUpdateProposal] = []
    var _derivativeMarketParamUpdateProposals: [Injective_Exchange_V1beta1_DerivativeMarketParamUpdateProposal] = []
    var _spotMarketLaunchProposals: [Injective_Exchange_V1beta1_SpotMarketLaunchProposal] = []
    var _perpetualMarketLaunchProposals: [Injective_Exchange_V1beta1_PerpetualMarketLaunchProposal] = []
    var _expiryFuturesMarketLaunchProposals: [Injective_Exchange_V1beta1_ExpiryFuturesMarketLaunchProposal] = []
    var _tradingRewardCampaignUpdateProposal: Injective_Exchange_V1beta1_TradingRewardCampaignUpdateProposal? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _title = source._title
      _description_p = source._description_p
      _spotMarketParamUpdateProposals = source._spotMarketParamUpdateProposals
      _derivativeMarketParamUpdateProposals = source._derivativeMarketParamUpdateProposals
      _spotMarketLaunchProposals = source._spotMarketLaunchProposals
      _perpetualMarketLaunchProposals = source._perpetualMarketLaunchProposals
      _expiryFuturesMarketLaunchProposals = source._expiryFuturesMarketLaunchProposals
      _tradingRewardCampaignUpdateProposal = source._tradingRewardCampaignUpdateProposal
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._spotMarketParamUpdateProposals) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._derivativeMarketParamUpdateProposals) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._spotMarketLaunchProposals) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._perpetualMarketLaunchProposals) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._expiryFuturesMarketLaunchProposals) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._tradingRewardCampaignUpdateProposal) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if !_storage._spotMarketParamUpdateProposals.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._spotMarketParamUpdateProposals, fieldNumber: 3)
      }
      if !_storage._derivativeMarketParamUpdateProposals.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._derivativeMarketParamUpdateProposals, fieldNumber: 4)
      }
      if !_storage._spotMarketLaunchProposals.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._spotMarketLaunchProposals, fieldNumber: 5)
      }
      if !_storage._perpetualMarketLaunchProposals.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._perpetualMarketLaunchProposals, fieldNumber: 6)
      }
      if !_storage._expiryFuturesMarketLaunchProposals.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._expiryFuturesMarketLaunchProposals, fieldNumber: 7)
      }
      if let v = _storage._tradingRewardCampaignUpdateProposal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_BatchExchangeModificationProposal, rhs: Injective_Exchange_V1beta1_BatchExchangeModificationProposal) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._title != rhs_storage._title {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._spotMarketParamUpdateProposals != rhs_storage._spotMarketParamUpdateProposals {return false}
        if _storage._derivativeMarketParamUpdateProposals != rhs_storage._derivativeMarketParamUpdateProposals {return false}
        if _storage._spotMarketLaunchProposals != rhs_storage._spotMarketLaunchProposals {return false}
        if _storage._perpetualMarketLaunchProposals != rhs_storage._perpetualMarketLaunchProposals {return false}
        if _storage._expiryFuturesMarketLaunchProposals != rhs_storage._expiryFuturesMarketLaunchProposals {return false}
        if _storage._tradingRewardCampaignUpdateProposal != rhs_storage._tradingRewardCampaignUpdateProposal {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SpotMarketLaunchProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpotMarketLaunchProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "ticker"),
    4: .standard(proto: "base_denom"),
    5: .standard(proto: "quote_denom"),
    6: .standard(proto: "min_price_tick_size"),
    7: .standard(proto: "min_quantity_tick_size"),
    8: .standard(proto: "maker_fee_rate"),
    9: .standard(proto: "taker_fee_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.baseDenom) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.quoteDenom) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.makerFeeRate) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.takerFeeRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 3)
    }
    if !self.baseDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.baseDenom, fieldNumber: 4)
    }
    if !self.quoteDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteDenom, fieldNumber: 5)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 6)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 7)
    }
    if !self.makerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerFeeRate, fieldNumber: 8)
    }
    if !self.takerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerFeeRate, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SpotMarketLaunchProposal, rhs: Injective_Exchange_V1beta1_SpotMarketLaunchProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.baseDenom != rhs.baseDenom {return false}
    if lhs.quoteDenom != rhs.quoteDenom {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.makerFeeRate != rhs.makerFeeRate {return false}
    if lhs.takerFeeRate != rhs.takerFeeRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_PerpetualMarketLaunchProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PerpetualMarketLaunchProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "ticker"),
    4: .standard(proto: "quote_denom"),
    5: .standard(proto: "oracle_base"),
    6: .standard(proto: "oracle_quote"),
    7: .standard(proto: "oracle_scale_factor"),
    8: .standard(proto: "oracle_type"),
    9: .standard(proto: "initial_margin_ratio"),
    10: .standard(proto: "maintenance_margin_ratio"),
    11: .standard(proto: "maker_fee_rate"),
    12: .standard(proto: "taker_fee_rate"),
    13: .standard(proto: "min_price_tick_size"),
    14: .standard(proto: "min_quantity_tick_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.quoteDenom) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.oracleBase) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.oracleQuote) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.oracleScaleFactor) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.oracleType) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.initialMarginRatio) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.maintenanceMarginRatio) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.makerFeeRate) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.takerFeeRate) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 3)
    }
    if !self.quoteDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteDenom, fieldNumber: 4)
    }
    if !self.oracleBase.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleBase, fieldNumber: 5)
    }
    if !self.oracleQuote.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleQuote, fieldNumber: 6)
    }
    if self.oracleScaleFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.oracleScaleFactor, fieldNumber: 7)
    }
    if self.oracleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracleType, fieldNumber: 8)
    }
    if !self.initialMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.initialMarginRatio, fieldNumber: 9)
    }
    if !self.maintenanceMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.maintenanceMarginRatio, fieldNumber: 10)
    }
    if !self.makerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerFeeRate, fieldNumber: 11)
    }
    if !self.takerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerFeeRate, fieldNumber: 12)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 13)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_PerpetualMarketLaunchProposal, rhs: Injective_Exchange_V1beta1_PerpetualMarketLaunchProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.quoteDenom != rhs.quoteDenom {return false}
    if lhs.oracleBase != rhs.oracleBase {return false}
    if lhs.oracleQuote != rhs.oracleQuote {return false}
    if lhs.oracleScaleFactor != rhs.oracleScaleFactor {return false}
    if lhs.oracleType != rhs.oracleType {return false}
    if lhs.initialMarginRatio != rhs.initialMarginRatio {return false}
    if lhs.maintenanceMarginRatio != rhs.maintenanceMarginRatio {return false}
    if lhs.makerFeeRate != rhs.makerFeeRate {return false}
    if lhs.takerFeeRate != rhs.takerFeeRate {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_ExpiryFuturesMarketLaunchProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpiryFuturesMarketLaunchProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "ticker"),
    4: .standard(proto: "quote_denom"),
    5: .standard(proto: "oracle_base"),
    6: .standard(proto: "oracle_quote"),
    7: .standard(proto: "oracle_scale_factor"),
    8: .standard(proto: "oracle_type"),
    9: .same(proto: "expiry"),
    10: .standard(proto: "initial_margin_ratio"),
    11: .standard(proto: "maintenance_margin_ratio"),
    12: .standard(proto: "maker_fee_rate"),
    13: .standard(proto: "taker_fee_rate"),
    14: .standard(proto: "min_price_tick_size"),
    15: .standard(proto: "min_quantity_tick_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.quoteDenom) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.oracleBase) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.oracleQuote) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.oracleScaleFactor) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.oracleType) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.expiry) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.initialMarginRatio) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.maintenanceMarginRatio) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.makerFeeRate) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.takerFeeRate) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 3)
    }
    if !self.quoteDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteDenom, fieldNumber: 4)
    }
    if !self.oracleBase.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleBase, fieldNumber: 5)
    }
    if !self.oracleQuote.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleQuote, fieldNumber: 6)
    }
    if self.oracleScaleFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.oracleScaleFactor, fieldNumber: 7)
    }
    if self.oracleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracleType, fieldNumber: 8)
    }
    if self.expiry != 0 {
      try visitor.visitSingularInt64Field(value: self.expiry, fieldNumber: 9)
    }
    if !self.initialMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.initialMarginRatio, fieldNumber: 10)
    }
    if !self.maintenanceMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.maintenanceMarginRatio, fieldNumber: 11)
    }
    if !self.makerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerFeeRate, fieldNumber: 12)
    }
    if !self.takerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerFeeRate, fieldNumber: 13)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 14)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_ExpiryFuturesMarketLaunchProposal, rhs: Injective_Exchange_V1beta1_ExpiryFuturesMarketLaunchProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.quoteDenom != rhs.quoteDenom {return false}
    if lhs.oracleBase != rhs.oracleBase {return false}
    if lhs.oracleQuote != rhs.oracleQuote {return false}
    if lhs.oracleScaleFactor != rhs.oracleScaleFactor {return false}
    if lhs.oracleType != rhs.oracleType {return false}
    if lhs.expiry != rhs.expiry {return false}
    if lhs.initialMarginRatio != rhs.initialMarginRatio {return false}
    if lhs.maintenanceMarginRatio != rhs.maintenanceMarginRatio {return false}
    if lhs.makerFeeRate != rhs.makerFeeRate {return false}
    if lhs.takerFeeRate != rhs.takerFeeRate {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeMarketParamUpdateProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeMarketParamUpdateProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "market_id"),
    4: .standard(proto: "initial_margin_ratio"),
    5: .standard(proto: "maintenance_margin_ratio"),
    6: .standard(proto: "maker_fee_rate"),
    7: .standard(proto: "taker_fee_rate"),
    8: .standard(proto: "relayer_fee_share_rate"),
    9: .standard(proto: "min_price_tick_size"),
    10: .standard(proto: "min_quantity_tick_size"),
    11: .same(proto: "HourlyInterestRate"),
    12: .same(proto: "HourlyFundingRateCap"),
    13: .same(proto: "status"),
    14: .standard(proto: "oracle_params"),
  ]

  fileprivate class _StorageClass {
    var _title: String = String()
    var _description_p: String = String()
    var _marketID: String = String()
    var _initialMarginRatio: String = String()
    var _maintenanceMarginRatio: String = String()
    var _makerFeeRate: String = String()
    var _takerFeeRate: String = String()
    var _relayerFeeShareRate: String = String()
    var _minPriceTickSize: String = String()
    var _minQuantityTickSize: String = String()
    var _hourlyInterestRate: String = String()
    var _hourlyFundingRateCap: String = String()
    var _status: Injective_Exchange_V1beta1_MarketStatus = .unspecified
    var _oracleParams: Injective_Exchange_V1beta1_OracleParams? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _title = source._title
      _description_p = source._description_p
      _marketID = source._marketID
      _initialMarginRatio = source._initialMarginRatio
      _maintenanceMarginRatio = source._maintenanceMarginRatio
      _makerFeeRate = source._makerFeeRate
      _takerFeeRate = source._takerFeeRate
      _relayerFeeShareRate = source._relayerFeeShareRate
      _minPriceTickSize = source._minPriceTickSize
      _minQuantityTickSize = source._minQuantityTickSize
      _hourlyInterestRate = source._hourlyInterestRate
      _hourlyFundingRateCap = source._hourlyFundingRateCap
      _status = source._status
      _oracleParams = source._oracleParams
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._marketID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._initialMarginRatio) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._maintenanceMarginRatio) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._makerFeeRate) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._takerFeeRate) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._relayerFeeShareRate) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._minPriceTickSize) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._minQuantityTickSize) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._hourlyInterestRate) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._hourlyFundingRateCap) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._oracleParams) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if !_storage._marketID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._marketID, fieldNumber: 3)
      }
      if !_storage._initialMarginRatio.isEmpty {
        try visitor.visitSingularStringField(value: _storage._initialMarginRatio, fieldNumber: 4)
      }
      if !_storage._maintenanceMarginRatio.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maintenanceMarginRatio, fieldNumber: 5)
      }
      if !_storage._makerFeeRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._makerFeeRate, fieldNumber: 6)
      }
      if !_storage._takerFeeRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._takerFeeRate, fieldNumber: 7)
      }
      if !_storage._relayerFeeShareRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._relayerFeeShareRate, fieldNumber: 8)
      }
      if !_storage._minPriceTickSize.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minPriceTickSize, fieldNumber: 9)
      }
      if !_storage._minQuantityTickSize.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minQuantityTickSize, fieldNumber: 10)
      }
      if !_storage._hourlyInterestRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hourlyInterestRate, fieldNumber: 11)
      }
      if !_storage._hourlyFundingRateCap.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hourlyFundingRateCap, fieldNumber: 12)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 13)
      }
      if let v = _storage._oracleParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeMarketParamUpdateProposal, rhs: Injective_Exchange_V1beta1_DerivativeMarketParamUpdateProposal) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._title != rhs_storage._title {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._marketID != rhs_storage._marketID {return false}
        if _storage._initialMarginRatio != rhs_storage._initialMarginRatio {return false}
        if _storage._maintenanceMarginRatio != rhs_storage._maintenanceMarginRatio {return false}
        if _storage._makerFeeRate != rhs_storage._makerFeeRate {return false}
        if _storage._takerFeeRate != rhs_storage._takerFeeRate {return false}
        if _storage._relayerFeeShareRate != rhs_storage._relayerFeeShareRate {return false}
        if _storage._minPriceTickSize != rhs_storage._minPriceTickSize {return false}
        if _storage._minQuantityTickSize != rhs_storage._minQuantityTickSize {return false}
        if _storage._hourlyInterestRate != rhs_storage._hourlyInterestRate {return false}
        if _storage._hourlyFundingRateCap != rhs_storage._hourlyFundingRateCap {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._oracleParams != rhs_storage._oracleParams {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_OracleParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OracleParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "oracle_base"),
    2: .standard(proto: "oracle_quote"),
    3: .standard(proto: "oracle_scale_factor"),
    4: .standard(proto: "oracle_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.oracleBase) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.oracleQuote) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.oracleScaleFactor) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.oracleType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.oracleBase.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleBase, fieldNumber: 1)
    }
    if !self.oracleQuote.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleQuote, fieldNumber: 2)
    }
    if self.oracleScaleFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.oracleScaleFactor, fieldNumber: 3)
    }
    if self.oracleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracleType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_OracleParams, rhs: Injective_Exchange_V1beta1_OracleParams) -> Bool {
    if lhs.oracleBase != rhs.oracleBase {return false}
    if lhs.oracleQuote != rhs.oracleQuote {return false}
    if lhs.oracleScaleFactor != rhs.oracleScaleFactor {return false}
    if lhs.oracleType != rhs.oracleType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TradingRewardCampaignLaunchProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradingRewardCampaignLaunchProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "campaign_info"),
    4: .standard(proto: "campaign_reward_pools"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._campaignInfo) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.campaignRewardPools) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if let v = self._campaignInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.campaignRewardPools.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.campaignRewardPools, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TradingRewardCampaignLaunchProposal, rhs: Injective_Exchange_V1beta1_TradingRewardCampaignLaunchProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._campaignInfo != rhs._campaignInfo {return false}
    if lhs.campaignRewardPools != rhs.campaignRewardPools {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TradingRewardCampaignUpdateProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradingRewardCampaignUpdateProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "campaign_info"),
    4: .standard(proto: "campaign_reward_pools_additions"),
    5: .standard(proto: "campaign_reward_pools_updates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._campaignInfo) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.campaignRewardPoolsAdditions) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.campaignRewardPoolsUpdates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if let v = self._campaignInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.campaignRewardPoolsAdditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.campaignRewardPoolsAdditions, fieldNumber: 4)
    }
    if !self.campaignRewardPoolsUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.campaignRewardPoolsUpdates, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TradingRewardCampaignUpdateProposal, rhs: Injective_Exchange_V1beta1_TradingRewardCampaignUpdateProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._campaignInfo != rhs._campaignInfo {return false}
    if lhs.campaignRewardPoolsAdditions != rhs.campaignRewardPoolsAdditions {return false}
    if lhs.campaignRewardPoolsUpdates != rhs.campaignRewardPoolsUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_FeeDiscountProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeDiscountProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "schedule"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._schedule) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if let v = self._schedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_FeeDiscountProposal, rhs: Injective_Exchange_V1beta1_FeeDiscountProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._schedule != rhs._schedule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_BatchCommunityPoolSpendProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchCommunityPoolSpendProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "proposals"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.proposals) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.proposals.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.proposals, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_BatchCommunityPoolSpendProposal, rhs: Injective_Exchange_V1beta1_BatchCommunityPoolSpendProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.proposals != rhs.proposals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
