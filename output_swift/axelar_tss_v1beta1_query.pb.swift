// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: axelar/tss/v1beta1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Axelar_Tss_V1beta1_VoteStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case notFound // = 1
  case pending // = 2
  case decided // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notFound
    case 2: self = .pending
    case 3: self = .decided
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notFound: return 1
    case .pending: return 2
    case .decided: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Axelar_Tss_V1beta1_VoteStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Axelar_Tss_V1beta1_VoteStatus] = [
    .unspecified,
    .notFound,
    .pending,
    .decided,
  ]
}

#endif  // swift(>=4.2)

struct Axelar_Tss_V1beta1_QuerySignatureResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sig: Axelar_Tss_V1beta1_QuerySignatureResponse.OneOf_Sig? = nil

  var thresholdSignature: Axelar_Tss_V1beta1_QuerySignatureResponse.ThresholdSignature {
    get {
      if case .thresholdSignature(let v)? = sig {return v}
      return Axelar_Tss_V1beta1_QuerySignatureResponse.ThresholdSignature()
    }
    set {sig = .thresholdSignature(newValue)}
  }

  var multisigSignature: Axelar_Tss_V1beta1_QuerySignatureResponse.MultisigSignature {
    get {
      if case .multisigSignature(let v)? = sig {return v}
      return Axelar_Tss_V1beta1_QuerySignatureResponse.MultisigSignature()
    }
    set {sig = .multisigSignature(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Sig: Equatable {
    case thresholdSignature(Axelar_Tss_V1beta1_QuerySignatureResponse.ThresholdSignature)
    case multisigSignature(Axelar_Tss_V1beta1_QuerySignatureResponse.MultisigSignature)

  #if !swift(>=4.1)
    static func ==(lhs: Axelar_Tss_V1beta1_QuerySignatureResponse.OneOf_Sig, rhs: Axelar_Tss_V1beta1_QuerySignatureResponse.OneOf_Sig) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.thresholdSignature, .thresholdSignature): return {
        guard case .thresholdSignature(let l) = lhs, case .thresholdSignature(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multisigSignature, .multisigSignature): return {
        guard case .multisigSignature(let l) = lhs, case .multisigSignature(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct Signature {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var r: String = String()

    var s: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ThresholdSignature {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var voteStatus: Axelar_Tss_V1beta1_VoteStatus = .unspecified

    var signature: Axelar_Tss_V1beta1_QuerySignatureResponse.Signature {
      get {return _signature ?? Axelar_Tss_V1beta1_QuerySignatureResponse.Signature()}
      set {_signature = newValue}
    }
    /// Returns true if `signature` has been explicitly set.
    var hasSignature: Bool {return self._signature != nil}
    /// Clears the value of `signature`. Subsequent reads from it will return its default value.
    mutating func clearSignature() {self._signature = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _signature: Axelar_Tss_V1beta1_QuerySignatureResponse.Signature? = nil
  }

  struct MultisigSignature {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sigStatus: Axelar_Tss_Exported_V1beta1_SigStatus = .unspecified

    var signatures: [Axelar_Tss_V1beta1_QuerySignatureResponse.Signature] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Axelar_Tss_V1beta1_QueryKeyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: Axelar_Tss_V1beta1_QueryKeyResponse.OneOf_PublicKey? = nil

  var ecdsaKey: Axelar_Tss_V1beta1_QueryKeyResponse.ECDSAKey {
    get {
      if case .ecdsaKey(let v)? = publicKey {return v}
      return Axelar_Tss_V1beta1_QueryKeyResponse.ECDSAKey()
    }
    set {publicKey = .ecdsaKey(newValue)}
  }

  var multisigKey: Axelar_Tss_V1beta1_QueryKeyResponse.MultisigKey {
    get {
      if case .multisigKey(let v)? = publicKey {return v}
      return Axelar_Tss_V1beta1_QueryKeyResponse.MultisigKey()
    }
    set {publicKey = .multisigKey(newValue)}
  }

  var role: Axelar_Tss_Exported_V1beta1_KeyRole = .unspecified

  var rotatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _rotatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_rotatedAt = newValue}
  }
  /// Returns true if `rotatedAt` has been explicitly set.
  var hasRotatedAt: Bool {return self._rotatedAt != nil}
  /// Clears the value of `rotatedAt`. Subsequent reads from it will return its default value.
  mutating func clearRotatedAt() {self._rotatedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_PublicKey: Equatable {
    case ecdsaKey(Axelar_Tss_V1beta1_QueryKeyResponse.ECDSAKey)
    case multisigKey(Axelar_Tss_V1beta1_QueryKeyResponse.MultisigKey)

  #if !swift(>=4.1)
    static func ==(lhs: Axelar_Tss_V1beta1_QueryKeyResponse.OneOf_PublicKey, rhs: Axelar_Tss_V1beta1_QueryKeyResponse.OneOf_PublicKey) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.ecdsaKey, .ecdsaKey): return {
        guard case .ecdsaKey(let l) = lhs, case .ecdsaKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multisigKey, .multisigKey): return {
        guard case .multisigKey(let l) = lhs, case .multisigKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct Key {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var x: String = String()

    var y: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ECDSAKey {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var voteStatus: Axelar_Tss_V1beta1_VoteStatus = .unspecified

    var key: Axelar_Tss_V1beta1_QueryKeyResponse.Key {
      get {return _key ?? Axelar_Tss_V1beta1_QueryKeyResponse.Key()}
      set {_key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    var hasKey: Bool {return self._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    mutating func clearKey() {self._key = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _key: Axelar_Tss_V1beta1_QueryKeyResponse.Key? = nil
  }

  struct MultisigKey {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var threshold: Int64 = 0

    var key: [Axelar_Tss_V1beta1_QueryKeyResponse.Key] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _rotatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Axelar_Tss_V1beta1_QueryRecoveryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var partyUids: [String] = []

  var partyShareCounts: [UInt32] = []

  var threshold: UInt32 = 0

  var keygenOutput: Axelar_Tss_Tofnd_V1beta1_KeygenOutput {
    get {return _keygenOutput ?? Axelar_Tss_Tofnd_V1beta1_KeygenOutput()}
    set {_keygenOutput = newValue}
  }
  /// Returns true if `keygenOutput` has been explicitly set.
  var hasKeygenOutput: Bool {return self._keygenOutput != nil}
  /// Clears the value of `keygenOutput`. Subsequent reads from it will return its default value.
  mutating func clearKeygenOutput() {self._keygenOutput = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keygenOutput: Axelar_Tss_Tofnd_V1beta1_KeygenOutput? = nil
}

struct Axelar_Tss_V1beta1_QueryKeyShareResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var shareInfos: [Axelar_Tss_V1beta1_QueryKeyShareResponse.ShareInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ShareInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var keyID: String = String()

    var keyChain: String = String()

    var keyRole: String = String()

    var snapshotBlockNumber: Int64 = 0

    var validatorAddress: String = String()

    var numValidatorShares: Int64 = 0

    var numTotalShares: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Axelar_Tss_V1beta1_QueryDeactivatedOperatorsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var operatorAddresses: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Tss_V1beta1_QueryActiveOldKeysValidatorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keysInfo: [Axelar_Tss_V1beta1_QueryActiveOldKeysValidatorResponse.KeyInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct KeyInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var chain: String = String()

    var role: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Axelar_Tss_V1beta1_QueryActiveOldKeysResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Tss_V1beta1_QueryExternalKeyIDResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Tss_V1beta1_QueryNextKeyIDRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chain: String = String()

  var keyRole: Axelar_Tss_Exported_V1beta1_KeyRole = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Tss_V1beta1_QueryNextKeyIDResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "axelar.tss.v1beta1"

extension Axelar_Tss_V1beta1_VoteStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOTE_STATUS_UNSPECIFIED"),
    1: .same(proto: "VOTE_STATUS_NOT_FOUND"),
    2: .same(proto: "VOTE_STATUS_PENDING"),
    3: .same(proto: "VOTE_STATUS_DECIDED"),
  ]
}

extension Axelar_Tss_V1beta1_QuerySignatureResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySignatureResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "threshold_signature"),
    2: .standard(proto: "multisig_signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Axelar_Tss_V1beta1_QuerySignatureResponse.ThresholdSignature?
        var hadOneofValue = false
        if let current = self.sig {
          hadOneofValue = true
          if case .thresholdSignature(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sig = .thresholdSignature(v)
        }
      }()
      case 2: try {
        var v: Axelar_Tss_V1beta1_QuerySignatureResponse.MultisigSignature?
        var hadOneofValue = false
        if let current = self.sig {
          hadOneofValue = true
          if case .multisigSignature(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sig = .multisigSignature(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.sig {
    case .thresholdSignature?: try {
      guard case .thresholdSignature(let v)? = self.sig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .multisigSignature?: try {
      guard case .multisigSignature(let v)? = self.sig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_V1beta1_QuerySignatureResponse, rhs: Axelar_Tss_V1beta1_QuerySignatureResponse) -> Bool {
    if lhs.sig != rhs.sig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_V1beta1_QuerySignatureResponse.Signature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Axelar_Tss_V1beta1_QuerySignatureResponse.protoMessageName + ".Signature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "r"),
    2: .same(proto: "s"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.r) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.s) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.r.isEmpty {
      try visitor.visitSingularStringField(value: self.r, fieldNumber: 1)
    }
    if !self.s.isEmpty {
      try visitor.visitSingularStringField(value: self.s, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_V1beta1_QuerySignatureResponse.Signature, rhs: Axelar_Tss_V1beta1_QuerySignatureResponse.Signature) -> Bool {
    if lhs.r != rhs.r {return false}
    if lhs.s != rhs.s {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_V1beta1_QuerySignatureResponse.ThresholdSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Axelar_Tss_V1beta1_QuerySignatureResponse.protoMessageName + ".ThresholdSignature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vote_status"),
    2: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.voteStatus) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.voteStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.voteStatus, fieldNumber: 1)
    }
    if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_V1beta1_QuerySignatureResponse.ThresholdSignature, rhs: Axelar_Tss_V1beta1_QuerySignatureResponse.ThresholdSignature) -> Bool {
    if lhs.voteStatus != rhs.voteStatus {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_V1beta1_QuerySignatureResponse.MultisigSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Axelar_Tss_V1beta1_QuerySignatureResponse.protoMessageName + ".MultisigSignature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sig_status"),
    2: .same(proto: "signatures"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.sigStatus) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.signatures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sigStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.sigStatus, fieldNumber: 1)
    }
    if !self.signatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signatures, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_V1beta1_QuerySignatureResponse.MultisigSignature, rhs: Axelar_Tss_V1beta1_QuerySignatureResponse.MultisigSignature) -> Bool {
    if lhs.sigStatus != rhs.sigStatus {return false}
    if lhs.signatures != rhs.signatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_V1beta1_QueryKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryKeyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ecdsa_key"),
    2: .standard(proto: "multisig_key"),
    3: .same(proto: "role"),
    4: .standard(proto: "rotated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Axelar_Tss_V1beta1_QueryKeyResponse.ECDSAKey?
        var hadOneofValue = false
        if let current = self.publicKey {
          hadOneofValue = true
          if case .ecdsaKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.publicKey = .ecdsaKey(v)
        }
      }()
      case 2: try {
        var v: Axelar_Tss_V1beta1_QueryKeyResponse.MultisigKey?
        var hadOneofValue = false
        if let current = self.publicKey {
          hadOneofValue = true
          if case .multisigKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.publicKey = .multisigKey(v)
        }
      }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._rotatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.publicKey {
    case .ecdsaKey?: try {
      guard case .ecdsaKey(let v)? = self.publicKey else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .multisigKey?: try {
      guard case .multisigKey(let v)? = self.publicKey else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if self.role != .unspecified {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 3)
    }
    if let v = self._rotatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_V1beta1_QueryKeyResponse, rhs: Axelar_Tss_V1beta1_QueryKeyResponse) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.role != rhs.role {return false}
    if lhs._rotatedAt != rhs._rotatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_V1beta1_QueryKeyResponse.Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Axelar_Tss_V1beta1_QueryKeyResponse.protoMessageName + ".Key"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.y) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.x.isEmpty {
      try visitor.visitSingularStringField(value: self.x, fieldNumber: 1)
    }
    if !self.y.isEmpty {
      try visitor.visitSingularStringField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_V1beta1_QueryKeyResponse.Key, rhs: Axelar_Tss_V1beta1_QueryKeyResponse.Key) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_V1beta1_QueryKeyResponse.ECDSAKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Axelar_Tss_V1beta1_QueryKeyResponse.protoMessageName + ".ECDSAKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vote_status"),
    2: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.voteStatus) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.voteStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.voteStatus, fieldNumber: 1)
    }
    if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_V1beta1_QueryKeyResponse.ECDSAKey, rhs: Axelar_Tss_V1beta1_QueryKeyResponse.ECDSAKey) -> Bool {
    if lhs.voteStatus != rhs.voteStatus {return false}
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_V1beta1_QueryKeyResponse.MultisigKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Axelar_Tss_V1beta1_QueryKeyResponse.protoMessageName + ".MultisigKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threshold"),
    2: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.threshold) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.threshold != 0 {
      try visitor.visitSingularInt64Field(value: self.threshold, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.key, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_V1beta1_QueryKeyResponse.MultisigKey, rhs: Axelar_Tss_V1beta1_QueryKeyResponse.MultisigKey) -> Bool {
    if lhs.threshold != rhs.threshold {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_V1beta1_QueryRecoveryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRecoveryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "party_uids"),
    2: .standard(proto: "party_share_counts"),
    3: .same(proto: "threshold"),
    4: .standard(proto: "keygen_output"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.partyUids) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.partyShareCounts) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.threshold) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._keygenOutput) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.partyUids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.partyUids, fieldNumber: 1)
    }
    if !self.partyShareCounts.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.partyShareCounts, fieldNumber: 2)
    }
    if self.threshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.threshold, fieldNumber: 3)
    }
    if let v = self._keygenOutput {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_V1beta1_QueryRecoveryResponse, rhs: Axelar_Tss_V1beta1_QueryRecoveryResponse) -> Bool {
    if lhs.partyUids != rhs.partyUids {return false}
    if lhs.partyShareCounts != rhs.partyShareCounts {return false}
    if lhs.threshold != rhs.threshold {return false}
    if lhs._keygenOutput != rhs._keygenOutput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_V1beta1_QueryKeyShareResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryKeyShareResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "share_infos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.shareInfos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.shareInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shareInfos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_V1beta1_QueryKeyShareResponse, rhs: Axelar_Tss_V1beta1_QueryKeyShareResponse) -> Bool {
    if lhs.shareInfos != rhs.shareInfos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_V1beta1_QueryKeyShareResponse.ShareInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Axelar_Tss_V1beta1_QueryKeyShareResponse.protoMessageName + ".ShareInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_id"),
    2: .standard(proto: "key_chain"),
    3: .standard(proto: "key_role"),
    4: .standard(proto: "snapshot_block_number"),
    5: .standard(proto: "validator_address"),
    6: .standard(proto: "num_validator_shares"),
    7: .standard(proto: "num_total_shares"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyChain) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.keyRole) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.snapshotBlockNumber) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.validatorAddress) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.numValidatorShares) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.numTotalShares) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 1)
    }
    if !self.keyChain.isEmpty {
      try visitor.visitSingularStringField(value: self.keyChain, fieldNumber: 2)
    }
    if !self.keyRole.isEmpty {
      try visitor.visitSingularStringField(value: self.keyRole, fieldNumber: 3)
    }
    if self.snapshotBlockNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.snapshotBlockNumber, fieldNumber: 4)
    }
    if !self.validatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddress, fieldNumber: 5)
    }
    if self.numValidatorShares != 0 {
      try visitor.visitSingularInt64Field(value: self.numValidatorShares, fieldNumber: 6)
    }
    if self.numTotalShares != 0 {
      try visitor.visitSingularInt64Field(value: self.numTotalShares, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_V1beta1_QueryKeyShareResponse.ShareInfo, rhs: Axelar_Tss_V1beta1_QueryKeyShareResponse.ShareInfo) -> Bool {
    if lhs.keyID != rhs.keyID {return false}
    if lhs.keyChain != rhs.keyChain {return false}
    if lhs.keyRole != rhs.keyRole {return false}
    if lhs.snapshotBlockNumber != rhs.snapshotBlockNumber {return false}
    if lhs.validatorAddress != rhs.validatorAddress {return false}
    if lhs.numValidatorShares != rhs.numValidatorShares {return false}
    if lhs.numTotalShares != rhs.numTotalShares {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_V1beta1_QueryDeactivatedOperatorsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryDeactivatedOperatorsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "operator_addresses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.operatorAddresses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operatorAddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.operatorAddresses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_V1beta1_QueryDeactivatedOperatorsResponse, rhs: Axelar_Tss_V1beta1_QueryDeactivatedOperatorsResponse) -> Bool {
    if lhs.operatorAddresses != rhs.operatorAddresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_V1beta1_QueryActiveOldKeysValidatorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryActiveOldKeysValidatorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "keys_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keysInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keysInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keysInfo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_V1beta1_QueryActiveOldKeysValidatorResponse, rhs: Axelar_Tss_V1beta1_QueryActiveOldKeysValidatorResponse) -> Bool {
    if lhs.keysInfo != rhs.keysInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_V1beta1_QueryActiveOldKeysValidatorResponse.KeyInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Axelar_Tss_V1beta1_QueryActiveOldKeysValidatorResponse.protoMessageName + ".KeyInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "chain"),
    3: .same(proto: "role"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.role) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 2)
    }
    if self.role != 0 {
      try visitor.visitSingularInt32Field(value: self.role, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_V1beta1_QueryActiveOldKeysValidatorResponse.KeyInfo, rhs: Axelar_Tss_V1beta1_QueryActiveOldKeysValidatorResponse.KeyInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.chain != rhs.chain {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_V1beta1_QueryActiveOldKeysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryActiveOldKeysResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.keyIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keyIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_V1beta1_QueryActiveOldKeysResponse, rhs: Axelar_Tss_V1beta1_QueryActiveOldKeysResponse) -> Bool {
    if lhs.keyIds != rhs.keyIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_V1beta1_QueryExternalKeyIDResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryExternalKeyIDResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.keyIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keyIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_V1beta1_QueryExternalKeyIDResponse, rhs: Axelar_Tss_V1beta1_QueryExternalKeyIDResponse) -> Bool {
    if lhs.keyIds != rhs.keyIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_V1beta1_QueryNextKeyIDRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryNextKeyIDRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .standard(proto: "key_role"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chain) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.keyRole) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    if self.keyRole != .unspecified {
      try visitor.visitSingularEnumField(value: self.keyRole, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_V1beta1_QueryNextKeyIDRequest, rhs: Axelar_Tss_V1beta1_QueryNextKeyIDRequest) -> Bool {
    if lhs.chain != rhs.chain {return false}
    if lhs.keyRole != rhs.keyRole {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_V1beta1_QueryNextKeyIDResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryNextKeyIDResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_V1beta1_QueryNextKeyIDResponse, rhs: Axelar_Tss_V1beta1_QueryNextKeyIDResponse) -> Bool {
    if lhs.keyID != rhs.keyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
