// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ixo/bonds/bonds.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// FunctionParam is a key-value pair used for specifying a specific bond parameter.
struct Bonds_FunctionParam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var param: String = String()

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BondDetails contains details about the current state of a given bond.
struct Bonds_BondDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var spotPrice: [Cosmos_Base_V1beta1_DecCoin] = []

  var supply: Cosmos_Base_V1beta1_Coin {
    get {return _supply ?? Cosmos_Base_V1beta1_Coin()}
    set {_supply = newValue}
  }
  /// Returns true if `supply` has been explicitly set.
  var hasSupply: Bool {return self._supply != nil}
  /// Clears the value of `supply`. Subsequent reads from it will return its default value.
  mutating func clearSupply() {self._supply = nil}

  var reserve: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _supply: Cosmos_Base_V1beta1_Coin? = nil
}

/// Bond defines a token bonding curve type with all of its parameters.
struct Bonds_Bond {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var creatorDid: String {
    get {return _storage._creatorDid}
    set {_uniqueStorage()._creatorDid = newValue}
  }

  var controllerDid: String {
    get {return _storage._controllerDid}
    set {_uniqueStorage()._controllerDid = newValue}
  }

  var functionType: String {
    get {return _storage._functionType}
    set {_uniqueStorage()._functionType = newValue}
  }

  var functionParameters: [Bonds_FunctionParam] {
    get {return _storage._functionParameters}
    set {_uniqueStorage()._functionParameters = newValue}
  }

  var reserveTokens: [String] {
    get {return _storage._reserveTokens}
    set {_uniqueStorage()._reserveTokens = newValue}
  }

  var txFeePercentage: String {
    get {return _storage._txFeePercentage}
    set {_uniqueStorage()._txFeePercentage = newValue}
  }

  var exitFeePercentage: String {
    get {return _storage._exitFeePercentage}
    set {_uniqueStorage()._exitFeePercentage = newValue}
  }

  var feeAddress: String {
    get {return _storage._feeAddress}
    set {_uniqueStorage()._feeAddress = newValue}
  }

  var reserveWithdrawalAddress: String {
    get {return _storage._reserveWithdrawalAddress}
    set {_uniqueStorage()._reserveWithdrawalAddress = newValue}
  }

  var maxSupply: Cosmos_Base_V1beta1_Coin {
    get {return _storage._maxSupply ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._maxSupply = newValue}
  }
  /// Returns true if `maxSupply` has been explicitly set.
  var hasMaxSupply: Bool {return _storage._maxSupply != nil}
  /// Clears the value of `maxSupply`. Subsequent reads from it will return its default value.
  mutating func clearMaxSupply() {_uniqueStorage()._maxSupply = nil}

  var orderQuantityLimits: [Cosmos_Base_V1beta1_Coin] {
    get {return _storage._orderQuantityLimits}
    set {_uniqueStorage()._orderQuantityLimits = newValue}
  }

  var sanityRate: String {
    get {return _storage._sanityRate}
    set {_uniqueStorage()._sanityRate = newValue}
  }

  var sanityMarginPercentage: String {
    get {return _storage._sanityMarginPercentage}
    set {_uniqueStorage()._sanityMarginPercentage = newValue}
  }

  var currentSupply: Cosmos_Base_V1beta1_Coin {
    get {return _storage._currentSupply ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._currentSupply = newValue}
  }
  /// Returns true if `currentSupply` has been explicitly set.
  var hasCurrentSupply: Bool {return _storage._currentSupply != nil}
  /// Clears the value of `currentSupply`. Subsequent reads from it will return its default value.
  mutating func clearCurrentSupply() {_uniqueStorage()._currentSupply = nil}

  var currentReserve: [Cosmos_Base_V1beta1_Coin] {
    get {return _storage._currentReserve}
    set {_uniqueStorage()._currentReserve = newValue}
  }

  var availableReserve: [Cosmos_Base_V1beta1_Coin] {
    get {return _storage._availableReserve}
    set {_uniqueStorage()._availableReserve = newValue}
  }

  var currentOutcomePaymentReserve: [Cosmos_Base_V1beta1_Coin] {
    get {return _storage._currentOutcomePaymentReserve}
    set {_uniqueStorage()._currentOutcomePaymentReserve = newValue}
  }

  var allowSells: Bool {
    get {return _storage._allowSells}
    set {_uniqueStorage()._allowSells = newValue}
  }

  var allowReserveWithdrawals: Bool {
    get {return _storage._allowReserveWithdrawals}
    set {_uniqueStorage()._allowReserveWithdrawals = newValue}
  }

  var alphaBond: Bool {
    get {return _storage._alphaBond}
    set {_uniqueStorage()._alphaBond = newValue}
  }

  var batchBlocks: String {
    get {return _storage._batchBlocks}
    set {_uniqueStorage()._batchBlocks = newValue}
  }

  var outcomePayment: String {
    get {return _storage._outcomePayment}
    set {_uniqueStorage()._outcomePayment = newValue}
  }

  var state: String {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var bondDid: String {
    get {return _storage._bondDid}
    set {_uniqueStorage()._bondDid = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// BaseOrder defines a base order type. It contains all the necessary fields for specifying
/// the general details about a buy, sell, or swap order.
struct Bonds_BaseOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountDid: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var cancelled: Bool = false

  var cancelReason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

/// BuyOrder defines a type for submitting a buy order on a bond, together with the maximum
/// amount of reserve tokens the buyer is willing to pay.
struct Bonds_BuyOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseOrder: Bonds_BaseOrder {
    get {return _baseOrder ?? Bonds_BaseOrder()}
    set {_baseOrder = newValue}
  }
  /// Returns true if `baseOrder` has been explicitly set.
  var hasBaseOrder: Bool {return self._baseOrder != nil}
  /// Clears the value of `baseOrder`. Subsequent reads from it will return its default value.
  mutating func clearBaseOrder() {self._baseOrder = nil}

  var maxPrices: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseOrder: Bonds_BaseOrder? = nil
}

/// SellOrder defines a type for submitting a sell order on a bond.
struct Bonds_SellOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseOrder: Bonds_BaseOrder {
    get {return _baseOrder ?? Bonds_BaseOrder()}
    set {_baseOrder = newValue}
  }
  /// Returns true if `baseOrder` has been explicitly set.
  var hasBaseOrder: Bool {return self._baseOrder != nil}
  /// Clears the value of `baseOrder`. Subsequent reads from it will return its default value.
  mutating func clearBaseOrder() {self._baseOrder = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseOrder: Bonds_BaseOrder? = nil
}

/// SwapOrder defines a type for submitting a swap order between two tokens on a bond.
struct Bonds_SwapOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseOrder: Bonds_BaseOrder {
    get {return _baseOrder ?? Bonds_BaseOrder()}
    set {_baseOrder = newValue}
  }
  /// Returns true if `baseOrder` has been explicitly set.
  var hasBaseOrder: Bool {return self._baseOrder != nil}
  /// Clears the value of `baseOrder`. Subsequent reads from it will return its default value.
  mutating func clearBaseOrder() {self._baseOrder = nil}

  var toToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseOrder: Bonds_BaseOrder? = nil
}

/// Batch holds a collection of outstanding buy, sell, and swap orders on a particular bond.
struct Bonds_Batch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var blocksRemaining: String = String()

  var nextPublicAlpha: String = String()

  var totalBuyAmount: Cosmos_Base_V1beta1_Coin {
    get {return _totalBuyAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_totalBuyAmount = newValue}
  }
  /// Returns true if `totalBuyAmount` has been explicitly set.
  var hasTotalBuyAmount: Bool {return self._totalBuyAmount != nil}
  /// Clears the value of `totalBuyAmount`. Subsequent reads from it will return its default value.
  mutating func clearTotalBuyAmount() {self._totalBuyAmount = nil}

  var totalSellAmount: Cosmos_Base_V1beta1_Coin {
    get {return _totalSellAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_totalSellAmount = newValue}
  }
  /// Returns true if `totalSellAmount` has been explicitly set.
  var hasTotalSellAmount: Bool {return self._totalSellAmount != nil}
  /// Clears the value of `totalSellAmount`. Subsequent reads from it will return its default value.
  mutating func clearTotalSellAmount() {self._totalSellAmount = nil}

  var buyPrices: [Cosmos_Base_V1beta1_DecCoin] = []

  var sellPrices: [Cosmos_Base_V1beta1_DecCoin] = []

  var buys: [Bonds_BuyOrder] = []

  var sells: [Bonds_SellOrder] = []

  var swaps: [Bonds_SwapOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _totalBuyAmount: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _totalSellAmount: Cosmos_Base_V1beta1_Coin? = nil
}

/// Params defines the parameters for the bonds module.
struct Bonds_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reservedBondTokens: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bonds"

extension Bonds_FunctionParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FunctionParam"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "param"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.param) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.param.isEmpty {
      try visitor.visitSingularStringField(value: self.param, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_FunctionParam, rhs: Bonds_FunctionParam) -> Bool {
    if lhs.param != rhs.param {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_BondDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BondDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
    2: .standard(proto: "spot_price"),
    3: .same(proto: "supply"),
    4: .same(proto: "reserve"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.spotPrice) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._supply) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.reserve) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    if !self.spotPrice.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spotPrice, fieldNumber: 2)
    }
    if let v = self._supply {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.reserve.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reserve, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_BondDetails, rhs: Bonds_BondDetails) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.spotPrice != rhs.spotPrice {return false}
    if lhs._supply != rhs._supply {return false}
    if lhs.reserve != rhs.reserve {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_Bond: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Bond"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .standard(proto: "creator_did"),
    5: .standard(proto: "controller_did"),
    6: .standard(proto: "function_type"),
    7: .standard(proto: "function_parameters"),
    8: .standard(proto: "reserve_tokens"),
    9: .standard(proto: "tx_fee_percentage"),
    10: .standard(proto: "exit_fee_percentage"),
    11: .standard(proto: "fee_address"),
    12: .standard(proto: "reserve_withdrawal_address"),
    13: .standard(proto: "max_supply"),
    14: .standard(proto: "order_quantity_limits"),
    15: .standard(proto: "sanity_rate"),
    16: .standard(proto: "sanity_margin_percentage"),
    17: .standard(proto: "current_supply"),
    18: .standard(proto: "current_reserve"),
    19: .standard(proto: "available_reserve"),
    20: .standard(proto: "current_outcome_payment_reserve"),
    21: .standard(proto: "allow_sells"),
    22: .standard(proto: "allow_reserve_withdrawals"),
    23: .standard(proto: "alpha_bond"),
    24: .standard(proto: "batch_blocks"),
    25: .standard(proto: "outcome_payment"),
    26: .same(proto: "state"),
    27: .standard(proto: "bond_did"),
  ]

  fileprivate class _StorageClass {
    var _token: String = String()
    var _name: String = String()
    var _description_p: String = String()
    var _creatorDid: String = String()
    var _controllerDid: String = String()
    var _functionType: String = String()
    var _functionParameters: [Bonds_FunctionParam] = []
    var _reserveTokens: [String] = []
    var _txFeePercentage: String = String()
    var _exitFeePercentage: String = String()
    var _feeAddress: String = String()
    var _reserveWithdrawalAddress: String = String()
    var _maxSupply: Cosmos_Base_V1beta1_Coin? = nil
    var _orderQuantityLimits: [Cosmos_Base_V1beta1_Coin] = []
    var _sanityRate: String = String()
    var _sanityMarginPercentage: String = String()
    var _currentSupply: Cosmos_Base_V1beta1_Coin? = nil
    var _currentReserve: [Cosmos_Base_V1beta1_Coin] = []
    var _availableReserve: [Cosmos_Base_V1beta1_Coin] = []
    var _currentOutcomePaymentReserve: [Cosmos_Base_V1beta1_Coin] = []
    var _allowSells: Bool = false
    var _allowReserveWithdrawals: Bool = false
    var _alphaBond: Bool = false
    var _batchBlocks: String = String()
    var _outcomePayment: String = String()
    var _state: String = String()
    var _bondDid: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _token = source._token
      _name = source._name
      _description_p = source._description_p
      _creatorDid = source._creatorDid
      _controllerDid = source._controllerDid
      _functionType = source._functionType
      _functionParameters = source._functionParameters
      _reserveTokens = source._reserveTokens
      _txFeePercentage = source._txFeePercentage
      _exitFeePercentage = source._exitFeePercentage
      _feeAddress = source._feeAddress
      _reserveWithdrawalAddress = source._reserveWithdrawalAddress
      _maxSupply = source._maxSupply
      _orderQuantityLimits = source._orderQuantityLimits
      _sanityRate = source._sanityRate
      _sanityMarginPercentage = source._sanityMarginPercentage
      _currentSupply = source._currentSupply
      _currentReserve = source._currentReserve
      _availableReserve = source._availableReserve
      _currentOutcomePaymentReserve = source._currentOutcomePaymentReserve
      _allowSells = source._allowSells
      _allowReserveWithdrawals = source._allowReserveWithdrawals
      _alphaBond = source._alphaBond
      _batchBlocks = source._batchBlocks
      _outcomePayment = source._outcomePayment
      _state = source._state
      _bondDid = source._bondDid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._token) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._creatorDid) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._controllerDid) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._functionType) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._functionParameters) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._reserveTokens) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._txFeePercentage) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._exitFeePercentage) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._feeAddress) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._reserveWithdrawalAddress) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._maxSupply) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._orderQuantityLimits) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._sanityRate) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._sanityMarginPercentage) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._currentSupply) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._currentReserve) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._availableReserve) }()
        case 20: try { try decoder.decodeRepeatedMessageField(value: &_storage._currentOutcomePaymentReserve) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._allowSells) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._allowReserveWithdrawals) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._alphaBond) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._batchBlocks) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._outcomePayment) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._state) }()
        case 27: try { try decoder.decodeSingularStringField(value: &_storage._bondDid) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      if !_storage._creatorDid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._creatorDid, fieldNumber: 4)
      }
      if !_storage._controllerDid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._controllerDid, fieldNumber: 5)
      }
      if !_storage._functionType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._functionType, fieldNumber: 6)
      }
      if !_storage._functionParameters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._functionParameters, fieldNumber: 7)
      }
      if !_storage._reserveTokens.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._reserveTokens, fieldNumber: 8)
      }
      if !_storage._txFeePercentage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._txFeePercentage, fieldNumber: 9)
      }
      if !_storage._exitFeePercentage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exitFeePercentage, fieldNumber: 10)
      }
      if !_storage._feeAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._feeAddress, fieldNumber: 11)
      }
      if !_storage._reserveWithdrawalAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reserveWithdrawalAddress, fieldNumber: 12)
      }
      if let v = _storage._maxSupply {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if !_storage._orderQuantityLimits.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._orderQuantityLimits, fieldNumber: 14)
      }
      if !_storage._sanityRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sanityRate, fieldNumber: 15)
      }
      if !_storage._sanityMarginPercentage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sanityMarginPercentage, fieldNumber: 16)
      }
      if let v = _storage._currentSupply {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if !_storage._currentReserve.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._currentReserve, fieldNumber: 18)
      }
      if !_storage._availableReserve.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._availableReserve, fieldNumber: 19)
      }
      if !_storage._currentOutcomePaymentReserve.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._currentOutcomePaymentReserve, fieldNumber: 20)
      }
      if _storage._allowSells != false {
        try visitor.visitSingularBoolField(value: _storage._allowSells, fieldNumber: 21)
      }
      if _storage._allowReserveWithdrawals != false {
        try visitor.visitSingularBoolField(value: _storage._allowReserveWithdrawals, fieldNumber: 22)
      }
      if _storage._alphaBond != false {
        try visitor.visitSingularBoolField(value: _storage._alphaBond, fieldNumber: 23)
      }
      if !_storage._batchBlocks.isEmpty {
        try visitor.visitSingularStringField(value: _storage._batchBlocks, fieldNumber: 24)
      }
      if !_storage._outcomePayment.isEmpty {
        try visitor.visitSingularStringField(value: _storage._outcomePayment, fieldNumber: 25)
      }
      if !_storage._state.isEmpty {
        try visitor.visitSingularStringField(value: _storage._state, fieldNumber: 26)
      }
      if !_storage._bondDid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bondDid, fieldNumber: 27)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_Bond, rhs: Bonds_Bond) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._token != rhs_storage._token {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._creatorDid != rhs_storage._creatorDid {return false}
        if _storage._controllerDid != rhs_storage._controllerDid {return false}
        if _storage._functionType != rhs_storage._functionType {return false}
        if _storage._functionParameters != rhs_storage._functionParameters {return false}
        if _storage._reserveTokens != rhs_storage._reserveTokens {return false}
        if _storage._txFeePercentage != rhs_storage._txFeePercentage {return false}
        if _storage._exitFeePercentage != rhs_storage._exitFeePercentage {return false}
        if _storage._feeAddress != rhs_storage._feeAddress {return false}
        if _storage._reserveWithdrawalAddress != rhs_storage._reserveWithdrawalAddress {return false}
        if _storage._maxSupply != rhs_storage._maxSupply {return false}
        if _storage._orderQuantityLimits != rhs_storage._orderQuantityLimits {return false}
        if _storage._sanityRate != rhs_storage._sanityRate {return false}
        if _storage._sanityMarginPercentage != rhs_storage._sanityMarginPercentage {return false}
        if _storage._currentSupply != rhs_storage._currentSupply {return false}
        if _storage._currentReserve != rhs_storage._currentReserve {return false}
        if _storage._availableReserve != rhs_storage._availableReserve {return false}
        if _storage._currentOutcomePaymentReserve != rhs_storage._currentOutcomePaymentReserve {return false}
        if _storage._allowSells != rhs_storage._allowSells {return false}
        if _storage._allowReserveWithdrawals != rhs_storage._allowReserveWithdrawals {return false}
        if _storage._alphaBond != rhs_storage._alphaBond {return false}
        if _storage._batchBlocks != rhs_storage._batchBlocks {return false}
        if _storage._outcomePayment != rhs_storage._outcomePayment {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._bondDid != rhs_storage._bondDid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_BaseOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BaseOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_did"),
    2: .same(proto: "amount"),
    3: .same(proto: "cancelled"),
    4: .standard(proto: "cancel_reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountDid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.cancelled) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cancelReason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountDid.isEmpty {
      try visitor.visitSingularStringField(value: self.accountDid, fieldNumber: 1)
    }
    if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.cancelled != false {
      try visitor.visitSingularBoolField(value: self.cancelled, fieldNumber: 3)
    }
    if !self.cancelReason.isEmpty {
      try visitor.visitSingularStringField(value: self.cancelReason, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_BaseOrder, rhs: Bonds_BaseOrder) -> Bool {
    if lhs.accountDid != rhs.accountDid {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.cancelled != rhs.cancelled {return false}
    if lhs.cancelReason != rhs.cancelReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_BuyOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BuyOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_order"),
    2: .standard(proto: "max_prices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseOrder) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.maxPrices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._baseOrder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.maxPrices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.maxPrices, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_BuyOrder, rhs: Bonds_BuyOrder) -> Bool {
    if lhs._baseOrder != rhs._baseOrder {return false}
    if lhs.maxPrices != rhs.maxPrices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_SellOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SellOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseOrder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._baseOrder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_SellOrder, rhs: Bonds_SellOrder) -> Bool {
    if lhs._baseOrder != rhs._baseOrder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_SwapOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SwapOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_order"),
    2: .standard(proto: "to_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseOrder) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.toToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._baseOrder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.toToken.isEmpty {
      try visitor.visitSingularStringField(value: self.toToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_SwapOrder, rhs: Bonds_SwapOrder) -> Bool {
    if lhs._baseOrder != rhs._baseOrder {return false}
    if lhs.toToken != rhs.toToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_Batch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Batch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
    2: .standard(proto: "blocks_remaining"),
    3: .standard(proto: "next_public_alpha"),
    4: .standard(proto: "total_buy_amount"),
    5: .standard(proto: "total_sell_amount"),
    6: .standard(proto: "buy_prices"),
    7: .standard(proto: "sell_prices"),
    8: .same(proto: "buys"),
    9: .same(proto: "sells"),
    10: .same(proto: "swaps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blocksRemaining) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nextPublicAlpha) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._totalBuyAmount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._totalSellAmount) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.buyPrices) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.sellPrices) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.buys) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.sells) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.swaps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    if !self.blocksRemaining.isEmpty {
      try visitor.visitSingularStringField(value: self.blocksRemaining, fieldNumber: 2)
    }
    if !self.nextPublicAlpha.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPublicAlpha, fieldNumber: 3)
    }
    if let v = self._totalBuyAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._totalSellAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.buyPrices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buyPrices, fieldNumber: 6)
    }
    if !self.sellPrices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sellPrices, fieldNumber: 7)
    }
    if !self.buys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buys, fieldNumber: 8)
    }
    if !self.sells.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sells, fieldNumber: 9)
    }
    if !self.swaps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.swaps, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_Batch, rhs: Bonds_Batch) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.blocksRemaining != rhs.blocksRemaining {return false}
    if lhs.nextPublicAlpha != rhs.nextPublicAlpha {return false}
    if lhs._totalBuyAmount != rhs._totalBuyAmount {return false}
    if lhs._totalSellAmount != rhs._totalSellAmount {return false}
    if lhs.buyPrices != rhs.buyPrices {return false}
    if lhs.sellPrices != rhs.sellPrices {return false}
    if lhs.buys != rhs.buys {return false}
    if lhs.sells != rhs.sells {return false}
    if lhs.swaps != rhs.swaps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reserved_bond_tokens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.reservedBondTokens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reservedBondTokens.isEmpty {
      try visitor.visitRepeatedStringField(value: self.reservedBondTokens, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_Params, rhs: Bonds_Params) -> Bool {
    if lhs.reservedBondTokens != rhs.reservedBondTokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
