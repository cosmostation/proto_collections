// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: confio/poe/v1beta1/genesis.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// GenesisState - initial state of module
struct Confio_Poe_V1beta1_GenesisState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// params defines all the parameter of the module
  var params: Confio_Poe_V1beta1_Params {
    get {return _params ?? Confio_Poe_V1beta1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  /// SetupMode defines which scenario to apply on a genesis import.
  /// Either it is a fresh chain that needs PoE contracts bootstrapped or
  /// the module state has to be restored from a previous state dump.
  var setupMode: Confio_Poe_V1beta1_GenesisState.OneOf_SetupMode? = nil

  /// SeedContracts stores and instantiates the Proof of Engagement
  /// contracts on the chain.
  var seedContracts: Confio_Poe_V1beta1_SeedContracts {
    get {
      if case .seedContracts(let v)? = setupMode {return v}
      return Confio_Poe_V1beta1_SeedContracts()
    }
    set {setupMode = .seedContracts(newValue)}
  }

  /// ImportDump restores the state from an exported state genesis
  var importDump: Confio_Poe_V1beta1_ImportDump {
    get {
      if case .importDump(let v)? = setupMode {return v}
      return Confio_Poe_V1beta1_ImportDump()
    }
    set {setupMode = .importDump(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// SetupMode defines which scenario to apply on a genesis import.
  /// Either it is a fresh chain that needs PoE contracts bootstrapped or
  /// the module state has to be restored from a previous state dump.
  enum OneOf_SetupMode: Equatable {
    /// SeedContracts stores and instantiates the Proof of Engagement
    /// contracts on the chain.
    case seedContracts(Confio_Poe_V1beta1_SeedContracts)
    /// ImportDump restores the state from an exported state genesis
    case importDump(Confio_Poe_V1beta1_ImportDump)

  #if !swift(>=4.1)
    static func ==(lhs: Confio_Poe_V1beta1_GenesisState.OneOf_SetupMode, rhs: Confio_Poe_V1beta1_GenesisState.OneOf_SetupMode) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.seedContracts, .seedContracts): return {
        guard case .seedContracts(let l) = lhs, case .seedContracts(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.importDump, .importDump): return {
        guard case .importDump(let l) = lhs, case .importDump(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _params: Confio_Poe_V1beta1_Params? = nil
}

/// ImportDump has all module data for non seed mode.
struct Confio_Poe_V1beta1_ImportDump {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contracts PoE contract addresses and types
  var contracts: [Confio_Poe_V1beta1_PoEContract] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SeedContracts contains the contract configuration and group members to setup
/// all PoE contracts on chain.
struct Confio_Poe_V1beta1_SeedContracts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// GenTxs defines the genesis transactions to create a validator.
  var genTxs: [Data] {
    get {return _storage._genTxs}
    set {_uniqueStorage()._genTxs = newValue}
  }

  /// BootstrapAccountAddress single address that is set as bootstrap-account for
  /// the PoE contracts in seed mode.
  var bootstrapAccountAddress: String {
    get {return _storage._bootstrapAccountAddress}
    set {_uniqueStorage()._bootstrapAccountAddress = newValue}
  }

  /// Engagement weighted members of the engagement group. Validators should be
  /// in here.
  var engagement: [Confio_Poe_V1beta1_TG4Member] {
    get {return _storage._engagement}
    set {_uniqueStorage()._engagement = newValue}
  }

  var stakeContractConfig: Confio_Poe_V1beta1_StakeContractConfig {
    get {return _storage._stakeContractConfig ?? Confio_Poe_V1beta1_StakeContractConfig()}
    set {_uniqueStorage()._stakeContractConfig = newValue}
  }
  /// Returns true if `stakeContractConfig` has been explicitly set.
  var hasStakeContractConfig: Bool {return _storage._stakeContractConfig != nil}
  /// Clears the value of `stakeContractConfig`. Subsequent reads from it will return its default value.
  mutating func clearStakeContractConfig() {_uniqueStorage()._stakeContractConfig = nil}

  var valsetContractConfig: Confio_Poe_V1beta1_ValsetContractConfig {
    get {return _storage._valsetContractConfig ?? Confio_Poe_V1beta1_ValsetContractConfig()}
    set {_uniqueStorage()._valsetContractConfig = newValue}
  }
  /// Returns true if `valsetContractConfig` has been explicitly set.
  var hasValsetContractConfig: Bool {return _storage._valsetContractConfig != nil}
  /// Clears the value of `valsetContractConfig`. Subsequent reads from it will return its default value.
  mutating func clearValsetContractConfig() {_uniqueStorage()._valsetContractConfig = nil}

  var engagementContractConfig: Confio_Poe_V1beta1_EngagementContractConfig {
    get {return _storage._engagementContractConfig ?? Confio_Poe_V1beta1_EngagementContractConfig()}
    set {_uniqueStorage()._engagementContractConfig = newValue}
  }
  /// Returns true if `engagementContractConfig` has been explicitly set.
  var hasEngagementContractConfig: Bool {return _storage._engagementContractConfig != nil}
  /// Clears the value of `engagementContractConfig`. Subsequent reads from it will return its default value.
  mutating func clearEngagementContractConfig() {_uniqueStorage()._engagementContractConfig = nil}

  /// BondDenom defines the bondable coin denomination.
  var bondDenom: String {
    get {return _storage._bondDenom}
    set {_uniqueStorage()._bondDenom = newValue}
  }

  var oversightCommitteeContractConfig: Confio_Poe_V1beta1_OversightCommitteeContractConfig {
    get {return _storage._oversightCommitteeContractConfig ?? Confio_Poe_V1beta1_OversightCommitteeContractConfig()}
    set {_uniqueStorage()._oversightCommitteeContractConfig = newValue}
  }
  /// Returns true if `oversightCommitteeContractConfig` has been explicitly set.
  var hasOversightCommitteeContractConfig: Bool {return _storage._oversightCommitteeContractConfig != nil}
  /// Clears the value of `oversightCommitteeContractConfig`. Subsequent reads from it will return its default value.
  mutating func clearOversightCommitteeContractConfig() {_uniqueStorage()._oversightCommitteeContractConfig = nil}

  var communityPoolContractConfig: Confio_Poe_V1beta1_CommunityPoolContractConfig {
    get {return _storage._communityPoolContractConfig ?? Confio_Poe_V1beta1_CommunityPoolContractConfig()}
    set {_uniqueStorage()._communityPoolContractConfig = newValue}
  }
  /// Returns true if `communityPoolContractConfig` has been explicitly set.
  var hasCommunityPoolContractConfig: Bool {return _storage._communityPoolContractConfig != nil}
  /// Clears the value of `communityPoolContractConfig`. Subsequent reads from it will return its default value.
  mutating func clearCommunityPoolContractConfig() {_uniqueStorage()._communityPoolContractConfig = nil}

  var validatorVotingContractConfig: Confio_Poe_V1beta1_ValidatorVotingContractConfig {
    get {return _storage._validatorVotingContractConfig ?? Confio_Poe_V1beta1_ValidatorVotingContractConfig()}
    set {_uniqueStorage()._validatorVotingContractConfig = newValue}
  }
  /// Returns true if `validatorVotingContractConfig` has been explicitly set.
  var hasValidatorVotingContractConfig: Bool {return _storage._validatorVotingContractConfig != nil}
  /// Clears the value of `validatorVotingContractConfig`. Subsequent reads from it will return its default value.
  mutating func clearValidatorVotingContractConfig() {_uniqueStorage()._validatorVotingContractConfig = nil}

  var oversightCommunityMembers: [String] {
    get {return _storage._oversightCommunityMembers}
    set {_uniqueStorage()._oversightCommunityMembers = newValue}
  }

  var arbiterPoolMembers: [String] {
    get {return _storage._arbiterPoolMembers}
    set {_uniqueStorage()._arbiterPoolMembers = newValue}
  }

  var arbiterPoolContractConfig: Confio_Poe_V1beta1_ArbiterPoolContractConfig {
    get {return _storage._arbiterPoolContractConfig ?? Confio_Poe_V1beta1_ArbiterPoolContractConfig()}
    set {_uniqueStorage()._arbiterPoolContractConfig = newValue}
  }
  /// Returns true if `arbiterPoolContractConfig` has been explicitly set.
  var hasArbiterPoolContractConfig: Bool {return _storage._arbiterPoolContractConfig != nil}
  /// Clears the value of `arbiterPoolContractConfig`. Subsequent reads from it will return its default value.
  mutating func clearArbiterPoolContractConfig() {_uniqueStorage()._arbiterPoolContractConfig = nil}

  var mixerContractConfig: Confio_Poe_V1beta1_MixerContractConfig {
    get {return _storage._mixerContractConfig ?? Confio_Poe_V1beta1_MixerContractConfig()}
    set {_uniqueStorage()._mixerContractConfig = newValue}
  }
  /// Returns true if `mixerContractConfig` has been explicitly set.
  var hasMixerContractConfig: Bool {return _storage._mixerContractConfig != nil}
  /// Clears the value of `mixerContractConfig`. Subsequent reads from it will return its default value.
  mutating func clearMixerContractConfig() {_uniqueStorage()._mixerContractConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Mixer contract setup. See
/// https://github.com/confio/poe-contracts/tree/main/contracts/tg4-mixer
struct Confio_Poe_V1beta1_MixerContractConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sigmoid returns a sigmoid-like value of staked amount times engagement
  /// points. See the Proof-of-Engagement white-paper for details.
  var sigmoid: Confio_Poe_V1beta1_MixerContractConfig.Sigmoid {
    get {return _sigmoid ?? Confio_Poe_V1beta1_MixerContractConfig.Sigmoid()}
    set {_sigmoid = newValue}
  }
  /// Returns true if `sigmoid` has been explicitly set.
  var hasSigmoid: Bool {return self._sigmoid != nil}
  /// Clears the value of `sigmoid`. Subsequent reads from it will return its default value.
  mutating func clearSigmoid() {self._sigmoid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Sigmoid {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var maxPoints: UInt64 = 0

    var p: String = String()

    var s: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _sigmoid: Confio_Poe_V1beta1_MixerContractConfig.Sigmoid? = nil
}

/// StakeContractConfig initial setup config
struct Confio_Poe_V1beta1_StakeContractConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var minBond: UInt64 = 0

  var tokensPerPoint: UInt64 = 0

  var unbondingPeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _unbondingPeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_unbondingPeriod = newValue}
  }
  /// Returns true if `unbondingPeriod` has been explicitly set.
  var hasUnbondingPeriod: Bool {return self._unbondingPeriod != nil}
  /// Clears the value of `unbondingPeriod`. Subsequent reads from it will return its default value.
  mutating func clearUnbondingPeriod() {self._unbondingPeriod = nil}

  var claimAutoreturnLimit: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _unbondingPeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// ValsetContractConfig initial setup config
struct Confio_Poe_V1beta1_ValsetContractConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var minPoints: UInt64 = 0

  /// MaxValidators The maximum number of validators that can be included in the
  /// Tendermint validator set.
  var maxValidators: UInt32 = 0

  /// EpochLength We update the Tendermint validator set only once per epoch.
  /// Epoch # is env.block.time/epoch_length (round down). The first block with a
  /// new epoch number will trigger a new validator calculation.
  var epochLength: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _epochLength ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_epochLength = newValue}
  }
  /// Returns true if `epochLength` has been explicitly set.
  var hasEpochLength: Bool {return self._epochLength != nil}
  /// Clears the value of `epochLength`. Subsequent reads from it will return its default value.
  mutating func clearEpochLength() {self._epochLength = nil}

  var epochReward: Cosmos_Base_V1beta1_Coin {
    get {return _epochReward ?? Cosmos_Base_V1beta1_Coin()}
    set {_epochReward = newValue}
  }
  /// Returns true if `epochReward` has been explicitly set.
  var hasEpochReward: Bool {return self._epochReward != nil}
  /// Clears the value of `epochReward`. Subsequent reads from it will return its default value.
  mutating func clearEpochReward() {self._epochReward = nil}

  /// Scaling is the factor to multiply cw4-group weights to produce the
  /// Tendermint validator power
  var scaling: UInt32 = 0

  /// FeePercentage is the percentage of total accumulated fees that is
  /// subtracted from tokens minted as rewards. 50% by default. To disable this
  /// feature just set it to 0 (which effectively means that fees don't affect
  /// the per-epoch reward).
  var feePercentage: String = String()

  /// CommunityPoolRewardRation in percentage
  var communityPoolRewardRatio: String = String()

  /// EngagementRewardRatio reward ration in percentage for all
  var engagementRewardRatio: String = String()

  /// ValidatorRewardRation in percentage for all
  var validatorRewardRatio: String = String()

  /// AutoUnjail if set to true, we will auto-unjail any validator after their
  /// jailtime is over.
  var autoUnjail: Bool = false

  /// DoubleSignSlashRatio Validators who are caught double signing are jailed
  /// forever and their bonded tokens are slashed based on this value.
  var doubleSignSlashRatio: String = String()

  /// When a validator joins the valset, verify they sign the first block since
  /// joining or jail them for a period otherwise.
  ///
  /// The verification happens every time the validator becomes an active
  /// validator, including when they are unjailed or when they just gain enough
  /// power to participate.
  var verifyValidators: Bool = false

  /// OfflineJailDuration duration to jail a validator for in case they don't
  /// sign their first epoch boundary block. After the period, they have to pass
  /// verification again, ad infinitum.
  var offlineJailDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _offlineJailDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_offlineJailDuration = newValue}
  }
  /// Returns true if `offlineJailDuration` has been explicitly set.
  var hasOfflineJailDuration: Bool {return self._offlineJailDuration != nil}
  /// Clears the value of `offlineJailDuration`. Subsequent reads from it will return its default value.
  mutating func clearOfflineJailDuration() {self._offlineJailDuration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _epochLength: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _epochReward: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _offlineJailDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// EngagementContractConfig initial setup config
struct Confio_Poe_V1beta1_EngagementContractConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var halflife: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _halflife ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_halflife = newValue}
  }
  /// Returns true if `halflife` has been explicitly set.
  var hasHalflife: Bool {return self._halflife != nil}
  /// Clears the value of `halflife`. Subsequent reads from it will return its default value.
  mutating func clearHalflife() {self._halflife = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _halflife: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// OversightCommitteeContractConfig initial setup config for the trusted circle
struct Confio_Poe_V1beta1_OversightCommitteeContractConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of TRUSTED_CIRCLE
  var name: String = String()

  /// EscrowAmount The required escrow amount, in the default denom (utgd)
  var escrowAmount: Cosmos_Base_V1beta1_Coin {
    get {return _escrowAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_escrowAmount = newValue}
  }
  /// Returns true if `escrowAmount` has been explicitly set.
  var hasEscrowAmount: Bool {return self._escrowAmount != nil}
  /// Clears the value of `escrowAmount`. Subsequent reads from it will return its default value.
  mutating func clearEscrowAmount() {self._escrowAmount = nil}

  /// VotingRules rules for the tally
  var votingRules: Confio_Poe_V1beta1_VotingRules {
    get {return _votingRules ?? Confio_Poe_V1beta1_VotingRules()}
    set {_votingRules = newValue}
  }
  /// Returns true if `votingRules` has been explicitly set.
  var hasVotingRules: Bool {return self._votingRules != nil}
  /// Clears the value of `votingRules`. Subsequent reads from it will return its default value.
  mutating func clearVotingRules() {self._votingRules = nil}

  /// DenyListContractAddress is an optional cw4 contract with list of addresses
  /// denied to be part of TrustedCircle
  var denyListContractAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _escrowAmount: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _votingRules: Confio_Poe_V1beta1_VotingRules? = nil
}

/// CommunityPoolContractConfig initial setup config for the contract
struct Confio_Poe_V1beta1_CommunityPoolContractConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// VotingRules rules for the tally
  var votingRules: Confio_Poe_V1beta1_VotingRules {
    get {return _votingRules ?? Confio_Poe_V1beta1_VotingRules()}
    set {_votingRules = newValue}
  }
  /// Returns true if `votingRules` has been explicitly set.
  var hasVotingRules: Bool {return self._votingRules != nil}
  /// Clears the value of `votingRules`. Subsequent reads from it will return its default value.
  mutating func clearVotingRules() {self._votingRules = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _votingRules: Confio_Poe_V1beta1_VotingRules? = nil
}

/// ValidatorVotingContractConfig CommunityPoolContractConfig
struct Confio_Poe_V1beta1_ValidatorVotingContractConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// VotingRules rules for the tally
  var votingRules: Confio_Poe_V1beta1_VotingRules {
    get {return _votingRules ?? Confio_Poe_V1beta1_VotingRules()}
    set {_votingRules = newValue}
  }
  /// Returns true if `votingRules` has been explicitly set.
  var hasVotingRules: Bool {return self._votingRules != nil}
  /// Clears the value of `votingRules`. Subsequent reads from it will return its default value.
  mutating func clearVotingRules() {self._votingRules = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _votingRules: Confio_Poe_V1beta1_VotingRules? = nil
}

/// PoEContract address and type information
struct Confio_Poe_V1beta1_PoEContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ContractType type.
  var contractType: Confio_Poe_V1beta1_PoEContractType = .undefined

  /// Address is the bech32 address string
  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TG4Member member of the Engagement group.
struct Confio_Poe_V1beta1_TG4Member {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Address is the bech32 address string
  var address: String = String()

  var points: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// VotingRules contains configuration for the tally.
struct Confio_Poe_V1beta1_VotingRules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// VotingPeriod Voting period in days
  var votingPeriod: UInt32 = 0

  /// Quorum  voting quorum percentage (1-100)
  var quorum: String = String()

  /// Threshold voting threshold percentage (50-100)
  var threshold: String = String()

  /// AllowEndEarly If true, and absolute threshold and quorum are met, we can
  /// end before voting period finished. (Recommended value: true, unless you
  /// have special needs)
  var allowEndEarly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ArbiterPoolContractConfig initial setup config for the trusted circle
struct Confio_Poe_V1beta1_ArbiterPoolContractConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of TRUSTED_CIRCLE
  var name: String = String()

  /// EscrowAmount The required escrow amount, in the default denom (utgd)
  var escrowAmount: Cosmos_Base_V1beta1_Coin {
    get {return _escrowAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_escrowAmount = newValue}
  }
  /// Returns true if `escrowAmount` has been explicitly set.
  var hasEscrowAmount: Bool {return self._escrowAmount != nil}
  /// Clears the value of `escrowAmount`. Subsequent reads from it will return its default value.
  mutating func clearEscrowAmount() {self._escrowAmount = nil}

  /// VotingRules rules for the tally
  var votingRules: Confio_Poe_V1beta1_VotingRules {
    get {return _votingRules ?? Confio_Poe_V1beta1_VotingRules()}
    set {_votingRules = newValue}
  }
  /// Returns true if `votingRules` has been explicitly set.
  var hasVotingRules: Bool {return self._votingRules != nil}
  /// Clears the value of `votingRules`. Subsequent reads from it will return its default value.
  mutating func clearVotingRules() {self._votingRules = nil}

  /// DenyListContractAddress is an optional cw4 contract with list of addresses
  /// denied to be part of TrustedCircle
  var denyListContractAddress: String = String()

  /// DisputeCost The required dispute amount, in the default denom (utgd)
  var disputeCost: Cosmos_Base_V1beta1_Coin {
    get {return _disputeCost ?? Cosmos_Base_V1beta1_Coin()}
    set {_disputeCost = newValue}
  }
  /// Returns true if `disputeCost` has been explicitly set.
  var hasDisputeCost: Bool {return self._disputeCost != nil}
  /// Clears the value of `disputeCost`. Subsequent reads from it will return its default value.
  mutating func clearDisputeCost() {self._disputeCost = nil}

  var waitingPeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _waitingPeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_waitingPeriod = newValue}
  }
  /// Returns true if `waitingPeriod` has been explicitly set.
  var hasWaitingPeriod: Bool {return self._waitingPeriod != nil}
  /// Clears the value of `waitingPeriod`. Subsequent reads from it will return its default value.
  mutating func clearWaitingPeriod() {self._waitingPeriod = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _escrowAmount: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _votingRules: Confio_Poe_V1beta1_VotingRules? = nil
  fileprivate var _disputeCost: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _waitingPeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "confio.poe.v1beta1"

extension Confio_Poe_V1beta1_GenesisState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenesisState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
    2: .standard(proto: "seed_contracts"),
    3: .standard(proto: "import_dump"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      case 2: try {
        var v: Confio_Poe_V1beta1_SeedContracts?
        var hadOneofValue = false
        if let current = self.setupMode {
          hadOneofValue = true
          if case .seedContracts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.setupMode = .seedContracts(v)
        }
      }()
      case 3: try {
        var v: Confio_Poe_V1beta1_ImportDump?
        var hadOneofValue = false
        if let current = self.setupMode {
          hadOneofValue = true
          if case .importDump(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.setupMode = .importDump(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.setupMode {
    case .seedContracts?: try {
      guard case .seedContracts(let v)? = self.setupMode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .importDump?: try {
      guard case .importDump(let v)? = self.setupMode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Confio_Poe_V1beta1_GenesisState, rhs: Confio_Poe_V1beta1_GenesisState) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.setupMode != rhs.setupMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confio_Poe_V1beta1_ImportDump: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportDump"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contracts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.contracts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contracts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contracts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Confio_Poe_V1beta1_ImportDump, rhs: Confio_Poe_V1beta1_ImportDump) -> Bool {
    if lhs.contracts != rhs.contracts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confio_Poe_V1beta1_SeedContracts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SeedContracts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gen_txs"),
    2: .standard(proto: "bootstrap_account_address"),
    3: .same(proto: "engagement"),
    4: .standard(proto: "stake_contract_config"),
    5: .standard(proto: "valset_contract_config"),
    6: .standard(proto: "engagement_contract_config"),
    7: .standard(proto: "bond_denom"),
    8: .standard(proto: "oversight_committee_contract_config"),
    9: .standard(proto: "community_pool_contract_config"),
    10: .standard(proto: "validator_voting_contract_config"),
    11: .standard(proto: "oversight_community_members"),
    12: .standard(proto: "arbiter_pool_members"),
    13: .standard(proto: "arbiter_pool_contract_config"),
    14: .standard(proto: "mixer_contract_config"),
  ]

  fileprivate class _StorageClass {
    var _genTxs: [Data] = []
    var _bootstrapAccountAddress: String = String()
    var _engagement: [Confio_Poe_V1beta1_TG4Member] = []
    var _stakeContractConfig: Confio_Poe_V1beta1_StakeContractConfig? = nil
    var _valsetContractConfig: Confio_Poe_V1beta1_ValsetContractConfig? = nil
    var _engagementContractConfig: Confio_Poe_V1beta1_EngagementContractConfig? = nil
    var _bondDenom: String = String()
    var _oversightCommitteeContractConfig: Confio_Poe_V1beta1_OversightCommitteeContractConfig? = nil
    var _communityPoolContractConfig: Confio_Poe_V1beta1_CommunityPoolContractConfig? = nil
    var _validatorVotingContractConfig: Confio_Poe_V1beta1_ValidatorVotingContractConfig? = nil
    var _oversightCommunityMembers: [String] = []
    var _arbiterPoolMembers: [String] = []
    var _arbiterPoolContractConfig: Confio_Poe_V1beta1_ArbiterPoolContractConfig? = nil
    var _mixerContractConfig: Confio_Poe_V1beta1_MixerContractConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _genTxs = source._genTxs
      _bootstrapAccountAddress = source._bootstrapAccountAddress
      _engagement = source._engagement
      _stakeContractConfig = source._stakeContractConfig
      _valsetContractConfig = source._valsetContractConfig
      _engagementContractConfig = source._engagementContractConfig
      _bondDenom = source._bondDenom
      _oversightCommitteeContractConfig = source._oversightCommitteeContractConfig
      _communityPoolContractConfig = source._communityPoolContractConfig
      _validatorVotingContractConfig = source._validatorVotingContractConfig
      _oversightCommunityMembers = source._oversightCommunityMembers
      _arbiterPoolMembers = source._arbiterPoolMembers
      _arbiterPoolContractConfig = source._arbiterPoolContractConfig
      _mixerContractConfig = source._mixerContractConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedBytesField(value: &_storage._genTxs) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._bootstrapAccountAddress) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._engagement) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._stakeContractConfig) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._valsetContractConfig) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._engagementContractConfig) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._bondDenom) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._oversightCommitteeContractConfig) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._communityPoolContractConfig) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._validatorVotingContractConfig) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._oversightCommunityMembers) }()
        case 12: try { try decoder.decodeRepeatedStringField(value: &_storage._arbiterPoolMembers) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._arbiterPoolContractConfig) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._mixerContractConfig) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._genTxs.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._genTxs, fieldNumber: 1)
      }
      if !_storage._bootstrapAccountAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bootstrapAccountAddress, fieldNumber: 2)
      }
      if !_storage._engagement.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._engagement, fieldNumber: 3)
      }
      if let v = _storage._stakeContractConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._valsetContractConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._engagementContractConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._bondDenom.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bondDenom, fieldNumber: 7)
      }
      if let v = _storage._oversightCommitteeContractConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._communityPoolContractConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._validatorVotingContractConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._oversightCommunityMembers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._oversightCommunityMembers, fieldNumber: 11)
      }
      if !_storage._arbiterPoolMembers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._arbiterPoolMembers, fieldNumber: 12)
      }
      if let v = _storage._arbiterPoolContractConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._mixerContractConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Confio_Poe_V1beta1_SeedContracts, rhs: Confio_Poe_V1beta1_SeedContracts) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._genTxs != rhs_storage._genTxs {return false}
        if _storage._bootstrapAccountAddress != rhs_storage._bootstrapAccountAddress {return false}
        if _storage._engagement != rhs_storage._engagement {return false}
        if _storage._stakeContractConfig != rhs_storage._stakeContractConfig {return false}
        if _storage._valsetContractConfig != rhs_storage._valsetContractConfig {return false}
        if _storage._engagementContractConfig != rhs_storage._engagementContractConfig {return false}
        if _storage._bondDenom != rhs_storage._bondDenom {return false}
        if _storage._oversightCommitteeContractConfig != rhs_storage._oversightCommitteeContractConfig {return false}
        if _storage._communityPoolContractConfig != rhs_storage._communityPoolContractConfig {return false}
        if _storage._validatorVotingContractConfig != rhs_storage._validatorVotingContractConfig {return false}
        if _storage._oversightCommunityMembers != rhs_storage._oversightCommunityMembers {return false}
        if _storage._arbiterPoolMembers != rhs_storage._arbiterPoolMembers {return false}
        if _storage._arbiterPoolContractConfig != rhs_storage._arbiterPoolContractConfig {return false}
        if _storage._mixerContractConfig != rhs_storage._mixerContractConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confio_Poe_V1beta1_MixerContractConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MixerContractConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sigmoid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sigmoid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sigmoid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Confio_Poe_V1beta1_MixerContractConfig, rhs: Confio_Poe_V1beta1_MixerContractConfig) -> Bool {
    if lhs._sigmoid != rhs._sigmoid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confio_Poe_V1beta1_MixerContractConfig.Sigmoid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Confio_Poe_V1beta1_MixerContractConfig.protoMessageName + ".Sigmoid"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_points"),
    2: .same(proto: "p"),
    3: .same(proto: "s"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.maxPoints) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.s) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxPoints != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxPoints, fieldNumber: 1)
    }
    if !self.p.isEmpty {
      try visitor.visitSingularStringField(value: self.p, fieldNumber: 2)
    }
    if !self.s.isEmpty {
      try visitor.visitSingularStringField(value: self.s, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Confio_Poe_V1beta1_MixerContractConfig.Sigmoid, rhs: Confio_Poe_V1beta1_MixerContractConfig.Sigmoid) -> Bool {
    if lhs.maxPoints != rhs.maxPoints {return false}
    if lhs.p != rhs.p {return false}
    if lhs.s != rhs.s {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confio_Poe_V1beta1_StakeContractConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StakeContractConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_bond"),
    2: .standard(proto: "tokens_per_point"),
    3: .standard(proto: "unbonding_period"),
    4: .standard(proto: "claim_autoreturn_limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.minBond) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.tokensPerPoint) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._unbondingPeriod) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.claimAutoreturnLimit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minBond != 0 {
      try visitor.visitSingularUInt64Field(value: self.minBond, fieldNumber: 1)
    }
    if self.tokensPerPoint != 0 {
      try visitor.visitSingularUInt64Field(value: self.tokensPerPoint, fieldNumber: 2)
    }
    if let v = self._unbondingPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.claimAutoreturnLimit != 0 {
      try visitor.visitSingularUInt32Field(value: self.claimAutoreturnLimit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Confio_Poe_V1beta1_StakeContractConfig, rhs: Confio_Poe_V1beta1_StakeContractConfig) -> Bool {
    if lhs.minBond != rhs.minBond {return false}
    if lhs.tokensPerPoint != rhs.tokensPerPoint {return false}
    if lhs._unbondingPeriod != rhs._unbondingPeriod {return false}
    if lhs.claimAutoreturnLimit != rhs.claimAutoreturnLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confio_Poe_V1beta1_ValsetContractConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValsetContractConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_points"),
    2: .standard(proto: "max_validators"),
    3: .standard(proto: "epoch_length"),
    4: .standard(proto: "epoch_reward"),
    5: .same(proto: "scaling"),
    6: .standard(proto: "fee_percentage"),
    7: .standard(proto: "community_pool_reward_ratio"),
    8: .standard(proto: "engagement_reward_ratio"),
    9: .standard(proto: "validator_reward_ratio"),
    10: .standard(proto: "auto_unjail"),
    11: .standard(proto: "double_sign_slash_ratio"),
    12: .standard(proto: "verify_validators"),
    13: .same(proto: "offlineJailDuration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.minPoints) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.maxValidators) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._epochLength) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._epochReward) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.scaling) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.feePercentage) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.communityPoolRewardRatio) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.engagementRewardRatio) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.validatorRewardRatio) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.autoUnjail) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.doubleSignSlashRatio) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.verifyValidators) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._offlineJailDuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minPoints != 0 {
      try visitor.visitSingularUInt64Field(value: self.minPoints, fieldNumber: 1)
    }
    if self.maxValidators != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxValidators, fieldNumber: 2)
    }
    if let v = self._epochLength {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._epochReward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.scaling != 0 {
      try visitor.visitSingularUInt32Field(value: self.scaling, fieldNumber: 5)
    }
    if !self.feePercentage.isEmpty {
      try visitor.visitSingularStringField(value: self.feePercentage, fieldNumber: 6)
    }
    if !self.communityPoolRewardRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.communityPoolRewardRatio, fieldNumber: 7)
    }
    if !self.engagementRewardRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.engagementRewardRatio, fieldNumber: 8)
    }
    if !self.validatorRewardRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorRewardRatio, fieldNumber: 9)
    }
    if self.autoUnjail != false {
      try visitor.visitSingularBoolField(value: self.autoUnjail, fieldNumber: 10)
    }
    if !self.doubleSignSlashRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.doubleSignSlashRatio, fieldNumber: 11)
    }
    if self.verifyValidators != false {
      try visitor.visitSingularBoolField(value: self.verifyValidators, fieldNumber: 12)
    }
    if let v = self._offlineJailDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Confio_Poe_V1beta1_ValsetContractConfig, rhs: Confio_Poe_V1beta1_ValsetContractConfig) -> Bool {
    if lhs.minPoints != rhs.minPoints {return false}
    if lhs.maxValidators != rhs.maxValidators {return false}
    if lhs._epochLength != rhs._epochLength {return false}
    if lhs._epochReward != rhs._epochReward {return false}
    if lhs.scaling != rhs.scaling {return false}
    if lhs.feePercentage != rhs.feePercentage {return false}
    if lhs.communityPoolRewardRatio != rhs.communityPoolRewardRatio {return false}
    if lhs.engagementRewardRatio != rhs.engagementRewardRatio {return false}
    if lhs.validatorRewardRatio != rhs.validatorRewardRatio {return false}
    if lhs.autoUnjail != rhs.autoUnjail {return false}
    if lhs.doubleSignSlashRatio != rhs.doubleSignSlashRatio {return false}
    if lhs.verifyValidators != rhs.verifyValidators {return false}
    if lhs._offlineJailDuration != rhs._offlineJailDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confio_Poe_V1beta1_EngagementContractConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EngagementContractConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "halflife"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._halflife) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._halflife {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Confio_Poe_V1beta1_EngagementContractConfig, rhs: Confio_Poe_V1beta1_EngagementContractConfig) -> Bool {
    if lhs._halflife != rhs._halflife {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confio_Poe_V1beta1_OversightCommitteeContractConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OversightCommitteeContractConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "escrow_amount"),
    3: .standard(proto: "voting_rules"),
    4: .standard(proto: "deny_list_contract_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._escrowAmount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._votingRules) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.denyListContractAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._escrowAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._votingRules {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.denyListContractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.denyListContractAddress, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Confio_Poe_V1beta1_OversightCommitteeContractConfig, rhs: Confio_Poe_V1beta1_OversightCommitteeContractConfig) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._escrowAmount != rhs._escrowAmount {return false}
    if lhs._votingRules != rhs._votingRules {return false}
    if lhs.denyListContractAddress != rhs.denyListContractAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confio_Poe_V1beta1_CommunityPoolContractConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommunityPoolContractConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "voting_rules"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._votingRules) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._votingRules {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Confio_Poe_V1beta1_CommunityPoolContractConfig, rhs: Confio_Poe_V1beta1_CommunityPoolContractConfig) -> Bool {
    if lhs._votingRules != rhs._votingRules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confio_Poe_V1beta1_ValidatorVotingContractConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidatorVotingContractConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "voting_rules"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._votingRules) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._votingRules {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Confio_Poe_V1beta1_ValidatorVotingContractConfig, rhs: Confio_Poe_V1beta1_ValidatorVotingContractConfig) -> Bool {
    if lhs._votingRules != rhs._votingRules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confio_Poe_V1beta1_PoEContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoEContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_type"),
    2: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.contractType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.contractType != .undefined {
      try visitor.visitSingularEnumField(value: self.contractType, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Confio_Poe_V1beta1_PoEContract, rhs: Confio_Poe_V1beta1_PoEContract) -> Bool {
    if lhs.contractType != rhs.contractType {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confio_Poe_V1beta1_TG4Member: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TG4Member"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.points) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.points != 0 {
      try visitor.visitSingularUInt64Field(value: self.points, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Confio_Poe_V1beta1_TG4Member, rhs: Confio_Poe_V1beta1_TG4Member) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.points != rhs.points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confio_Poe_V1beta1_VotingRules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VotingRules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "voting_period"),
    2: .same(proto: "quorum"),
    3: .same(proto: "threshold"),
    4: .standard(proto: "allow_end_early"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.votingPeriod) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.quorum) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.threshold) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.allowEndEarly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.votingPeriod != 0 {
      try visitor.visitSingularUInt32Field(value: self.votingPeriod, fieldNumber: 1)
    }
    if !self.quorum.isEmpty {
      try visitor.visitSingularStringField(value: self.quorum, fieldNumber: 2)
    }
    if !self.threshold.isEmpty {
      try visitor.visitSingularStringField(value: self.threshold, fieldNumber: 3)
    }
    if self.allowEndEarly != false {
      try visitor.visitSingularBoolField(value: self.allowEndEarly, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Confio_Poe_V1beta1_VotingRules, rhs: Confio_Poe_V1beta1_VotingRules) -> Bool {
    if lhs.votingPeriod != rhs.votingPeriod {return false}
    if lhs.quorum != rhs.quorum {return false}
    if lhs.threshold != rhs.threshold {return false}
    if lhs.allowEndEarly != rhs.allowEndEarly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Confio_Poe_V1beta1_ArbiterPoolContractConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArbiterPoolContractConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "escrow_amount"),
    3: .standard(proto: "voting_rules"),
    4: .standard(proto: "deny_list_contract_address"),
    5: .standard(proto: "dispute_cost"),
    6: .standard(proto: "waiting_period"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._escrowAmount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._votingRules) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.denyListContractAddress) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._disputeCost) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._waitingPeriod) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._escrowAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._votingRules {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.denyListContractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.denyListContractAddress, fieldNumber: 4)
    }
    if let v = self._disputeCost {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._waitingPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Confio_Poe_V1beta1_ArbiterPoolContractConfig, rhs: Confio_Poe_V1beta1_ArbiterPoolContractConfig) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._escrowAmount != rhs._escrowAmount {return false}
    if lhs._votingRules != rhs._votingRules {return false}
    if lhs.denyListContractAddress != rhs.denyListContractAddress {return false}
    if lhs._disputeCost != rhs._disputeCost {return false}
    if lhs._waitingPeriod != rhs._waitingPeriod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
