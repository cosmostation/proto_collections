// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: crescent/liquidity/v1beta1/liquidity.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// OrderDirection enumerates order directions.
enum Crescent_Liquidity_V1beta1_OrderDirection: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// ORDER_DIRECTION_UNSPECIFIED specifies unknown order direction
  case unspecified // = 0

  /// ORDER_DIRECTION_BUY specifies buy(swap quote coin to base coin) order direction
  case buy // = 1

  /// ORDER_DIRECTION_SELL specifies sell(swap base coin to quote coin) order direction
  case sell // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .buy
    case 2: self = .sell
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .buy: return 1
    case .sell: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Crescent_Liquidity_V1beta1_OrderDirection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Crescent_Liquidity_V1beta1_OrderDirection] = [
    .unspecified,
    .buy,
    .sell,
  ]
}

#endif  // swift(>=4.2)

/// RequestStatus enumerates request statuses.
enum Crescent_Liquidity_V1beta1_RequestStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// REQUEST_STATUS_UNSPECIFIED specifies unknown request status
  case unspecified // = 0

  /// REQUEST_STATUS_NOT_EXECUTED indicates the request is not executed yet
  case notExecuted // = 1

  /// REQUEST_STATUS_SUCCEEDED indicates the request has been succeeded
  case succeeded // = 2

  /// REQUEST_STATUS_FAILED indicates the request is failed
  case failed // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notExecuted
    case 2: self = .succeeded
    case 3: self = .failed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notExecuted: return 1
    case .succeeded: return 2
    case .failed: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Crescent_Liquidity_V1beta1_RequestStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Crescent_Liquidity_V1beta1_RequestStatus] = [
    .unspecified,
    .notExecuted,
    .succeeded,
    .failed,
  ]
}

#endif  // swift(>=4.2)

/// OrderStatus enumerates order statuses.
enum Crescent_Liquidity_V1beta1_OrderStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// ORDER_STATUS_UNSPECIFIED specifies unknown order status
  case unspecified // = 0

  /// ORDER_STATUS_NOT_EXECUTED indicates the order has not been executed yet
  case notExecuted // = 1

  /// ORDER_STATUS_NOT_MATCHED indicates the order has been executed but has no match
  case notMatched // = 2

  /// ORDER_STATUS_PARTIALLY_MATCHED indicates the order has been partially matched
  case partiallyMatched // = 3

  /// ORDER_STATUS_COMPLETED indicates the order has been fully matched and completed
  case completed // = 4

  /// ORDER_STATUS_CANCELED indicates the order has been canceled
  case canceled // = 5

  /// ORDER_STATUS_EXPIRED indicates the order has been expired
  case expired // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notExecuted
    case 2: self = .notMatched
    case 3: self = .partiallyMatched
    case 4: self = .completed
    case 5: self = .canceled
    case 6: self = .expired
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notExecuted: return 1
    case .notMatched: return 2
    case .partiallyMatched: return 3
    case .completed: return 4
    case .canceled: return 5
    case .expired: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Crescent_Liquidity_V1beta1_OrderStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Crescent_Liquidity_V1beta1_OrderStatus] = [
    .unspecified,
    .notExecuted,
    .notMatched,
    .partiallyMatched,
    .completed,
    .canceled,
    .expired,
  ]
}

#endif  // swift(>=4.2)

/// Params defines the parameters for the liquidity module.
struct Crescent_Liquidity_V1beta1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var batchSize: UInt32 = 0

  var tickPrecision: UInt32 = 0

  var feeCollectorAddress: String = String()

  var dustCollectorAddress: String = String()

  var minInitialPoolCoinSupply: String = String()

  var pairCreationFee: [Cosmos_Base_V1beta1_Coin] = []

  var poolCreationFee: [Cosmos_Base_V1beta1_Coin] = []

  var minInitialDepositAmount: String = String()

  var maxPriceLimitRatio: String = String()

  var maxOrderLifespan: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _maxOrderLifespan ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_maxOrderLifespan = newValue}
  }
  /// Returns true if `maxOrderLifespan` has been explicitly set.
  var hasMaxOrderLifespan: Bool {return self._maxOrderLifespan != nil}
  /// Clears the value of `maxOrderLifespan`. Subsequent reads from it will return its default value.
  mutating func clearMaxOrderLifespan() {self._maxOrderLifespan = nil}

  var swapFeeRate: String = String()

  var withdrawFeeRate: String = String()

  var depositExtraGas: UInt64 = 0

  var withdrawExtraGas: UInt64 = 0

  var orderExtraGas: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _maxOrderLifespan: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Pair defines a coin pair.
struct Crescent_Liquidity_V1beta1_Pair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var baseCoinDenom: String = String()

  var quoteCoinDenom: String = String()

  var escrowAddress: String = String()

  var lastOrderID: UInt64 = 0

  var lastPrice: String = String()

  var currentBatchID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Pool defines a basic liquidity pool with no min-price and max-price.
struct Crescent_Liquidity_V1beta1_Pool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var pairID: UInt64 = 0

  var reserveAddress: String = String()

  var poolCoinDenom: String = String()

  var lastDepositRequestID: UInt64 = 0

  var lastWithdrawRequestID: UInt64 = 0

  var disabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DepositRequest defines a deposit request.
struct Crescent_Liquidity_V1beta1_DepositRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id specifies the id for the request
  var id: UInt64 = 0

  /// pool_id specifies the pool id
  var poolID: UInt64 = 0

  /// msg_height specifies the block height when the request is stored for the batch execution
  var msgHeight: Int64 = 0

  /// depositor specifies the bech32-encoded address that makes a deposit to the pool
  var depositor: String = String()

  /// deposit_coins specifies the amount of coins to deposit.
  var depositCoins: [Cosmos_Base_V1beta1_Coin] = []

  /// accepted_coins specifies the amount of coins that are accepted.
  var acceptedCoins: [Cosmos_Base_V1beta1_Coin] = []

  var mintedPoolCoin: Cosmos_Base_V1beta1_Coin {
    get {return _mintedPoolCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_mintedPoolCoin = newValue}
  }
  /// Returns true if `mintedPoolCoin` has been explicitly set.
  var hasMintedPoolCoin: Bool {return self._mintedPoolCoin != nil}
  /// Clears the value of `mintedPoolCoin`. Subsequent reads from it will return its default value.
  mutating func clearMintedPoolCoin() {self._mintedPoolCoin = nil}

  var status: Crescent_Liquidity_V1beta1_RequestStatus = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mintedPoolCoin: Cosmos_Base_V1beta1_Coin? = nil
}

/// WithdrawRequest defines a withdraw request.
struct Crescent_Liquidity_V1beta1_WithdrawRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id specifies the id for the request
  var id: UInt64 = 0

  /// pool_id specifies the pool id
  var poolID: UInt64 = 0

  /// msg_height specifies the block height when the request is stored for the batch execution
  var msgHeight: Int64 = 0

  /// withdrawer specifies the bech32-encoded address that withdraws pool coin from the pool
  var withdrawer: String = String()

  /// pool_coin specifies the pool coin that is a proof of liquidity provider for the pool
  var poolCoin: Cosmos_Base_V1beta1_Coin {
    get {return _poolCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_poolCoin = newValue}
  }
  /// Returns true if `poolCoin` has been explicitly set.
  var hasPoolCoin: Bool {return self._poolCoin != nil}
  /// Clears the value of `poolCoin`. Subsequent reads from it will return its default value.
  mutating func clearPoolCoin() {self._poolCoin = nil}

  /// withdrawn_coins specifies the amount of coins that are withdrawn.
  var withdrawnCoins: [Cosmos_Base_V1beta1_Coin] = []

  var status: Crescent_Liquidity_V1beta1_RequestStatus = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _poolCoin: Cosmos_Base_V1beta1_Coin? = nil
}

/// Order defines an order.
struct Crescent_Liquidity_V1beta1_Order {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id specifies the id for the request
  var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// pair_id specifies the pair id
  var pairID: UInt64 {
    get {return _storage._pairID}
    set {_uniqueStorage()._pairID = newValue}
  }

  /// msg_height specifies the block height when the request is stored for the batch execution
  var msgHeight: Int64 {
    get {return _storage._msgHeight}
    set {_uniqueStorage()._msgHeight = newValue}
  }

  /// orderer specifies the bech32-encoded address that makes an order
  var orderer: String {
    get {return _storage._orderer}
    set {_uniqueStorage()._orderer = newValue}
  }

  /// direction specifies the order direction; either buy or sell
  var direction: Crescent_Liquidity_V1beta1_OrderDirection {
    get {return _storage._direction}
    set {_uniqueStorage()._direction = newValue}
  }

  var offerCoin: Cosmos_Base_V1beta1_Coin {
    get {return _storage._offerCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._offerCoin = newValue}
  }
  /// Returns true if `offerCoin` has been explicitly set.
  var hasOfferCoin: Bool {return _storage._offerCoin != nil}
  /// Clears the value of `offerCoin`. Subsequent reads from it will return its default value.
  mutating func clearOfferCoin() {_uniqueStorage()._offerCoin = nil}

  /// remaining_offer_coin specifies the remaining offer coin
  var remainingOfferCoin: Cosmos_Base_V1beta1_Coin {
    get {return _storage._remainingOfferCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._remainingOfferCoin = newValue}
  }
  /// Returns true if `remainingOfferCoin` has been explicitly set.
  var hasRemainingOfferCoin: Bool {return _storage._remainingOfferCoin != nil}
  /// Clears the value of `remainingOfferCoin`. Subsequent reads from it will return its default value.
  mutating func clearRemainingOfferCoin() {_uniqueStorage()._remainingOfferCoin = nil}

  /// received_coin specifies the received coin after the swap
  var receivedCoin: Cosmos_Base_V1beta1_Coin {
    get {return _storage._receivedCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._receivedCoin = newValue}
  }
  /// Returns true if `receivedCoin` has been explicitly set.
  var hasReceivedCoin: Bool {return _storage._receivedCoin != nil}
  /// Clears the value of `receivedCoin`. Subsequent reads from it will return its default value.
  mutating func clearReceivedCoin() {_uniqueStorage()._receivedCoin = nil}

  /// price specifies the price that an orderer is willing to swap
  var price: String {
    get {return _storage._price}
    set {_uniqueStorage()._price = newValue}
  }

  var amount: String {
    get {return _storage._amount}
    set {_uniqueStorage()._amount = newValue}
  }

  var openAmount: String {
    get {return _storage._openAmount}
    set {_uniqueStorage()._openAmount = newValue}
  }

  /// batch_id specifies the pair's batch id when the request is stored
  var batchID: UInt64 {
    get {return _storage._batchID}
    set {_uniqueStorage()._batchID = newValue}
  }

  var expireAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expireAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expireAt = newValue}
  }
  /// Returns true if `expireAt` has been explicitly set.
  var hasExpireAt: Bool {return _storage._expireAt != nil}
  /// Clears the value of `expireAt`. Subsequent reads from it will return its default value.
  mutating func clearExpireAt() {_uniqueStorage()._expireAt = nil}

  var status: Crescent_Liquidity_V1beta1_OrderStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "crescent.liquidity.v1beta1"

extension Crescent_Liquidity_V1beta1_OrderDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORDER_DIRECTION_UNSPECIFIED"),
    1: .same(proto: "ORDER_DIRECTION_BUY"),
    2: .same(proto: "ORDER_DIRECTION_SELL"),
  ]
}

extension Crescent_Liquidity_V1beta1_RequestStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REQUEST_STATUS_UNSPECIFIED"),
    1: .same(proto: "REQUEST_STATUS_NOT_EXECUTED"),
    2: .same(proto: "REQUEST_STATUS_SUCCEEDED"),
    3: .same(proto: "REQUEST_STATUS_FAILED"),
  ]
}

extension Crescent_Liquidity_V1beta1_OrderStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORDER_STATUS_UNSPECIFIED"),
    1: .same(proto: "ORDER_STATUS_NOT_EXECUTED"),
    2: .same(proto: "ORDER_STATUS_NOT_MATCHED"),
    3: .same(proto: "ORDER_STATUS_PARTIALLY_MATCHED"),
    4: .same(proto: "ORDER_STATUS_COMPLETED"),
    5: .same(proto: "ORDER_STATUS_CANCELED"),
    6: .same(proto: "ORDER_STATUS_EXPIRED"),
  ]
}

extension Crescent_Liquidity_V1beta1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_size"),
    2: .standard(proto: "tick_precision"),
    3: .standard(proto: "fee_collector_address"),
    4: .standard(proto: "dust_collector_address"),
    5: .standard(proto: "min_initial_pool_coin_supply"),
    6: .standard(proto: "pair_creation_fee"),
    7: .standard(proto: "pool_creation_fee"),
    8: .standard(proto: "min_initial_deposit_amount"),
    9: .standard(proto: "max_price_limit_ratio"),
    10: .standard(proto: "max_order_lifespan"),
    11: .standard(proto: "swap_fee_rate"),
    12: .standard(proto: "withdraw_fee_rate"),
    13: .standard(proto: "deposit_extra_gas"),
    14: .standard(proto: "withdraw_extra_gas"),
    15: .standard(proto: "order_extra_gas"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.batchSize) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.tickPrecision) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.feeCollectorAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.dustCollectorAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.minInitialPoolCoinSupply) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.pairCreationFee) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.poolCreationFee) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.minInitialDepositAmount) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.maxPriceLimitRatio) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._maxOrderLifespan) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.swapFeeRate) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.withdrawFeeRate) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self.depositExtraGas) }()
      case 14: try { try decoder.decodeSingularUInt64Field(value: &self.withdrawExtraGas) }()
      case 15: try { try decoder.decodeSingularUInt64Field(value: &self.orderExtraGas) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.batchSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.batchSize, fieldNumber: 1)
    }
    if self.tickPrecision != 0 {
      try visitor.visitSingularUInt32Field(value: self.tickPrecision, fieldNumber: 2)
    }
    if !self.feeCollectorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.feeCollectorAddress, fieldNumber: 3)
    }
    if !self.dustCollectorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.dustCollectorAddress, fieldNumber: 4)
    }
    if !self.minInitialPoolCoinSupply.isEmpty {
      try visitor.visitSingularStringField(value: self.minInitialPoolCoinSupply, fieldNumber: 5)
    }
    if !self.pairCreationFee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pairCreationFee, fieldNumber: 6)
    }
    if !self.poolCreationFee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.poolCreationFee, fieldNumber: 7)
    }
    if !self.minInitialDepositAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.minInitialDepositAmount, fieldNumber: 8)
    }
    if !self.maxPriceLimitRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.maxPriceLimitRatio, fieldNumber: 9)
    }
    if let v = self._maxOrderLifespan {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if !self.swapFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.swapFeeRate, fieldNumber: 11)
    }
    if !self.withdrawFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.withdrawFeeRate, fieldNumber: 12)
    }
    if self.depositExtraGas != 0 {
      try visitor.visitSingularUInt64Field(value: self.depositExtraGas, fieldNumber: 13)
    }
    if self.withdrawExtraGas != 0 {
      try visitor.visitSingularUInt64Field(value: self.withdrawExtraGas, fieldNumber: 14)
    }
    if self.orderExtraGas != 0 {
      try visitor.visitSingularUInt64Field(value: self.orderExtraGas, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Crescent_Liquidity_V1beta1_Params, rhs: Crescent_Liquidity_V1beta1_Params) -> Bool {
    if lhs.batchSize != rhs.batchSize {return false}
    if lhs.tickPrecision != rhs.tickPrecision {return false}
    if lhs.feeCollectorAddress != rhs.feeCollectorAddress {return false}
    if lhs.dustCollectorAddress != rhs.dustCollectorAddress {return false}
    if lhs.minInitialPoolCoinSupply != rhs.minInitialPoolCoinSupply {return false}
    if lhs.pairCreationFee != rhs.pairCreationFee {return false}
    if lhs.poolCreationFee != rhs.poolCreationFee {return false}
    if lhs.minInitialDepositAmount != rhs.minInitialDepositAmount {return false}
    if lhs.maxPriceLimitRatio != rhs.maxPriceLimitRatio {return false}
    if lhs._maxOrderLifespan != rhs._maxOrderLifespan {return false}
    if lhs.swapFeeRate != rhs.swapFeeRate {return false}
    if lhs.withdrawFeeRate != rhs.withdrawFeeRate {return false}
    if lhs.depositExtraGas != rhs.depositExtraGas {return false}
    if lhs.withdrawExtraGas != rhs.withdrawExtraGas {return false}
    if lhs.orderExtraGas != rhs.orderExtraGas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Crescent_Liquidity_V1beta1_Pair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "base_coin_denom"),
    3: .standard(proto: "quote_coin_denom"),
    4: .standard(proto: "escrow_address"),
    5: .standard(proto: "last_order_id"),
    6: .standard(proto: "last_price"),
    7: .standard(proto: "current_batch_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.baseCoinDenom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.quoteCoinDenom) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.escrowAddress) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.lastOrderID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.lastPrice) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.currentBatchID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.baseCoinDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.baseCoinDenom, fieldNumber: 2)
    }
    if !self.quoteCoinDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteCoinDenom, fieldNumber: 3)
    }
    if !self.escrowAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.escrowAddress, fieldNumber: 4)
    }
    if self.lastOrderID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastOrderID, fieldNumber: 5)
    }
    if !self.lastPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.lastPrice, fieldNumber: 6)
    }
    if self.currentBatchID != 0 {
      try visitor.visitSingularUInt64Field(value: self.currentBatchID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Crescent_Liquidity_V1beta1_Pair, rhs: Crescent_Liquidity_V1beta1_Pair) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.baseCoinDenom != rhs.baseCoinDenom {return false}
    if lhs.quoteCoinDenom != rhs.quoteCoinDenom {return false}
    if lhs.escrowAddress != rhs.escrowAddress {return false}
    if lhs.lastOrderID != rhs.lastOrderID {return false}
    if lhs.lastPrice != rhs.lastPrice {return false}
    if lhs.currentBatchID != rhs.currentBatchID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Crescent_Liquidity_V1beta1_Pool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pool"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "pair_id"),
    3: .standard(proto: "reserve_address"),
    4: .standard(proto: "pool_coin_denom"),
    5: .standard(proto: "last_deposit_request_id"),
    6: .standard(proto: "last_withdraw_request_id"),
    7: .same(proto: "disabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.pairID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reserveAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.poolCoinDenom) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.lastDepositRequestID) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.lastWithdrawRequestID) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.pairID != 0 {
      try visitor.visitSingularUInt64Field(value: self.pairID, fieldNumber: 2)
    }
    if !self.reserveAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.reserveAddress, fieldNumber: 3)
    }
    if !self.poolCoinDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.poolCoinDenom, fieldNumber: 4)
    }
    if self.lastDepositRequestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastDepositRequestID, fieldNumber: 5)
    }
    if self.lastWithdrawRequestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastWithdrawRequestID, fieldNumber: 6)
    }
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Crescent_Liquidity_V1beta1_Pool, rhs: Crescent_Liquidity_V1beta1_Pool) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.pairID != rhs.pairID {return false}
    if lhs.reserveAddress != rhs.reserveAddress {return false}
    if lhs.poolCoinDenom != rhs.poolCoinDenom {return false}
    if lhs.lastDepositRequestID != rhs.lastDepositRequestID {return false}
    if lhs.lastWithdrawRequestID != rhs.lastWithdrawRequestID {return false}
    if lhs.disabled != rhs.disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Crescent_Liquidity_V1beta1_DepositRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DepositRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "pool_id"),
    3: .standard(proto: "msg_height"),
    4: .same(proto: "depositor"),
    5: .standard(proto: "deposit_coins"),
    6: .standard(proto: "accepted_coins"),
    7: .standard(proto: "minted_pool_coin"),
    8: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.msgHeight) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.depositor) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.depositCoins) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.acceptedCoins) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._mintedPoolCoin) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 2)
    }
    if self.msgHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.msgHeight, fieldNumber: 3)
    }
    if !self.depositor.isEmpty {
      try visitor.visitSingularStringField(value: self.depositor, fieldNumber: 4)
    }
    if !self.depositCoins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.depositCoins, fieldNumber: 5)
    }
    if !self.acceptedCoins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.acceptedCoins, fieldNumber: 6)
    }
    if let v = self._mintedPoolCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Crescent_Liquidity_V1beta1_DepositRequest, rhs: Crescent_Liquidity_V1beta1_DepositRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.poolID != rhs.poolID {return false}
    if lhs.msgHeight != rhs.msgHeight {return false}
    if lhs.depositor != rhs.depositor {return false}
    if lhs.depositCoins != rhs.depositCoins {return false}
    if lhs.acceptedCoins != rhs.acceptedCoins {return false}
    if lhs._mintedPoolCoin != rhs._mintedPoolCoin {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Crescent_Liquidity_V1beta1_WithdrawRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WithdrawRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "pool_id"),
    3: .standard(proto: "msg_height"),
    4: .same(proto: "withdrawer"),
    5: .standard(proto: "pool_coin"),
    6: .standard(proto: "withdrawn_coins"),
    7: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.poolID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.msgHeight) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.withdrawer) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._poolCoin) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.withdrawnCoins) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 2)
    }
    if self.msgHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.msgHeight, fieldNumber: 3)
    }
    if !self.withdrawer.isEmpty {
      try visitor.visitSingularStringField(value: self.withdrawer, fieldNumber: 4)
    }
    if let v = self._poolCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.withdrawnCoins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.withdrawnCoins, fieldNumber: 6)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Crescent_Liquidity_V1beta1_WithdrawRequest, rhs: Crescent_Liquidity_V1beta1_WithdrawRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.poolID != rhs.poolID {return false}
    if lhs.msgHeight != rhs.msgHeight {return false}
    if lhs.withdrawer != rhs.withdrawer {return false}
    if lhs._poolCoin != rhs._poolCoin {return false}
    if lhs.withdrawnCoins != rhs.withdrawnCoins {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Crescent_Liquidity_V1beta1_Order: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Order"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "pair_id"),
    3: .standard(proto: "msg_height"),
    4: .same(proto: "orderer"),
    5: .same(proto: "direction"),
    6: .standard(proto: "offer_coin"),
    7: .standard(proto: "remaining_offer_coin"),
    8: .standard(proto: "received_coin"),
    9: .same(proto: "price"),
    10: .same(proto: "amount"),
    11: .standard(proto: "open_amount"),
    12: .standard(proto: "batch_id"),
    13: .standard(proto: "expire_at"),
    14: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _pairID: UInt64 = 0
    var _msgHeight: Int64 = 0
    var _orderer: String = String()
    var _direction: Crescent_Liquidity_V1beta1_OrderDirection = .unspecified
    var _offerCoin: Cosmos_Base_V1beta1_Coin? = nil
    var _remainingOfferCoin: Cosmos_Base_V1beta1_Coin? = nil
    var _receivedCoin: Cosmos_Base_V1beta1_Coin? = nil
    var _price: String = String()
    var _amount: String = String()
    var _openAmount: String = String()
    var _batchID: UInt64 = 0
    var _expireAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _status: Crescent_Liquidity_V1beta1_OrderStatus = .unspecified

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _pairID = source._pairID
      _msgHeight = source._msgHeight
      _orderer = source._orderer
      _direction = source._direction
      _offerCoin = source._offerCoin
      _remainingOfferCoin = source._remainingOfferCoin
      _receivedCoin = source._receivedCoin
      _price = source._price
      _amount = source._amount
      _openAmount = source._openAmount
      _batchID = source._batchID
      _expireAt = source._expireAt
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._pairID) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._msgHeight) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._orderer) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._direction) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._offerCoin) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._remainingOfferCoin) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._receivedCoin) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._price) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._amount) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._openAmount) }()
        case 12: try { try decoder.decodeSingularUInt64Field(value: &_storage._batchID) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._expireAt) }()
        case 14: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._pairID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._pairID, fieldNumber: 2)
      }
      if _storage._msgHeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._msgHeight, fieldNumber: 3)
      }
      if !_storage._orderer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._orderer, fieldNumber: 4)
      }
      if _storage._direction != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._direction, fieldNumber: 5)
      }
      if let v = _storage._offerCoin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._remainingOfferCoin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._receivedCoin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._price.isEmpty {
        try visitor.visitSingularStringField(value: _storage._price, fieldNumber: 9)
      }
      if !_storage._amount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._amount, fieldNumber: 10)
      }
      if !_storage._openAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._openAmount, fieldNumber: 11)
      }
      if _storage._batchID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._batchID, fieldNumber: 12)
      }
      if let v = _storage._expireAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Crescent_Liquidity_V1beta1_Order, rhs: Crescent_Liquidity_V1beta1_Order) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._pairID != rhs_storage._pairID {return false}
        if _storage._msgHeight != rhs_storage._msgHeight {return false}
        if _storage._orderer != rhs_storage._orderer {return false}
        if _storage._direction != rhs_storage._direction {return false}
        if _storage._offerCoin != rhs_storage._offerCoin {return false}
        if _storage._remainingOfferCoin != rhs_storage._remainingOfferCoin {return false}
        if _storage._receivedCoin != rhs_storage._receivedCoin {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._openAmount != rhs_storage._openAmount {return false}
        if _storage._batchID != rhs_storage._batchID {return false}
        if _storage._expireAt != rhs_storage._expireAt {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
