// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: burrow/acm.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Acm_Account {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: Data = Data()

  var publicKey: Crypto_PublicKey {
    get {return _publicKey ?? Crypto_PublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  /// Sequence counts the number of transactions that have been accepted from this account
  var sequence: UInt64 = 0

  /// The account's current native token balance
  var balance: UInt64 = 0

  /// We expect exactly one of EVMCode, WASMCode, and NativeName to be non-empty
  /// EVM bytecode
  var evmcode: Data = Data()

  var permissions: Permission_AccountPermissions {
    get {return _permissions ?? Permission_AccountPermissions()}
    set {_permissions = newValue}
  }
  /// Returns true if `permissions` has been explicitly set.
  var hasPermissions: Bool {return self._permissions != nil}
  /// Clears the value of `permissions`. Subsequent reads from it will return its default value.
  mutating func clearPermissions() {self._permissions = nil}

  /// WASM bytecode
  var wasmcode: Data = Data()

  /// Fully qualified (`<contract name>.<function name>`) name of native contract this for which this account object
  /// is a sentinel value. Which is to say this account object is a pointer to compiled code and does not contain
  /// the contract logic in its entirety
  var nativeName: String = String()

  /// The sha3 hash of the code associated with the account
  var codeHash: Data = Data()

  /// Pointer to the Metadata associated with this account
  var contractMeta: [Acm_ContractMeta] = []

  /// The metadata is stored in the deployed account. When the deployed account creates new account
  /// (from Solidity/EVM), they point to the original deployed account where the metadata is stored.
  /// This original account is called the forebear.
  var forebear: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publicKey: Crypto_PublicKey? = nil
  fileprivate var _permissions: Permission_AccountPermissions? = nil
}

struct Acm_ContractMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var codeHash: Data = Data()

  var metadataHash: Data = Data()

  /// In the dump format we would like the ABI rather than its hash
  var metadata: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "acm"

extension Acm_Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Account"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Address"),
    2: .same(proto: "PublicKey"),
    3: .same(proto: "Sequence"),
    4: .same(proto: "Balance"),
    5: .same(proto: "EVMCode"),
    6: .same(proto: "Permissions"),
    7: .same(proto: "WASMCode"),
    11: .same(proto: "NativeName"),
    8: .same(proto: "CodeHash"),
    9: .same(proto: "ContractMeta"),
    10: .same(proto: "Forebear"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.sequence) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.balance) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.evmcode) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._permissions) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.wasmcode) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.codeHash) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.contractMeta) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.forebear) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.nativeName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequence, fieldNumber: 3)
    }
    if self.balance != 0 {
      try visitor.visitSingularUInt64Field(value: self.balance, fieldNumber: 4)
    }
    if !self.evmcode.isEmpty {
      try visitor.visitSingularBytesField(value: self.evmcode, fieldNumber: 5)
    }
    if let v = self._permissions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.wasmcode.isEmpty {
      try visitor.visitSingularBytesField(value: self.wasmcode, fieldNumber: 7)
    }
    if !self.codeHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.codeHash, fieldNumber: 8)
    }
    if !self.contractMeta.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contractMeta, fieldNumber: 9)
    }
    if !self.forebear.isEmpty {
      try visitor.visitSingularBytesField(value: self.forebear, fieldNumber: 10)
    }
    if !self.nativeName.isEmpty {
      try visitor.visitSingularStringField(value: self.nativeName, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Acm_Account, rhs: Acm_Account) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.evmcode != rhs.evmcode {return false}
    if lhs._permissions != rhs._permissions {return false}
    if lhs.wasmcode != rhs.wasmcode {return false}
    if lhs.nativeName != rhs.nativeName {return false}
    if lhs.codeHash != rhs.codeHash {return false}
    if lhs.contractMeta != rhs.contractMeta {return false}
    if lhs.forebear != rhs.forebear {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Acm_ContractMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractMeta"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CodeHash"),
    2: .same(proto: "MetadataHash"),
    3: .same(proto: "Metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.codeHash) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.metadataHash) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.codeHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.codeHash, fieldNumber: 1)
    }
    if !self.metadataHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadataHash, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Acm_ContractMeta, rhs: Acm_ContractMeta) -> Bool {
    if lhs.codeHash != rhs.codeHash {return false}
    if lhs.metadataHash != rhs.metadataHash {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
