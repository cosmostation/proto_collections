// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: provenance/marker/v1/marker.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MarkerType defines the types of marker
enum Provenance_Marker_V1_MarkerType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// MARKER_TYPE_UNSPECIFIED is an invalid/unknown marker type.
  case unspecified // = 0

  /// MARKER_TYPE_COIN is a marker that represents a standard fungible coin (default).
  case coin // = 1

  /// MARKER_TYPE_RESTRICTED is a marker that represents a denom with send_enabled = false.
  case restricted // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .coin
    case 2: self = .restricted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .coin: return 1
    case .restricted: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Provenance_Marker_V1_MarkerType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Provenance_Marker_V1_MarkerType] = [
    .unspecified,
    .coin,
    .restricted,
  ]
}

#endif  // swift(>=4.2)

/// MarkerStatus defines the various states a marker account can be in.
enum Provenance_Marker_V1_MarkerStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// MARKER_STATUS_UNSPECIFIED - Unknown/Invalid Marker Status
  case unspecified // = 0

  /// MARKER_STATUS_PROPOSED - Initial configuration period, updates allowed, token supply not created.
  case proposed // = 1

  /// MARKER_STATUS_FINALIZED - Configuration finalized, ready for supply creation
  case finalized // = 2

  /// MARKER_STATUS_ACTIVE - Supply is created, rules are in force.
  case active // = 3

  /// MARKER_STATUS_CANCELLED - Marker has been cancelled, pending destroy
  case cancelled // = 4

  /// MARKER_STATUS_DESTROYED - Marker supply has all been recalled, marker is considered destroyed and no further
  /// actions allowed.
  case destroyed // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .proposed
    case 2: self = .finalized
    case 3: self = .active
    case 4: self = .cancelled
    case 5: self = .destroyed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .proposed: return 1
    case .finalized: return 2
    case .active: return 3
    case .cancelled: return 4
    case .destroyed: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Provenance_Marker_V1_MarkerStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Provenance_Marker_V1_MarkerStatus] = [
    .unspecified,
    .proposed,
    .finalized,
    .active,
    .cancelled,
    .destroyed,
  ]
}

#endif  // swift(>=4.2)

/// Params defines the set of params for the account module.
struct Provenance_Marker_V1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// maximum amount of supply to allow a marker to be created with
  var maxTotalSupply: UInt64 = 0

  /// indicates if governance based controls of markers is allowed.
  var enableGovernance: Bool = false

  /// a regular expression used to validate marker denom values from normal create requests (governance
  /// requests are only subject to platform coin validation denom expression)
  var unrestrictedDenomRegex: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MarkerAccount holds the marker configuration information in addition to a base account structure.
struct Provenance_Marker_V1_MarkerAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// base cosmos account information including address and coin holdings.
  var baseAccount: Cosmos_Auth_V1beta1_BaseAccount {
    get {return _baseAccount ?? Cosmos_Auth_V1beta1_BaseAccount()}
    set {_baseAccount = newValue}
  }
  /// Returns true if `baseAccount` has been explicitly set.
  var hasBaseAccount: Bool {return self._baseAccount != nil}
  /// Clears the value of `baseAccount`. Subsequent reads from it will return its default value.
  mutating func clearBaseAccount() {self._baseAccount = nil}

  /// Address that owns the marker configuration.  This account must sign any requests
  /// to change marker config (only valid for statuses prior to finalization)
  var manager: String = String()

  /// Access control lists
  var accessControl: [Provenance_Marker_V1_AccessGrant] = []

  /// Indicates the current status of this marker record.
  var status: Provenance_Marker_V1_MarkerStatus = .unspecified

  /// value denomination and total supply for the token.
  var denom: String = String()

  /// the total supply expected for a marker.  This is the amount that is minted when a marker is created.
  var supply: String = String()

  /// Marker type information
  var markerType: Provenance_Marker_V1_MarkerType = .unspecified

  /// A fixed supply will mint additional coin automatically if the total supply decreases below a set value.  This
  /// may occur if the coin is burned or an account holding the coin is slashed. (default: true)
  var supplyFixed: Bool = false

  /// indicates that governance based control is allowed for this marker
  var allowGovernanceControl: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseAccount: Cosmos_Auth_V1beta1_BaseAccount? = nil
}

/// EventMarkerAdd event emitted when marker is added
struct Provenance_Marker_V1_EventMarkerAdd {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var amount: String = String()

  var status: String = String()

  var manager: String = String()

  var markerType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventMarkerAddAccess event emitted when marker access is added
struct Provenance_Marker_V1_EventMarkerAddAccess {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var access: Provenance_Marker_V1_EventMarkerAccess {
    get {return _access ?? Provenance_Marker_V1_EventMarkerAccess()}
    set {_access = newValue}
  }
  /// Returns true if `access` has been explicitly set.
  var hasAccess: Bool {return self._access != nil}
  /// Clears the value of `access`. Subsequent reads from it will return its default value.
  mutating func clearAccess() {self._access = nil}

  var denom: String = String()

  var administrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _access: Provenance_Marker_V1_EventMarkerAccess? = nil
}

/// EventMarkerAccess event access permissions for address
struct Provenance_Marker_V1_EventMarkerAccess {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var permissions: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventMarkerDeleteAccess event emitted when marker access is revoked
struct Provenance_Marker_V1_EventMarkerDeleteAccess {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var removeAddress: String = String()

  var denom: String = String()

  var administrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventMarkerFinalize event emitted when marker is finalized
struct Provenance_Marker_V1_EventMarkerFinalize {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var administrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventMarkerActivate event emitted when marker is activated
struct Provenance_Marker_V1_EventMarkerActivate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var administrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventMarkerCancel event emitted when marker is cancelled
struct Provenance_Marker_V1_EventMarkerCancel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var administrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventMarkerDelete event emitted when marker is deleted
struct Provenance_Marker_V1_EventMarkerDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var administrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventMarkerMint event emitted when additional marker supply is minted
struct Provenance_Marker_V1_EventMarkerMint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: String = String()

  var denom: String = String()

  var administrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventMarkerBurn event emitted when coin is burned from marker
struct Provenance_Marker_V1_EventMarkerBurn {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: String = String()

  var denom: String = String()

  var administrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventMarkerWithdraw event emitted when coins are withdrew from marker
struct Provenance_Marker_V1_EventMarkerWithdraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var coins: String = String()

  var denom: String = String()

  var administrator: String = String()

  var toAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventMarkerTransfer event emitted when coins are transfered to from account to another
struct Provenance_Marker_V1_EventMarkerTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amount: String = String()

  var denom: String = String()

  var administrator: String = String()

  var toAddress: String = String()

  var fromAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventMarkerSetDenomMetadata event emitted when metadata is set on marker with denom
struct Provenance_Marker_V1_EventMarkerSetDenomMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadataBase: String = String()

  var metadataDescription: String = String()

  var metadataDisplay: String = String()

  var metadataDenomUnits: [Provenance_Marker_V1_EventDenomUnit] = []

  var administrator: String = String()

  var metadataName: String = String()

  var metadataSymbol: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventDenomUnit denom units for set denom metadata event
struct Provenance_Marker_V1_EventDenomUnit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var exponent: String = String()

  var aliases: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "provenance.marker.v1"

extension Provenance_Marker_V1_MarkerType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MARKER_TYPE_UNSPECIFIED"),
    1: .same(proto: "MARKER_TYPE_COIN"),
    2: .same(proto: "MARKER_TYPE_RESTRICTED"),
  ]
}

extension Provenance_Marker_V1_MarkerStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MARKER_STATUS_UNSPECIFIED"),
    1: .same(proto: "MARKER_STATUS_PROPOSED"),
    2: .same(proto: "MARKER_STATUS_FINALIZED"),
    3: .same(proto: "MARKER_STATUS_ACTIVE"),
    4: .same(proto: "MARKER_STATUS_CANCELLED"),
    5: .same(proto: "MARKER_STATUS_DESTROYED"),
  ]
}

extension Provenance_Marker_V1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_total_supply"),
    2: .standard(proto: "enable_governance"),
    3: .standard(proto: "unrestricted_denom_regex"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.maxTotalSupply) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enableGovernance) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.unrestrictedDenomRegex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxTotalSupply != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxTotalSupply, fieldNumber: 1)
    }
    if self.enableGovernance != false {
      try visitor.visitSingularBoolField(value: self.enableGovernance, fieldNumber: 2)
    }
    if !self.unrestrictedDenomRegex.isEmpty {
      try visitor.visitSingularStringField(value: self.unrestrictedDenomRegex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_Params, rhs: Provenance_Marker_V1_Params) -> Bool {
    if lhs.maxTotalSupply != rhs.maxTotalSupply {return false}
    if lhs.enableGovernance != rhs.enableGovernance {return false}
    if lhs.unrestrictedDenomRegex != rhs.unrestrictedDenomRegex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_MarkerAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MarkerAccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_account"),
    2: .same(proto: "manager"),
    3: .standard(proto: "access_control"),
    4: .same(proto: "status"),
    5: .same(proto: "denom"),
    6: .same(proto: "supply"),
    7: .standard(proto: "marker_type"),
    8: .standard(proto: "supply_fixed"),
    9: .standard(proto: "allow_governance_control"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseAccount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.manager) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.accessControl) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.supply) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.markerType) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.supplyFixed) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.allowGovernanceControl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._baseAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.manager.isEmpty {
      try visitor.visitSingularStringField(value: self.manager, fieldNumber: 2)
    }
    if !self.accessControl.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accessControl, fieldNumber: 3)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 5)
    }
    if !self.supply.isEmpty {
      try visitor.visitSingularStringField(value: self.supply, fieldNumber: 6)
    }
    if self.markerType != .unspecified {
      try visitor.visitSingularEnumField(value: self.markerType, fieldNumber: 7)
    }
    if self.supplyFixed != false {
      try visitor.visitSingularBoolField(value: self.supplyFixed, fieldNumber: 8)
    }
    if self.allowGovernanceControl != false {
      try visitor.visitSingularBoolField(value: self.allowGovernanceControl, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_MarkerAccount, rhs: Provenance_Marker_V1_MarkerAccount) -> Bool {
    if lhs._baseAccount != rhs._baseAccount {return false}
    if lhs.manager != rhs.manager {return false}
    if lhs.accessControl != rhs.accessControl {return false}
    if lhs.status != rhs.status {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.supply != rhs.supply {return false}
    if lhs.markerType != rhs.markerType {return false}
    if lhs.supplyFixed != rhs.supplyFixed {return false}
    if lhs.allowGovernanceControl != rhs.allowGovernanceControl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_EventMarkerAdd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMarkerAdd"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "amount"),
    3: .same(proto: "status"),
    4: .same(proto: "manager"),
    5: .standard(proto: "marker_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.manager) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.markerType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 3)
    }
    if !self.manager.isEmpty {
      try visitor.visitSingularStringField(value: self.manager, fieldNumber: 4)
    }
    if !self.markerType.isEmpty {
      try visitor.visitSingularStringField(value: self.markerType, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_EventMarkerAdd, rhs: Provenance_Marker_V1_EventMarkerAdd) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.status != rhs.status {return false}
    if lhs.manager != rhs.manager {return false}
    if lhs.markerType != rhs.markerType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_EventMarkerAddAccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMarkerAddAccess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "access"),
    2: .same(proto: "denom"),
    3: .same(proto: "administrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._access) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._access {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_EventMarkerAddAccess, rhs: Provenance_Marker_V1_EventMarkerAddAccess) -> Bool {
    if lhs._access != rhs._access {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_EventMarkerAccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMarkerAccess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "permissions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.permissions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.permissions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.permissions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_EventMarkerAccess, rhs: Provenance_Marker_V1_EventMarkerAccess) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_EventMarkerDeleteAccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMarkerDeleteAccess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "remove_address"),
    2: .same(proto: "denom"),
    3: .same(proto: "administrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.removeAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.removeAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.removeAddress, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_EventMarkerDeleteAccess, rhs: Provenance_Marker_V1_EventMarkerDeleteAccess) -> Bool {
    if lhs.removeAddress != rhs.removeAddress {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_EventMarkerFinalize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMarkerFinalize"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "administrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_EventMarkerFinalize, rhs: Provenance_Marker_V1_EventMarkerFinalize) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_EventMarkerActivate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMarkerActivate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "administrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_EventMarkerActivate, rhs: Provenance_Marker_V1_EventMarkerActivate) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_EventMarkerCancel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMarkerCancel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "administrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_EventMarkerCancel, rhs: Provenance_Marker_V1_EventMarkerCancel) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_EventMarkerDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMarkerDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "administrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_EventMarkerDelete, rhs: Provenance_Marker_V1_EventMarkerDelete) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_EventMarkerMint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMarkerMint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "denom"),
    3: .same(proto: "administrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_EventMarkerMint, rhs: Provenance_Marker_V1_EventMarkerMint) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_EventMarkerBurn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMarkerBurn"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "denom"),
    3: .same(proto: "administrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_EventMarkerBurn, rhs: Provenance_Marker_V1_EventMarkerBurn) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_EventMarkerWithdraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMarkerWithdraw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coins"),
    2: .same(proto: "denom"),
    3: .same(proto: "administrator"),
    4: .standard(proto: "to_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.coins) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.toAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.coins.isEmpty {
      try visitor.visitSingularStringField(value: self.coins, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 3)
    }
    if !self.toAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.toAddress, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_EventMarkerWithdraw, rhs: Provenance_Marker_V1_EventMarkerWithdraw) -> Bool {
    if lhs.coins != rhs.coins {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_EventMarkerTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMarkerTransfer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "denom"),
    3: .same(proto: "administrator"),
    4: .standard(proto: "to_address"),
    5: .standard(proto: "from_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.toAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.fromAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 3)
    }
    if !self.toAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.toAddress, fieldNumber: 4)
    }
    if !self.fromAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.fromAddress, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_EventMarkerTransfer, rhs: Provenance_Marker_V1_EventMarkerTransfer) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.fromAddress != rhs.fromAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_EventMarkerSetDenomMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventMarkerSetDenomMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metadata_base"),
    2: .standard(proto: "metadata_description"),
    3: .standard(proto: "metadata_display"),
    4: .standard(proto: "metadata_denom_units"),
    5: .same(proto: "administrator"),
    6: .standard(proto: "metadata_name"),
    7: .standard(proto: "metadata_symbol"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.metadataBase) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.metadataDescription) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.metadataDisplay) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.metadataDenomUnits) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.administrator) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.metadataName) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.metadataSymbol) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metadataBase.isEmpty {
      try visitor.visitSingularStringField(value: self.metadataBase, fieldNumber: 1)
    }
    if !self.metadataDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.metadataDescription, fieldNumber: 2)
    }
    if !self.metadataDisplay.isEmpty {
      try visitor.visitSingularStringField(value: self.metadataDisplay, fieldNumber: 3)
    }
    if !self.metadataDenomUnits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadataDenomUnits, fieldNumber: 4)
    }
    if !self.administrator.isEmpty {
      try visitor.visitSingularStringField(value: self.administrator, fieldNumber: 5)
    }
    if !self.metadataName.isEmpty {
      try visitor.visitSingularStringField(value: self.metadataName, fieldNumber: 6)
    }
    if !self.metadataSymbol.isEmpty {
      try visitor.visitSingularStringField(value: self.metadataSymbol, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_EventMarkerSetDenomMetadata, rhs: Provenance_Marker_V1_EventMarkerSetDenomMetadata) -> Bool {
    if lhs.metadataBase != rhs.metadataBase {return false}
    if lhs.metadataDescription != rhs.metadataDescription {return false}
    if lhs.metadataDisplay != rhs.metadataDisplay {return false}
    if lhs.metadataDenomUnits != rhs.metadataDenomUnits {return false}
    if lhs.administrator != rhs.administrator {return false}
    if lhs.metadataName != rhs.metadataName {return false}
    if lhs.metadataSymbol != rhs.metadataSymbol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Marker_V1_EventDenomUnit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventDenomUnit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "exponent"),
    3: .same(proto: "aliases"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.exponent) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.aliases) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.exponent.isEmpty {
      try visitor.visitSingularStringField(value: self.exponent, fieldNumber: 2)
    }
    if !self.aliases.isEmpty {
      try visitor.visitRepeatedStringField(value: self.aliases, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Marker_V1_EventDenomUnit, rhs: Provenance_Marker_V1_EventDenomUnit) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.exponent != rhs.exponent {return false}
    if lhs.aliases != rhs.aliases {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
