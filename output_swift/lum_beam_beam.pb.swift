// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: lum/beam/beam.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Lum_Network_Beam_BeamState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case `open` // = 1
  case canceled // = 2
  case closed // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .open
    case 2: self = .canceled
    case 3: self = .closed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .open: return 1
    case .canceled: return 2
    case .closed: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Lum_Network_Beam_BeamState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lum_Network_Beam_BeamState] = [
    .unspecified,
    .open,
    .canceled,
    .closed,
  ]
}

#endif  // swift(>=4.2)

struct Lum_Network_Beam_BeamMedia {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mimetype: String = String()

  var url: String = String()

  var thumbnailURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lum_Network_Beam_BeamReviewer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reviewerID: String = String()

  var name: String = String()

  var isAnonymous: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lum_Network_Beam_BeamVerifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var url: String = String()

  var signature: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lum_Network_Beam_BeamReward {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var trigger: String = String()

  var amount: Float = 0

  var maxAmount: Float = 0

  var currency: String = String()

  var status: String = String()

  var details: [Lum_Network_Beam_BeamReward.BeamRewardDetails] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct BeamRewardDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: String = String()

    var amount: Float = 0

    var maxAmount: Float = 0

    var status: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Lum_Network_Beam_BeamMerchantReview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderID: String = String()

  var reviewID: String = String()

  var merchantURL: String = String()

  var ratingURL: String = String()

  var reviewURL: String = String()

  var collectionMethod: String = String()

  var timestamp: String = String()

  var ratings: Lum_Network_Beam_BeamMerchantReview.BeamMerchantReviewRating {
    get {return _ratings ?? Lum_Network_Beam_BeamMerchantReview.BeamMerchantReviewRating()}
    set {_ratings = newValue}
  }
  /// Returns true if `ratings` has been explicitly set.
  var hasRatings: Bool {return self._ratings != nil}
  /// Clears the value of `ratings`. Subsequent reads from it will return its default value.
  mutating func clearRatings() {self._ratings = nil}

  var title: String = String()

  var content: Lum_Network_Beam_BeamMerchantReview.BeamMerchantReviewContent {
    get {return _content ?? Lum_Network_Beam_BeamMerchantReview.BeamMerchantReviewContent()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  mutating func clearContent() {self._content = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct BeamMerchantReviewRating {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var overall: Float = 0

    var customerService: Float = 0

    var nps: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BeamMerchantReviewContent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var overall: String = String()

    var customerService: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _ratings: Lum_Network_Beam_BeamMerchantReview.BeamMerchantReviewRating? = nil
  fileprivate var _content: Lum_Network_Beam_BeamMerchantReview.BeamMerchantReviewContent? = nil
}

struct Lum_Network_Beam_BeamProductReview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orderID: String = String()

  var reviewID: String = String()

  var ratingURL: String = String()

  var reviewURL: String = String()

  var collectionMethod: String = String()

  var timestamp: String = String()

  var ratings: Lum_Network_Beam_BeamProductReview.BeamProductReviewRating {
    get {return _ratings ?? Lum_Network_Beam_BeamProductReview.BeamProductReviewRating()}
    set {_ratings = newValue}
  }
  /// Returns true if `ratings` has been explicitly set.
  var hasRatings: Bool {return self._ratings != nil}
  /// Clears the value of `ratings`. Subsequent reads from it will return its default value.
  mutating func clearRatings() {self._ratings = nil}

  var title: String = String()

  var content: Lum_Network_Beam_BeamProductReview.BeamProductReviewContent {
    get {return _content ?? Lum_Network_Beam_BeamProductReview.BeamProductReviewContent()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  mutating func clearContent() {self._content = nil}

  var medias: [Lum_Network_Beam_BeamMedia] = []

  var products: [Lum_Network_Beam_BeamProductReview.BeamProduct] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct BeamProductReviewRating {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var overall: Float = 0

    var quality: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BeamProductReviewContent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var overall: String = String()

    var pros: String = String()

    var cons: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BeamProduct {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var url: String = String()

    var urls: [String] = []

    var ids: Lum_Network_Beam_BeamProductReview.BeamProduct.BeamProductIds {
      get {return _ids ?? Lum_Network_Beam_BeamProductReview.BeamProduct.BeamProductIds()}
      set {_ids = newValue}
    }
    /// Returns true if `ids` has been explicitly set.
    var hasIds: Bool {return self._ids != nil}
    /// Clears the value of `ids`. Subsequent reads from it will return its default value.
    mutating func clearIds() {self._ids = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct BeamProductIds {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var gtins: [String] = []

      var mpns: [String] = []

      var skus: [String] = []

      var asins: [String] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _ids: Lum_Network_Beam_BeamProductReview.BeamProduct.BeamProductIds? = nil
  }

  init() {}

  fileprivate var _ratings: Lum_Network_Beam_BeamProductReview.BeamProductReviewRating? = nil
  fileprivate var _content: Lum_Network_Beam_BeamProductReview.BeamProductReviewContent? = nil
}

struct Lum_Network_Beam_BeamData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reward: Lum_Network_Beam_BeamReward {
    get {return _storage._reward ?? Lum_Network_Beam_BeamReward()}
    set {_uniqueStorage()._reward = newValue}
  }
  /// Returns true if `reward` has been explicitly set.
  var hasReward: Bool {return _storage._reward != nil}
  /// Clears the value of `reward`. Subsequent reads from it will return its default value.
  mutating func clearReward() {_uniqueStorage()._reward = nil}

  var verifier: Lum_Network_Beam_BeamVerifier {
    get {return _storage._verifier ?? Lum_Network_Beam_BeamVerifier()}
    set {_uniqueStorage()._verifier = newValue}
  }
  /// Returns true if `verifier` has been explicitly set.
  var hasVerifier: Bool {return _storage._verifier != nil}
  /// Clears the value of `verifier`. Subsequent reads from it will return its default value.
  mutating func clearVerifier() {_uniqueStorage()._verifier = nil}

  var reviewer: Lum_Network_Beam_BeamReviewer {
    get {return _storage._reviewer ?? Lum_Network_Beam_BeamReviewer()}
    set {_uniqueStorage()._reviewer = newValue}
  }
  /// Returns true if `reviewer` has been explicitly set.
  var hasReviewer: Bool {return _storage._reviewer != nil}
  /// Clears the value of `reviewer`. Subsequent reads from it will return its default value.
  mutating func clearReviewer() {_uniqueStorage()._reviewer = nil}

  var merchantReview: Lum_Network_Beam_BeamMerchantReview {
    get {return _storage._merchantReview ?? Lum_Network_Beam_BeamMerchantReview()}
    set {_uniqueStorage()._merchantReview = newValue}
  }
  /// Returns true if `merchantReview` has been explicitly set.
  var hasMerchantReview: Bool {return _storage._merchantReview != nil}
  /// Clears the value of `merchantReview`. Subsequent reads from it will return its default value.
  mutating func clearMerchantReview() {_uniqueStorage()._merchantReview = nil}

  var productsReviews: [Lum_Network_Beam_BeamProductReview] {
    get {return _storage._productsReviews}
    set {_uniqueStorage()._productsReviews = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lum_Network_Beam_Beam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var creatorAddress: String {
    get {return _storage._creatorAddress}
    set {_uniqueStorage()._creatorAddress = newValue}
  }

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _storage._amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {_uniqueStorage()._amount = nil}

  var status: Lum_Network_Beam_BeamState {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var secret: String {
    get {return _storage._secret}
    set {_uniqueStorage()._secret = newValue}
  }

  var claimAddress: String {
    get {return _storage._claimAddress}
    set {_uniqueStorage()._claimAddress = newValue}
  }

  var fundsWithdrawn: Bool {
    get {return _storage._fundsWithdrawn}
    set {_uniqueStorage()._fundsWithdrawn = newValue}
  }

  var claimed: Bool {
    get {return _storage._claimed}
    set {_uniqueStorage()._claimed = newValue}
  }

  var cancelReason: String {
    get {return _storage._cancelReason}
    set {_uniqueStorage()._cancelReason = newValue}
  }

  var hideContent: Bool {
    get {return _storage._hideContent}
    set {_uniqueStorage()._hideContent = newValue}
  }

  var schema: String {
    get {return _storage._schema}
    set {_uniqueStorage()._schema = newValue}
  }

  var data: Lum_Network_Beam_BeamData {
    get {return _storage._data ?? Lum_Network_Beam_BeamData()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {_uniqueStorage()._data = nil}

  var claimExpiresAtBlock: Int32 {
    get {return _storage._claimExpiresAtBlock}
    set {_uniqueStorage()._claimExpiresAtBlock = newValue}
  }

  var closesAtBlock: Int32 {
    get {return _storage._closesAtBlock}
    set {_uniqueStorage()._closesAtBlock = newValue}
  }

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  var closedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._closedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._closedAt = newValue}
  }
  /// Returns true if `closedAt` has been explicitly set.
  var hasClosedAt: Bool {return _storage._closedAt != nil}
  /// Clears the value of `closedAt`. Subsequent reads from it will return its default value.
  mutating func clearClosedAt() {_uniqueStorage()._closedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "lum.network.beam"

extension Lum_Network_Beam_BeamState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "OPEN"),
    2: .same(proto: "CANCELED"),
    3: .same(proto: "CLOSED"),
  ]
}

extension Lum_Network_Beam_BeamMedia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeamMedia"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mimetype"),
    2: .same(proto: "url"),
    3: .standard(proto: "thumbnail_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mimetype) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.thumbnailURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mimetype.isEmpty {
      try visitor.visitSingularStringField(value: self.mimetype, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if !self.thumbnailURL.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lum_Network_Beam_BeamMedia, rhs: Lum_Network_Beam_BeamMedia) -> Bool {
    if lhs.mimetype != rhs.mimetype {return false}
    if lhs.url != rhs.url {return false}
    if lhs.thumbnailURL != rhs.thumbnailURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lum_Network_Beam_BeamReviewer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeamReviewer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reviewer_id"),
    2: .same(proto: "name"),
    3: .standard(proto: "is_anonymous"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reviewerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isAnonymous) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reviewerID.isEmpty {
      try visitor.visitSingularStringField(value: self.reviewerID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.isAnonymous != false {
      try visitor.visitSingularBoolField(value: self.isAnonymous, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lum_Network_Beam_BeamReviewer, rhs: Lum_Network_Beam_BeamReviewer) -> Bool {
    if lhs.reviewerID != rhs.reviewerID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.isAnonymous != rhs.isAnonymous {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lum_Network_Beam_BeamVerifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeamVerifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "url"),
    3: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lum_Network_Beam_BeamVerifier, rhs: Lum_Network_Beam_BeamVerifier) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lum_Network_Beam_BeamReward: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeamReward"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trigger"),
    2: .same(proto: "amount"),
    3: .standard(proto: "max_amount"),
    4: .same(proto: "currency"),
    5: .same(proto: "status"),
    6: .same(proto: "details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trigger) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.maxAmount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.currency) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.details) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trigger.isEmpty {
      try visitor.visitSingularStringField(value: self.trigger, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularFloatField(value: self.amount, fieldNumber: 2)
    }
    if self.maxAmount != 0 {
      try visitor.visitSingularFloatField(value: self.maxAmount, fieldNumber: 3)
    }
    if !self.currency.isEmpty {
      try visitor.visitSingularStringField(value: self.currency, fieldNumber: 4)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 5)
    }
    if !self.details.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.details, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lum_Network_Beam_BeamReward, rhs: Lum_Network_Beam_BeamReward) -> Bool {
    if lhs.trigger != rhs.trigger {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.maxAmount != rhs.maxAmount {return false}
    if lhs.currency != rhs.currency {return false}
    if lhs.status != rhs.status {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lum_Network_Beam_BeamReward.BeamRewardDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lum_Network_Beam_BeamReward.protoMessageName + ".BeamRewardDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "amount"),
    3: .standard(proto: "max_amount"),
    4: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.maxAmount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularFloatField(value: self.amount, fieldNumber: 2)
    }
    if self.maxAmount != 0 {
      try visitor.visitSingularFloatField(value: self.maxAmount, fieldNumber: 3)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lum_Network_Beam_BeamReward.BeamRewardDetails, rhs: Lum_Network_Beam_BeamReward.BeamRewardDetails) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.maxAmount != rhs.maxAmount {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lum_Network_Beam_BeamMerchantReview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeamMerchantReview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_id"),
    2: .standard(proto: "review_id"),
    3: .standard(proto: "merchant_url"),
    4: .standard(proto: "rating_url"),
    5: .standard(proto: "review_url"),
    6: .standard(proto: "collection_method"),
    7: .same(proto: "timestamp"),
    8: .same(proto: "ratings"),
    9: .same(proto: "title"),
    10: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orderID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reviewID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.merchantURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ratingURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.reviewURL) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.collectionMethod) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.timestamp) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._ratings) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderID.isEmpty {
      try visitor.visitSingularStringField(value: self.orderID, fieldNumber: 1)
    }
    if !self.reviewID.isEmpty {
      try visitor.visitSingularStringField(value: self.reviewID, fieldNumber: 2)
    }
    if !self.merchantURL.isEmpty {
      try visitor.visitSingularStringField(value: self.merchantURL, fieldNumber: 3)
    }
    if !self.ratingURL.isEmpty {
      try visitor.visitSingularStringField(value: self.ratingURL, fieldNumber: 4)
    }
    if !self.reviewURL.isEmpty {
      try visitor.visitSingularStringField(value: self.reviewURL, fieldNumber: 5)
    }
    if !self.collectionMethod.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionMethod, fieldNumber: 6)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitSingularStringField(value: self.timestamp, fieldNumber: 7)
    }
    if let v = self._ratings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 9)
    }
    if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lum_Network_Beam_BeamMerchantReview, rhs: Lum_Network_Beam_BeamMerchantReview) -> Bool {
    if lhs.orderID != rhs.orderID {return false}
    if lhs.reviewID != rhs.reviewID {return false}
    if lhs.merchantURL != rhs.merchantURL {return false}
    if lhs.ratingURL != rhs.ratingURL {return false}
    if lhs.reviewURL != rhs.reviewURL {return false}
    if lhs.collectionMethod != rhs.collectionMethod {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._ratings != rhs._ratings {return false}
    if lhs.title != rhs.title {return false}
    if lhs._content != rhs._content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lum_Network_Beam_BeamMerchantReview.BeamMerchantReviewRating: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lum_Network_Beam_BeamMerchantReview.protoMessageName + ".BeamMerchantReviewRating"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "overall"),
    2: .standard(proto: "customer_service"),
    3: .same(proto: "nps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.overall) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.customerService) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.nps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.overall != 0 {
      try visitor.visitSingularFloatField(value: self.overall, fieldNumber: 1)
    }
    if self.customerService != 0 {
      try visitor.visitSingularFloatField(value: self.customerService, fieldNumber: 2)
    }
    if self.nps != 0 {
      try visitor.visitSingularFloatField(value: self.nps, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lum_Network_Beam_BeamMerchantReview.BeamMerchantReviewRating, rhs: Lum_Network_Beam_BeamMerchantReview.BeamMerchantReviewRating) -> Bool {
    if lhs.overall != rhs.overall {return false}
    if lhs.customerService != rhs.customerService {return false}
    if lhs.nps != rhs.nps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lum_Network_Beam_BeamMerchantReview.BeamMerchantReviewContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lum_Network_Beam_BeamMerchantReview.protoMessageName + ".BeamMerchantReviewContent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "overall"),
    2: .standard(proto: "customer_service"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.overall) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.customerService) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.overall.isEmpty {
      try visitor.visitSingularStringField(value: self.overall, fieldNumber: 1)
    }
    if !self.customerService.isEmpty {
      try visitor.visitSingularStringField(value: self.customerService, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lum_Network_Beam_BeamMerchantReview.BeamMerchantReviewContent, rhs: Lum_Network_Beam_BeamMerchantReview.BeamMerchantReviewContent) -> Bool {
    if lhs.overall != rhs.overall {return false}
    if lhs.customerService != rhs.customerService {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lum_Network_Beam_BeamProductReview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeamProductReview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_id"),
    2: .standard(proto: "review_id"),
    3: .standard(proto: "rating_url"),
    4: .standard(proto: "review_url"),
    5: .standard(proto: "collection_method"),
    6: .same(proto: "timestamp"),
    7: .same(proto: "ratings"),
    8: .same(proto: "title"),
    9: .same(proto: "content"),
    10: .same(proto: "medias"),
    11: .same(proto: "products"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orderID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reviewID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ratingURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reviewURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.collectionMethod) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.timestamp) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._ratings) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.medias) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.products) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderID.isEmpty {
      try visitor.visitSingularStringField(value: self.orderID, fieldNumber: 1)
    }
    if !self.reviewID.isEmpty {
      try visitor.visitSingularStringField(value: self.reviewID, fieldNumber: 2)
    }
    if !self.ratingURL.isEmpty {
      try visitor.visitSingularStringField(value: self.ratingURL, fieldNumber: 3)
    }
    if !self.reviewURL.isEmpty {
      try visitor.visitSingularStringField(value: self.reviewURL, fieldNumber: 4)
    }
    if !self.collectionMethod.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionMethod, fieldNumber: 5)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitSingularStringField(value: self.timestamp, fieldNumber: 6)
    }
    if let v = self._ratings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 8)
    }
    if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if !self.medias.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.medias, fieldNumber: 10)
    }
    if !self.products.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.products, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lum_Network_Beam_BeamProductReview, rhs: Lum_Network_Beam_BeamProductReview) -> Bool {
    if lhs.orderID != rhs.orderID {return false}
    if lhs.reviewID != rhs.reviewID {return false}
    if lhs.ratingURL != rhs.ratingURL {return false}
    if lhs.reviewURL != rhs.reviewURL {return false}
    if lhs.collectionMethod != rhs.collectionMethod {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._ratings != rhs._ratings {return false}
    if lhs.title != rhs.title {return false}
    if lhs._content != rhs._content {return false}
    if lhs.medias != rhs.medias {return false}
    if lhs.products != rhs.products {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lum_Network_Beam_BeamProductReview.BeamProductReviewRating: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lum_Network_Beam_BeamProductReview.protoMessageName + ".BeamProductReviewRating"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "overall"),
    2: .same(proto: "quality"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.overall) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.quality) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.overall != 0 {
      try visitor.visitSingularFloatField(value: self.overall, fieldNumber: 1)
    }
    if self.quality != 0 {
      try visitor.visitSingularFloatField(value: self.quality, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lum_Network_Beam_BeamProductReview.BeamProductReviewRating, rhs: Lum_Network_Beam_BeamProductReview.BeamProductReviewRating) -> Bool {
    if lhs.overall != rhs.overall {return false}
    if lhs.quality != rhs.quality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lum_Network_Beam_BeamProductReview.BeamProductReviewContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lum_Network_Beam_BeamProductReview.protoMessageName + ".BeamProductReviewContent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "overall"),
    2: .same(proto: "pros"),
    3: .same(proto: "cons"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.overall) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pros) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cons) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.overall.isEmpty {
      try visitor.visitSingularStringField(value: self.overall, fieldNumber: 1)
    }
    if !self.pros.isEmpty {
      try visitor.visitSingularStringField(value: self.pros, fieldNumber: 2)
    }
    if !self.cons.isEmpty {
      try visitor.visitSingularStringField(value: self.cons, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lum_Network_Beam_BeamProductReview.BeamProductReviewContent, rhs: Lum_Network_Beam_BeamProductReview.BeamProductReviewContent) -> Bool {
    if lhs.overall != rhs.overall {return false}
    if lhs.pros != rhs.pros {return false}
    if lhs.cons != rhs.cons {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lum_Network_Beam_BeamProductReview.BeamProduct: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lum_Network_Beam_BeamProductReview.protoMessageName + ".BeamProduct"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "url"),
    3: .same(proto: "urls"),
    4: .same(proto: "ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.urls) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if !self.urls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.urls, fieldNumber: 3)
    }
    if let v = self._ids {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lum_Network_Beam_BeamProductReview.BeamProduct, rhs: Lum_Network_Beam_BeamProductReview.BeamProduct) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.urls != rhs.urls {return false}
    if lhs._ids != rhs._ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lum_Network_Beam_BeamProductReview.BeamProduct.BeamProductIds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lum_Network_Beam_BeamProductReview.BeamProduct.protoMessageName + ".BeamProductIds"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gtins"),
    2: .same(proto: "mpns"),
    3: .same(proto: "skus"),
    4: .same(proto: "asins"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.gtins) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.mpns) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.skus) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.asins) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gtins.isEmpty {
      try visitor.visitRepeatedStringField(value: self.gtins, fieldNumber: 1)
    }
    if !self.mpns.isEmpty {
      try visitor.visitRepeatedStringField(value: self.mpns, fieldNumber: 2)
    }
    if !self.skus.isEmpty {
      try visitor.visitRepeatedStringField(value: self.skus, fieldNumber: 3)
    }
    if !self.asins.isEmpty {
      try visitor.visitRepeatedStringField(value: self.asins, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lum_Network_Beam_BeamProductReview.BeamProduct.BeamProductIds, rhs: Lum_Network_Beam_BeamProductReview.BeamProduct.BeamProductIds) -> Bool {
    if lhs.gtins != rhs.gtins {return false}
    if lhs.mpns != rhs.mpns {return false}
    if lhs.skus != rhs.skus {return false}
    if lhs.asins != rhs.asins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lum_Network_Beam_BeamData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeamData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reward"),
    2: .same(proto: "verifier"),
    3: .same(proto: "reviewer"),
    4: .standard(proto: "merchant_review"),
    5: .standard(proto: "products_reviews"),
  ]

  fileprivate class _StorageClass {
    var _reward: Lum_Network_Beam_BeamReward? = nil
    var _verifier: Lum_Network_Beam_BeamVerifier? = nil
    var _reviewer: Lum_Network_Beam_BeamReviewer? = nil
    var _merchantReview: Lum_Network_Beam_BeamMerchantReview? = nil
    var _productsReviews: [Lum_Network_Beam_BeamProductReview] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _reward = source._reward
      _verifier = source._verifier
      _reviewer = source._reviewer
      _merchantReview = source._merchantReview
      _productsReviews = source._productsReviews
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._reward) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._verifier) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._reviewer) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._merchantReview) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._productsReviews) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._reward {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._verifier {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._reviewer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._merchantReview {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._productsReviews.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._productsReviews, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lum_Network_Beam_BeamData, rhs: Lum_Network_Beam_BeamData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._reward != rhs_storage._reward {return false}
        if _storage._verifier != rhs_storage._verifier {return false}
        if _storage._reviewer != rhs_storage._reviewer {return false}
        if _storage._merchantReview != rhs_storage._merchantReview {return false}
        if _storage._productsReviews != rhs_storage._productsReviews {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lum_Network_Beam_Beam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Beam"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "creator_address"),
    2: .same(proto: "id"),
    3: .same(proto: "amount"),
    4: .same(proto: "status"),
    5: .same(proto: "secret"),
    6: .standard(proto: "claim_address"),
    7: .standard(proto: "funds_withdrawn"),
    8: .same(proto: "claimed"),
    9: .standard(proto: "cancel_reason"),
    10: .standard(proto: "hide_content"),
    11: .same(proto: "schema"),
    12: .same(proto: "data"),
    13: .standard(proto: "claim_expires_at_block"),
    14: .standard(proto: "closes_at_block"),
    15: .standard(proto: "created_at"),
    16: .standard(proto: "closed_at"),
  ]

  fileprivate class _StorageClass {
    var _creatorAddress: String = String()
    var _id: String = String()
    var _amount: Cosmos_Base_V1beta1_Coin? = nil
    var _status: Lum_Network_Beam_BeamState = .unspecified
    var _secret: String = String()
    var _claimAddress: String = String()
    var _fundsWithdrawn: Bool = false
    var _claimed: Bool = false
    var _cancelReason: String = String()
    var _hideContent: Bool = false
    var _schema: String = String()
    var _data: Lum_Network_Beam_BeamData? = nil
    var _claimExpiresAtBlock: Int32 = 0
    var _closesAtBlock: Int32 = 0
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _closedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _creatorAddress = source._creatorAddress
      _id = source._id
      _amount = source._amount
      _status = source._status
      _secret = source._secret
      _claimAddress = source._claimAddress
      _fundsWithdrawn = source._fundsWithdrawn
      _claimed = source._claimed
      _cancelReason = source._cancelReason
      _hideContent = source._hideContent
      _schema = source._schema
      _data = source._data
      _claimExpiresAtBlock = source._claimExpiresAtBlock
      _closesAtBlock = source._closesAtBlock
      _createdAt = source._createdAt
      _closedAt = source._closedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._creatorAddress) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._amount) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._secret) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._claimAddress) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._fundsWithdrawn) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._claimed) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._cancelReason) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._hideContent) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._schema) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._claimExpiresAtBlock) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._closesAtBlock) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._closedAt) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._creatorAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._creatorAddress, fieldNumber: 1)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 2)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 4)
      }
      if !_storage._secret.isEmpty {
        try visitor.visitSingularStringField(value: _storage._secret, fieldNumber: 5)
      }
      if !_storage._claimAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._claimAddress, fieldNumber: 6)
      }
      if _storage._fundsWithdrawn != false {
        try visitor.visitSingularBoolField(value: _storage._fundsWithdrawn, fieldNumber: 7)
      }
      if _storage._claimed != false {
        try visitor.visitSingularBoolField(value: _storage._claimed, fieldNumber: 8)
      }
      if !_storage._cancelReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cancelReason, fieldNumber: 9)
      }
      if _storage._hideContent != false {
        try visitor.visitSingularBoolField(value: _storage._hideContent, fieldNumber: 10)
      }
      if !_storage._schema.isEmpty {
        try visitor.visitSingularStringField(value: _storage._schema, fieldNumber: 11)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if _storage._claimExpiresAtBlock != 0 {
        try visitor.visitSingularInt32Field(value: _storage._claimExpiresAtBlock, fieldNumber: 13)
      }
      if _storage._closesAtBlock != 0 {
        try visitor.visitSingularInt32Field(value: _storage._closesAtBlock, fieldNumber: 14)
      }
      if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._closedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lum_Network_Beam_Beam, rhs: Lum_Network_Beam_Beam) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._creatorAddress != rhs_storage._creatorAddress {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._secret != rhs_storage._secret {return false}
        if _storage._claimAddress != rhs_storage._claimAddress {return false}
        if _storage._fundsWithdrawn != rhs_storage._fundsWithdrawn {return false}
        if _storage._claimed != rhs_storage._claimed {return false}
        if _storage._cancelReason != rhs_storage._cancelReason {return false}
        if _storage._hideContent != rhs_storage._hideContent {return false}
        if _storage._schema != rhs_storage._schema {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._claimExpiresAtBlock != rhs_storage._claimExpiresAtBlock {return false}
        if _storage._closesAtBlock != rhs_storage._closesAtBlock {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._closedAt != rhs_storage._closedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
