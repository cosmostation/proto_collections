// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: injective/exchange/v1beta1/exchange.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Injective_Exchange_V1beta1_MarketStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case active // = 1
  case paused // = 2
  case suspended // = 3
  case demolished // = 4
  case expired // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .active
    case 2: self = .paused
    case 3: self = .suspended
    case 4: self = .demolished
    case 5: self = .expired
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .active: return 1
    case .paused: return 2
    case .suspended: return 3
    case .demolished: return 4
    case .expired: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Injective_Exchange_V1beta1_MarketStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Injective_Exchange_V1beta1_MarketStatus] = [
    .unspecified,
    .active,
    .paused,
    .suspended,
    .demolished,
    .expired,
  ]
}

#endif  // swift(>=4.2)

enum Injective_Exchange_V1beta1_OrderType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case buy // = 1
  case sell // = 2
  case stopBuy // = 3
  case stopSell // = 4
  case takeBuy // = 5
  case takeSell // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .buy
    case 2: self = .sell
    case 3: self = .stopBuy
    case 4: self = .stopSell
    case 5: self = .takeBuy
    case 6: self = .takeSell
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .buy: return 1
    case .sell: return 2
    case .stopBuy: return 3
    case .stopSell: return 4
    case .takeBuy: return 5
    case .takeSell: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Injective_Exchange_V1beta1_OrderType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Injective_Exchange_V1beta1_OrderType] = [
    .unspecified,
    .buy,
    .sell,
    .stopBuy,
    .stopSell,
    .takeBuy,
    .takeSell,
  ]
}

#endif  // swift(>=4.2)

enum Injective_Exchange_V1beta1_ExecutionType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecifiedExecutionType // = 0
  case market // = 1
  case limitFill // = 2
  case limitMatchRestingOrder // = 3
  case limitMatchNewOrder // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecifiedExecutionType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecifiedExecutionType
    case 1: self = .market
    case 2: self = .limitFill
    case 3: self = .limitMatchRestingOrder
    case 4: self = .limitMatchNewOrder
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecifiedExecutionType: return 0
    case .market: return 1
    case .limitFill: return 2
    case .limitMatchRestingOrder: return 3
    case .limitMatchNewOrder: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Injective_Exchange_V1beta1_ExecutionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Injective_Exchange_V1beta1_ExecutionType] = [
    .unspecifiedExecutionType,
    .market,
    .limitFill,
    .limitMatchRestingOrder,
    .limitMatchNewOrder,
  ]
}

#endif  // swift(>=4.2)

struct Injective_Exchange_V1beta1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// spot_market_instant_listing_fee defines the expedited fee in INJ required to create a spot market by bypassing governance
  var spotMarketInstantListingFee: Cosmos_Base_V1beta1_Coin {
    get {return _spotMarketInstantListingFee ?? Cosmos_Base_V1beta1_Coin()}
    set {_spotMarketInstantListingFee = newValue}
  }
  /// Returns true if `spotMarketInstantListingFee` has been explicitly set.
  var hasSpotMarketInstantListingFee: Bool {return self._spotMarketInstantListingFee != nil}
  /// Clears the value of `spotMarketInstantListingFee`. Subsequent reads from it will return its default value.
  mutating func clearSpotMarketInstantListingFee() {self._spotMarketInstantListingFee = nil}

  /// derivative_market_instant_listing_fee defines the expedited fee in INJ required to create a derivative market by bypassing governance
  var derivativeMarketInstantListingFee: Cosmos_Base_V1beta1_Coin {
    get {return _derivativeMarketInstantListingFee ?? Cosmos_Base_V1beta1_Coin()}
    set {_derivativeMarketInstantListingFee = newValue}
  }
  /// Returns true if `derivativeMarketInstantListingFee` has been explicitly set.
  var hasDerivativeMarketInstantListingFee: Bool {return self._derivativeMarketInstantListingFee != nil}
  /// Clears the value of `derivativeMarketInstantListingFee`. Subsequent reads from it will return its default value.
  mutating func clearDerivativeMarketInstantListingFee() {self._derivativeMarketInstantListingFee = nil}

  /// default_spot_maker_fee defines the default exchange trade fee for makers on a spot market
  var defaultSpotMakerFeeRate: String = String()

  /// default_spot_taker_fee_rate defines the default exchange trade fee rate for takers on a new spot market
  var defaultSpotTakerFeeRate: String = String()

  /// default_derivative_maker_fee defines the default exchange trade fee for makers on a new derivative market
  var defaultDerivativeMakerFeeRate: String = String()

  /// default_derivative_taker_fee defines the default exchange trade fee for takers on a new derivative market
  var defaultDerivativeTakerFeeRate: String = String()

  /// default_initial_margin_ratio defines the default initial margin ratio on a new derivative market
  var defaultInitialMarginRatio: String = String()

  /// default_maintenance_margin_ratio defines the default maintenance margin ratio on a new derivative market
  var defaultMaintenanceMarginRatio: String = String()

  /// default_funding_interval defines the default funding interval on a derivative market
  var defaultFundingInterval: Int64 = 0

  /// funding_multiple defines the timestamp multiple that the funding timestamp should be a multiple of
  var fundingMultiple: Int64 = 0

  /// relayer_fee_share_rate defines the trade fee share percentage that goes to relayers
  var relayerFeeShareRate: String = String()

  /// default_hourly_funding_rate_cap defines the default maximum absolute value of the hourly funding rate
  var defaultHourlyFundingRateCap: String = String()

  /// hourly_interest_rate defines the hourly interest rate
  var defaultHourlyInterestRate: String = String()

  /// max_derivative_order_side_count defines the maximum number of derivative active orders a subaccount can have for a given orderbook side
  var maxDerivativeOrderSideCount: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _spotMarketInstantListingFee: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _derivativeMarketInstantListingFee: Cosmos_Base_V1beta1_Coin? = nil
}

/// An object describing a derivative market in the Injective Futures Protocol.
struct Injective_Exchange_V1beta1_DerivativeMarket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ticker for the derivative contract.
  var ticker: String = String()

  /// Oracle base currency
  var oracleBase: String = String()

  /// Oracle quote currency
  var oracleQuote: String = String()

  /// Oracle type
  var oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified

  /// Scale factor for oracle prices.
  var oracleScaleFactor: UInt32 = 0

  /// Address of the quote currency denomination for the derivative contract
  var quoteDenom: String = String()

  /// Unique market ID.
  var marketID: String = String()

  /// initial_margin_ratio defines the initial margin ratio of a derivative market
  var initialMarginRatio: String = String()

  /// maintenance_margin_ratio defines the maintenance margin ratio of a derivative market
  var maintenanceMarginRatio: String = String()

  /// maker_fee_rate defines the maker fee rate of a derivative market
  var makerFeeRate: String = String()

  /// taker_fee_rate defines the taker fee rate of a derivative market
  var takerFeeRate: String = String()

  /// relayer_fee_share_rate defines the percentage of the transaction fee shared with the relayer in a derivative market
  var relayerFeeShareRate: String = String()

  /// true if the market is a perpetual market. false if the market is an expiry futures market
  var isPerpetual: Bool = false

  /// Status of the market
  var status: Injective_Exchange_V1beta1_MarketStatus = .unspecified

  /// min_price_tick_size defines the minimum tick size that the price and margin required for orders in the market
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the quantity required for orders in the market
  var minQuantityTickSize: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// market ID.
  var marketID: String = String()

  /// expiration_timestamp defines the expiration time for a time expiry futures market.
  var expirationTimestamp: Int64 = 0

  /// expiration_twap_start_timestamp defines the start time of the TWAP calculation window
  var twapStartTimestamp: Int64 = 0

  /// expiration_twap_start_price_cumulative defines the cumulative price for the start of the TWAP window
  var expirationTwapStartPriceCumulative: String = String()

  /// settlement_price defines the settlement price for a time expiry futures market.
  var settlementPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_PerpetualMarketInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// market ID.
  var marketID: String = String()

  /// hourly_funding_rate_cap defines the maximum absolute value of the hourly funding rate
  var hourlyFundingRateCap: String = String()

  /// hourly_interest_rate defines the hourly interest rate
  var hourlyInterestRate: String = String()

  /// next_funding_timestamp defines the next funding timestamp in seconds of a perpetual market
  var nextFundingTimestamp: Int64 = 0

  /// funding_interval defines the next funding interval in seconds of a perpetual market.
  var fundingInterval: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_PerpetualMarketFunding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// cumulative_funding defines the cumulative funding of a perpetual market.
  var cumulativeFunding: String = String()

  /// cumulative_price defines the cumulative price for the current hour up to the last timestamp
  var cumulativePrice: String = String()

  var lastTimestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_DerivativeMarketSettlementInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// market ID.
  var marketID: String = String()

  /// settlement_price defines the settlement price
  var settlementPrice: String = String()

  /// starting_deficit defines starting deficit
  var startingDeficit: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_NextFundingTimestamp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nextTimestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An object describing trade pair of two assets.
struct Injective_Exchange_V1beta1_SpotMarket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote asset.
  var ticker: String = String()

  /// Coin denom used for the base asset
  var baseDenom: String = String()

  /// Coin used for the quote asset
  var quoteDenom: String = String()

  /// maker_fee_rate defines the fee percentage makers pay when trading
  var makerFeeRate: String = String()

  /// taker_fee_rate defines the fee percentage takers pay when trading
  var takerFeeRate: String = String()

  /// relayer_fee_share_rate defines the percentage of the transaction fee shared with the relayer in a derivative market
  var relayerFeeShareRate: String = String()

  /// Unique market ID.
  var marketID: String = String()

  /// Status of the market
  var status: Injective_Exchange_V1beta1_MarketStatus = .unspecified

  /// min_price_tick_size defines the minimum tick size that the price required for orders in the market
  var minPriceTickSize: String = String()

  /// min_quantity_tick_size defines the minimum tick size of the quantity required for orders in the market
  var minQuantityTickSize: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A subaccount's deposit for a given base currency
struct Injective_Exchange_V1beta1_Deposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var availableBalance: String = String()

  var totalBalance: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_SubaccountTradeNonce {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_OrderInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// bytes32 subaccount ID that created the order
  var subaccountID: String = String()

  /// address fee_recipient address that will receive fees for the order
  var feeRecipient: String = String()

  /// price of the order
  var price: String = String()

  /// quantity of the order
  var quantity: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_SpotOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// market_id represents the unique ID of the market
  var marketID: String = String()

  /// order_info contains the information of the order
  var orderInfo: Injective_Exchange_V1beta1_OrderInfo {
    get {return _orderInfo ?? Injective_Exchange_V1beta1_OrderInfo()}
    set {_orderInfo = newValue}
  }
  /// Returns true if `orderInfo` has been explicitly set.
  var hasOrderInfo: Bool {return self._orderInfo != nil}
  /// Clears the value of `orderInfo`. Subsequent reads from it will return its default value.
  mutating func clearOrderInfo() {self._orderInfo = nil}

  /// order types
  var orderType: Injective_Exchange_V1beta1_OrderType = .unspecified

  /// trigger_price is the trigger price used by stop/take orders
  var triggerPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _orderInfo: Injective_Exchange_V1beta1_OrderInfo? = nil
}

/// A valid Spot limit order with Metadata.
struct Injective_Exchange_V1beta1_SpotLimitOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// order_info contains the information of the order
  var orderInfo: Injective_Exchange_V1beta1_OrderInfo {
    get {return _orderInfo ?? Injective_Exchange_V1beta1_OrderInfo()}
    set {_orderInfo = newValue}
  }
  /// Returns true if `orderInfo` has been explicitly set.
  var hasOrderInfo: Bool {return self._orderInfo != nil}
  /// Clears the value of `orderInfo`. Subsequent reads from it will return its default value.
  mutating func clearOrderInfo() {self._orderInfo = nil}

  /// order types
  var orderType: Injective_Exchange_V1beta1_OrderType = .unspecified

  /// the amount of the quantity remaining fillable
  var fillable: String = String()

  /// trigger_price is the trigger price used by stop/take orders
  var triggerPrice: String = String()

  var orderHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _orderInfo: Injective_Exchange_V1beta1_OrderInfo? = nil
}

/// A valid Spot market order with Metadata.
struct Injective_Exchange_V1beta1_SpotMarketOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// order_info contains the information of the order
  var orderInfo: Injective_Exchange_V1beta1_OrderInfo {
    get {return _orderInfo ?? Injective_Exchange_V1beta1_OrderInfo()}
    set {_orderInfo = newValue}
  }
  /// Returns true if `orderInfo` has been explicitly set.
  var hasOrderInfo: Bool {return self._orderInfo != nil}
  /// Clears the value of `orderInfo`. Subsequent reads from it will return its default value.
  mutating func clearOrderInfo() {self._orderInfo = nil}

  var balanceHold: String = String()

  var orderHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _orderInfo: Injective_Exchange_V1beta1_OrderInfo? = nil
}

struct Injective_Exchange_V1beta1_DerivativeOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// market_id represents the unique ID of the market
  var marketID: String = String()

  /// order_info contains the information of the order
  var orderInfo: Injective_Exchange_V1beta1_OrderInfo {
    get {return _orderInfo ?? Injective_Exchange_V1beta1_OrderInfo()}
    set {_orderInfo = newValue}
  }
  /// Returns true if `orderInfo` has been explicitly set.
  var hasOrderInfo: Bool {return self._orderInfo != nil}
  /// Clears the value of `orderInfo`. Subsequent reads from it will return its default value.
  mutating func clearOrderInfo() {self._orderInfo = nil}

  /// order types
  var orderType: Injective_Exchange_V1beta1_OrderType = .unspecified

  /// margin is the margin used by the limit order
  var margin: String = String()

  /// trigger_price is the trigger price used by stop/take orders
  var triggerPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _orderInfo: Injective_Exchange_V1beta1_OrderInfo? = nil
}

struct Injective_Exchange_V1beta1_SubaccountOrderbookMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vanillaLimitOrderCount: UInt32 = 0

  var reduceOnlyLimitOrderCount: UInt32 = 0

  /// AggregateReduceOnlyQuantity is the aggregate fillable quantity of the subaccount's reduce-only limit orders in the given direction.
  var aggregateReduceOnlyQuantity: String = String()

  /// AggregateVanillaQuantity is the aggregate fillable quantity of the subaccount's vanilla limit orders in the given direction.
  var aggregateVanillaQuantity: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_SubaccountOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// price of the order
  var price: String = String()

  /// the amount of the quantity remaining fillable
  var quantity: String = String()

  var isReduceOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A valid Derivative limit order with Metadata.
struct Injective_Exchange_V1beta1_DerivativeLimitOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// order_info contains the information of the order
  var orderInfo: Injective_Exchange_V1beta1_OrderInfo {
    get {return _orderInfo ?? Injective_Exchange_V1beta1_OrderInfo()}
    set {_orderInfo = newValue}
  }
  /// Returns true if `orderInfo` has been explicitly set.
  var hasOrderInfo: Bool {return self._orderInfo != nil}
  /// Clears the value of `orderInfo`. Subsequent reads from it will return its default value.
  mutating func clearOrderInfo() {self._orderInfo = nil}

  /// order types
  var orderType: Injective_Exchange_V1beta1_OrderType = .unspecified

  /// margin is the margin used by the limit order
  var margin: String = String()

  /// the amount of the quantity remaining fillable
  var fillable: String = String()

  /// trigger_price is the trigger price used by stop/take orders
  var triggerPrice: String = String()

  var orderHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _orderInfo: Injective_Exchange_V1beta1_OrderInfo? = nil
}

/// A valid Derivative market order with Metadata.
struct Injective_Exchange_V1beta1_DerivativeMarketOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// order_info contains the information of the order
  var orderInfo: Injective_Exchange_V1beta1_OrderInfo {
    get {return _orderInfo ?? Injective_Exchange_V1beta1_OrderInfo()}
    set {_orderInfo = newValue}
  }
  /// Returns true if `orderInfo` has been explicitly set.
  var hasOrderInfo: Bool {return self._orderInfo != nil}
  /// Clears the value of `orderInfo`. Subsequent reads from it will return its default value.
  mutating func clearOrderInfo() {self._orderInfo = nil}

  /// order types
  var orderType: Injective_Exchange_V1beta1_OrderType = .unspecified

  var margin: String = String()

  var marginHold: String = String()

  /// trigger_price is the trigger price used by stop/take orders
  var triggerPrice: String = String()

  var orderHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _orderInfo: Injective_Exchange_V1beta1_OrderInfo? = nil
}

struct Injective_Exchange_V1beta1_Position {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isLong: Bool = false

  var quantity: String = String()

  var entryPrice: String = String()

  var margin: String = String()

  var cumulativeFundingEntry: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_MarketOrderIndicator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// market_id represents the unique ID of the market
  var marketID: String = String()

  var isBuy: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_TradeLog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var quantity: String = String()

  var price: String = String()

  /// bytes32 subaccount ID that executed the trade
  var subaccountID: Data = Data()

  var fee: String = String()

  var orderHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_PositionDelta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isLong: Bool = false

  var executionQuantity: String = String()

  var executionMargin: String = String()

  var executionPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_DerivativeTradeLog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: Data = Data()

  var positionDelta: Injective_Exchange_V1beta1_PositionDelta {
    get {return _positionDelta ?? Injective_Exchange_V1beta1_PositionDelta()}
    set {_positionDelta = newValue}
  }
  /// Returns true if `positionDelta` has been explicitly set.
  var hasPositionDelta: Bool {return self._positionDelta != nil}
  /// Clears the value of `positionDelta`. Subsequent reads from it will return its default value.
  mutating func clearPositionDelta() {self._positionDelta = nil}

  var payout: String = String()

  var fee: String = String()

  var orderHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _positionDelta: Injective_Exchange_V1beta1_PositionDelta? = nil
}

struct Injective_Exchange_V1beta1_EventBatchSpotExecution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var isBuy: Bool = false

  var executionType: Injective_Exchange_V1beta1_ExecutionType = .unspecifiedExecutionType

  var trades: [Injective_Exchange_V1beta1_TradeLog] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventBatchDerivativeExecution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var isBuy: Bool = false

  var isLiquidation: Bool = false

  /// nil for time expiry futures
  var cumulativeFunding: String = String()

  var executionType: Injective_Exchange_V1beta1_ExecutionType = .unspecifiedExecutionType

  var trades: [Injective_Exchange_V1beta1_DerivativeTradeLog] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_SubaccountPosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var position: Injective_Exchange_V1beta1_Position {
    get {return _position ?? Injective_Exchange_V1beta1_Position()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var subaccountID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: Injective_Exchange_V1beta1_Position? = nil
}

struct Injective_Exchange_V1beta1_EventBatchDerivativePosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var positions: [Injective_Exchange_V1beta1_SubaccountPosition] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventDerivativeMarketPaused {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var settlePrice: String = String()

  var totalMissingFunds: String = String()

  var missingFundsRate: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventNewSpotOrders {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var buyOrders: [Injective_Exchange_V1beta1_SpotLimitOrder] = []

  var sellOrders: [Injective_Exchange_V1beta1_SpotLimitOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventNewDerivativeOrders {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var buyOrders: [Injective_Exchange_V1beta1_DerivativeLimitOrder] = []

  var sellOrders: [Injective_Exchange_V1beta1_DerivativeLimitOrder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventCancelSpotOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var order: Injective_Exchange_V1beta1_SpotLimitOrder {
    get {return _order ?? Injective_Exchange_V1beta1_SpotLimitOrder()}
    set {_order = newValue}
  }
  /// Returns true if `order` has been explicitly set.
  var hasOrder: Bool {return self._order != nil}
  /// Clears the value of `order`. Subsequent reads from it will return its default value.
  mutating func clearOrder() {self._order = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _order: Injective_Exchange_V1beta1_SpotLimitOrder? = nil
}

struct Injective_Exchange_V1beta1_EventSpotMarketUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var market: Injective_Exchange_V1beta1_SpotMarket {
    get {return _market ?? Injective_Exchange_V1beta1_SpotMarket()}
    set {_market = newValue}
  }
  /// Returns true if `market` has been explicitly set.
  var hasMarket: Bool {return self._market != nil}
  /// Clears the value of `market`. Subsequent reads from it will return its default value.
  mutating func clearMarket() {self._market = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _market: Injective_Exchange_V1beta1_SpotMarket? = nil
}

struct Injective_Exchange_V1beta1_EventPerpetualMarketUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var market: Injective_Exchange_V1beta1_DerivativeMarket {
    get {return _storage._market ?? Injective_Exchange_V1beta1_DerivativeMarket()}
    set {_uniqueStorage()._market = newValue}
  }
  /// Returns true if `market` has been explicitly set.
  var hasMarket: Bool {return _storage._market != nil}
  /// Clears the value of `market`. Subsequent reads from it will return its default value.
  mutating func clearMarket() {_uniqueStorage()._market = nil}

  var perpetualMarketInfo: Injective_Exchange_V1beta1_PerpetualMarketInfo {
    get {return _storage._perpetualMarketInfo ?? Injective_Exchange_V1beta1_PerpetualMarketInfo()}
    set {_uniqueStorage()._perpetualMarketInfo = newValue}
  }
  /// Returns true if `perpetualMarketInfo` has been explicitly set.
  var hasPerpetualMarketInfo: Bool {return _storage._perpetualMarketInfo != nil}
  /// Clears the value of `perpetualMarketInfo`. Subsequent reads from it will return its default value.
  mutating func clearPerpetualMarketInfo() {_uniqueStorage()._perpetualMarketInfo = nil}

  var funding: Injective_Exchange_V1beta1_PerpetualMarketFunding {
    get {return _storage._funding ?? Injective_Exchange_V1beta1_PerpetualMarketFunding()}
    set {_uniqueStorage()._funding = newValue}
  }
  /// Returns true if `funding` has been explicitly set.
  var hasFunding: Bool {return _storage._funding != nil}
  /// Clears the value of `funding`. Subsequent reads from it will return its default value.
  mutating func clearFunding() {_uniqueStorage()._funding = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Injective_Exchange_V1beta1_EventExpiryFuturesMarketUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var market: Injective_Exchange_V1beta1_DerivativeMarket {
    get {return _storage._market ?? Injective_Exchange_V1beta1_DerivativeMarket()}
    set {_uniqueStorage()._market = newValue}
  }
  /// Returns true if `market` has been explicitly set.
  var hasMarket: Bool {return _storage._market != nil}
  /// Clears the value of `market`. Subsequent reads from it will return its default value.
  mutating func clearMarket() {_uniqueStorage()._market = nil}

  var expiryFuturesMarketInfo: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo {
    get {return _storage._expiryFuturesMarketInfo ?? Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo()}
    set {_uniqueStorage()._expiryFuturesMarketInfo = newValue}
  }
  /// Returns true if `expiryFuturesMarketInfo` has been explicitly set.
  var hasExpiryFuturesMarketInfo: Bool {return _storage._expiryFuturesMarketInfo != nil}
  /// Clears the value of `expiryFuturesMarketInfo`. Subsequent reads from it will return its default value.
  mutating func clearExpiryFuturesMarketInfo() {_uniqueStorage()._expiryFuturesMarketInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Injective_Exchange_V1beta1_EventPerpetualMarketFundingUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String = String()

  var funding: Injective_Exchange_V1beta1_PerpetualMarketFunding {
    get {return _funding ?? Injective_Exchange_V1beta1_PerpetualMarketFunding()}
    set {_funding = newValue}
  }
  /// Returns true if `funding` has been explicitly set.
  var hasFunding: Bool {return self._funding != nil}
  /// Clears the value of `funding`. Subsequent reads from it will return its default value.
  mutating func clearFunding() {self._funding = nil}

  var isHourlyFunding: Bool = false

  var fundingRate: String = String()

  var markPrice: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _funding: Injective_Exchange_V1beta1_PerpetualMarketFunding? = nil
}

struct Injective_Exchange_V1beta1_EventSubaccountDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var srcAddress: String = String()

  var subaccountID: Data = Data()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Injective_Exchange_V1beta1_EventSubaccountWithdraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: Data = Data()

  var dstAddress: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Injective_Exchange_V1beta1_EventSubaccountBalanceTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var srcSubaccountID: String = String()

  var dstSubaccountID: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Injective_Exchange_V1beta1_SubaccountDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subaccountID: Data = Data()

  var deposit: Injective_Exchange_V1beta1_Deposit {
    get {return _deposit ?? Injective_Exchange_V1beta1_Deposit()}
    set {_deposit = newValue}
  }
  /// Returns true if `deposit` has been explicitly set.
  var hasDeposit: Bool {return self._deposit != nil}
  /// Clears the value of `deposit`. Subsequent reads from it will return its default value.
  mutating func clearDeposit() {self._deposit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deposit: Injective_Exchange_V1beta1_Deposit? = nil
}

struct Injective_Exchange_V1beta1_DepositUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var deposits: [Injective_Exchange_V1beta1_SubaccountDeposit] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventBatchDepositUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var depositUpdates: [Injective_Exchange_V1beta1_DepositUpdate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_DerivativeMarketOrderCancel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketOrder: Injective_Exchange_V1beta1_DerivativeMarketOrder {
    get {return _marketOrder ?? Injective_Exchange_V1beta1_DerivativeMarketOrder()}
    set {_marketOrder = newValue}
  }
  /// Returns true if `marketOrder` has been explicitly set.
  var hasMarketOrder: Bool {return self._marketOrder != nil}
  /// Clears the value of `marketOrder`. Subsequent reads from it will return its default value.
  mutating func clearMarketOrder() {self._marketOrder = nil}

  var cancelQuantity: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _marketOrder: Injective_Exchange_V1beta1_DerivativeMarketOrder? = nil
}

struct Injective_Exchange_V1beta1_EventCancelDerivativeOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var marketID: String {
    get {return _storage._marketID}
    set {_uniqueStorage()._marketID = newValue}
  }

  var isLimitCancel: Bool {
    get {return _storage._isLimitCancel}
    set {_uniqueStorage()._isLimitCancel = newValue}
  }

  var limitOrder: Injective_Exchange_V1beta1_DerivativeLimitOrder {
    get {return _storage._limitOrder ?? Injective_Exchange_V1beta1_DerivativeLimitOrder()}
    set {_uniqueStorage()._limitOrder = newValue}
  }
  /// Returns true if `limitOrder` has been explicitly set.
  var hasLimitOrder: Bool {return _storage._limitOrder != nil}
  /// Clears the value of `limitOrder`. Subsequent reads from it will return its default value.
  mutating func clearLimitOrder() {_uniqueStorage()._limitOrder = nil}

  var marketOrderCancel: Injective_Exchange_V1beta1_DerivativeMarketOrderCancel {
    get {return _storage._marketOrderCancel ?? Injective_Exchange_V1beta1_DerivativeMarketOrderCancel()}
    set {_uniqueStorage()._marketOrderCancel = newValue}
  }
  /// Returns true if `marketOrderCancel` has been explicitly set.
  var hasMarketOrderCancel: Bool {return _storage._marketOrderCancel != nil}
  /// Clears the value of `marketOrderCancel`. Subsequent reads from it will return its default value.
  mutating func clearMarketOrderCancel() {_uniqueStorage()._marketOrderCancel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Injective_Exchange_V1beta1_PointsMultiplier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var makerPointsMultiplier: String = String()

  var takerPointsMultiplier: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_TradingRewardCampaignBoostInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var boostedSpotMarketIds: [String] = []

  var spotMarketMultipliers: [Injective_Exchange_V1beta1_PointsMultiplier] = []

  var boostedDerivativeMarketIds: [String] = []

  var derivativeMarketMultipliers: [Injective_Exchange_V1beta1_PointsMultiplier] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_CampaignRewardPool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startTimestamp: Int64 = 0

  /// max_campaign_rewards are the maximum reward amounts to be disbursed at the end of the campaign
  var maxCampaignRewards: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_TradingRewardCampaignInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// number of seconds of the duration of each campaign
  var campaignDurationSeconds: Int64 = 0

  /// the trading fee quote denoms which will be counted for the rewards
  var quoteDenoms: [String] = []

  /// the optional boost info for markets
  var tradingRewardBoostInfo: Injective_Exchange_V1beta1_TradingRewardCampaignBoostInfo {
    get {return _tradingRewardBoostInfo ?? Injective_Exchange_V1beta1_TradingRewardCampaignBoostInfo()}
    set {_tradingRewardBoostInfo = newValue}
  }
  /// Returns true if `tradingRewardBoostInfo` has been explicitly set.
  var hasTradingRewardBoostInfo: Bool {return self._tradingRewardBoostInfo != nil}
  /// Clears the value of `tradingRewardBoostInfo`. Subsequent reads from it will return its default value.
  mutating func clearTradingRewardBoostInfo() {self._tradingRewardBoostInfo = nil}

  /// the marketIDs which are disqualified from being rewarded
  var disqualifiedMarketIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tradingRewardBoostInfo: Injective_Exchange_V1beta1_TradingRewardCampaignBoostInfo? = nil
}

struct Injective_Exchange_V1beta1_FeeDiscountTierInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var makerDiscountRate: String = String()

  var takerDiscountRate: String = String()

  var stakedAmount: String = String()

  var feePaidAmount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_FeeDiscountSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bucketCount: UInt64 = 0

  var bucketDuration: Int64 = 0

  /// the trading fee quote denoms which will be counted for the fee paid contribution
  var quoteDenoms: [String] = []

  /// the fee discount tiers
  var tierInfos: [Injective_Exchange_V1beta1_FeeDiscountTierInfo] = []

  /// the marketIDs which are disqualified from contributing to the fee paid amount
  var disqualifiedMarketIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_FeeDiscountTierTTL {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tier: UInt64 = 0

  var ttlTimestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventFeeDiscountSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var schedule: Injective_Exchange_V1beta1_FeeDiscountSchedule {
    get {return _schedule ?? Injective_Exchange_V1beta1_FeeDiscountSchedule()}
    set {_schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  var hasSchedule: Bool {return self._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  mutating func clearSchedule() {self._schedule = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _schedule: Injective_Exchange_V1beta1_FeeDiscountSchedule? = nil
}

struct Injective_Exchange_V1beta1_EventTradingRewardCampaignUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var campaignInfo: Injective_Exchange_V1beta1_TradingRewardCampaignInfo {
    get {return _campaignInfo ?? Injective_Exchange_V1beta1_TradingRewardCampaignInfo()}
    set {_campaignInfo = newValue}
  }
  /// Returns true if `campaignInfo` has been explicitly set.
  var hasCampaignInfo: Bool {return self._campaignInfo != nil}
  /// Clears the value of `campaignInfo`. Subsequent reads from it will return its default value.
  mutating func clearCampaignInfo() {self._campaignInfo = nil}

  var campaignRewardPools: [Injective_Exchange_V1beta1_CampaignRewardPool] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _campaignInfo: Injective_Exchange_V1beta1_TradingRewardCampaignInfo? = nil
}

struct Injective_Exchange_V1beta1_AccountRewards {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var account: String = String()

  var rewards: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Exchange_V1beta1_EventTradingRewardDistribution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountRewards: [Injective_Exchange_V1beta1_AccountRewards] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "injective.exchange.v1beta1"

extension Injective_Exchange_V1beta1_MarketStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unspecified"),
    1: .same(proto: "Active"),
    2: .same(proto: "Paused"),
    3: .same(proto: "Suspended"),
    4: .same(proto: "Demolished"),
    5: .same(proto: "Expired"),
  ]
}

extension Injective_Exchange_V1beta1_OrderType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "BUY"),
    2: .same(proto: "SELL"),
    3: .same(proto: "STOP_BUY"),
    4: .same(proto: "STOP_SELL"),
    5: .same(proto: "TAKE_BUY"),
    6: .same(proto: "TAKE_SELL"),
  ]
}

extension Injective_Exchange_V1beta1_ExecutionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UnspecifiedExecutionType"),
    1: .same(proto: "Market"),
    2: .same(proto: "LimitFill"),
    3: .same(proto: "LimitMatchRestingOrder"),
    4: .same(proto: "LimitMatchNewOrder"),
  ]
}

extension Injective_Exchange_V1beta1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "spot_market_instant_listing_fee"),
    2: .standard(proto: "derivative_market_instant_listing_fee"),
    3: .standard(proto: "default_spot_maker_fee_rate"),
    4: .standard(proto: "default_spot_taker_fee_rate"),
    5: .standard(proto: "default_derivative_maker_fee_rate"),
    6: .standard(proto: "default_derivative_taker_fee_rate"),
    7: .standard(proto: "default_initial_margin_ratio"),
    8: .standard(proto: "default_maintenance_margin_ratio"),
    9: .standard(proto: "default_funding_interval"),
    10: .standard(proto: "funding_multiple"),
    11: .standard(proto: "relayer_fee_share_rate"),
    12: .standard(proto: "default_hourly_funding_rate_cap"),
    13: .standard(proto: "default_hourly_interest_rate"),
    14: .standard(proto: "max_derivative_order_side_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spotMarketInstantListingFee) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._derivativeMarketInstantListingFee) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.defaultSpotMakerFeeRate) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.defaultSpotTakerFeeRate) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.defaultDerivativeMakerFeeRate) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.defaultDerivativeTakerFeeRate) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.defaultInitialMarginRatio) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.defaultMaintenanceMarginRatio) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.defaultFundingInterval) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.fundingMultiple) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.relayerFeeShareRate) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.defaultHourlyFundingRateCap) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.defaultHourlyInterestRate) }()
      case 14: try { try decoder.decodeSingularUInt32Field(value: &self.maxDerivativeOrderSideCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._spotMarketInstantListingFee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._derivativeMarketInstantListingFee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.defaultSpotMakerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultSpotMakerFeeRate, fieldNumber: 3)
    }
    if !self.defaultSpotTakerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultSpotTakerFeeRate, fieldNumber: 4)
    }
    if !self.defaultDerivativeMakerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultDerivativeMakerFeeRate, fieldNumber: 5)
    }
    if !self.defaultDerivativeTakerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultDerivativeTakerFeeRate, fieldNumber: 6)
    }
    if !self.defaultInitialMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultInitialMarginRatio, fieldNumber: 7)
    }
    if !self.defaultMaintenanceMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultMaintenanceMarginRatio, fieldNumber: 8)
    }
    if self.defaultFundingInterval != 0 {
      try visitor.visitSingularInt64Field(value: self.defaultFundingInterval, fieldNumber: 9)
    }
    if self.fundingMultiple != 0 {
      try visitor.visitSingularInt64Field(value: self.fundingMultiple, fieldNumber: 10)
    }
    if !self.relayerFeeShareRate.isEmpty {
      try visitor.visitSingularStringField(value: self.relayerFeeShareRate, fieldNumber: 11)
    }
    if !self.defaultHourlyFundingRateCap.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultHourlyFundingRateCap, fieldNumber: 12)
    }
    if !self.defaultHourlyInterestRate.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultHourlyInterestRate, fieldNumber: 13)
    }
    if self.maxDerivativeOrderSideCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxDerivativeOrderSideCount, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_Params, rhs: Injective_Exchange_V1beta1_Params) -> Bool {
    if lhs._spotMarketInstantListingFee != rhs._spotMarketInstantListingFee {return false}
    if lhs._derivativeMarketInstantListingFee != rhs._derivativeMarketInstantListingFee {return false}
    if lhs.defaultSpotMakerFeeRate != rhs.defaultSpotMakerFeeRate {return false}
    if lhs.defaultSpotTakerFeeRate != rhs.defaultSpotTakerFeeRate {return false}
    if lhs.defaultDerivativeMakerFeeRate != rhs.defaultDerivativeMakerFeeRate {return false}
    if lhs.defaultDerivativeTakerFeeRate != rhs.defaultDerivativeTakerFeeRate {return false}
    if lhs.defaultInitialMarginRatio != rhs.defaultInitialMarginRatio {return false}
    if lhs.defaultMaintenanceMarginRatio != rhs.defaultMaintenanceMarginRatio {return false}
    if lhs.defaultFundingInterval != rhs.defaultFundingInterval {return false}
    if lhs.fundingMultiple != rhs.fundingMultiple {return false}
    if lhs.relayerFeeShareRate != rhs.relayerFeeShareRate {return false}
    if lhs.defaultHourlyFundingRateCap != rhs.defaultHourlyFundingRateCap {return false}
    if lhs.defaultHourlyInterestRate != rhs.defaultHourlyInterestRate {return false}
    if lhs.maxDerivativeOrderSideCount != rhs.maxDerivativeOrderSideCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeMarket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeMarket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ticker"),
    2: .standard(proto: "oracle_base"),
    3: .standard(proto: "oracle_quote"),
    4: .standard(proto: "oracle_type"),
    5: .standard(proto: "oracle_scale_factor"),
    6: .standard(proto: "quote_denom"),
    7: .standard(proto: "market_id"),
    8: .standard(proto: "initial_margin_ratio"),
    9: .standard(proto: "maintenance_margin_ratio"),
    10: .standard(proto: "maker_fee_rate"),
    11: .standard(proto: "taker_fee_rate"),
    12: .standard(proto: "relayer_fee_share_rate"),
    13: .same(proto: "isPerpetual"),
    14: .same(proto: "status"),
    15: .standard(proto: "min_price_tick_size"),
    16: .standard(proto: "min_quantity_tick_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.oracleBase) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.oracleQuote) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.oracleType) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.oracleScaleFactor) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.quoteDenom) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.initialMarginRatio) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.maintenanceMarginRatio) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.makerFeeRate) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.takerFeeRate) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.relayerFeeShareRate) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.isPerpetual) }()
      case 14: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 16: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 1)
    }
    if !self.oracleBase.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleBase, fieldNumber: 2)
    }
    if !self.oracleQuote.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleQuote, fieldNumber: 3)
    }
    if self.oracleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracleType, fieldNumber: 4)
    }
    if self.oracleScaleFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.oracleScaleFactor, fieldNumber: 5)
    }
    if !self.quoteDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteDenom, fieldNumber: 6)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 7)
    }
    if !self.initialMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.initialMarginRatio, fieldNumber: 8)
    }
    if !self.maintenanceMarginRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.maintenanceMarginRatio, fieldNumber: 9)
    }
    if !self.makerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerFeeRate, fieldNumber: 10)
    }
    if !self.takerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerFeeRate, fieldNumber: 11)
    }
    if !self.relayerFeeShareRate.isEmpty {
      try visitor.visitSingularStringField(value: self.relayerFeeShareRate, fieldNumber: 12)
    }
    if self.isPerpetual != false {
      try visitor.visitSingularBoolField(value: self.isPerpetual, fieldNumber: 13)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 14)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 15)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeMarket, rhs: Injective_Exchange_V1beta1_DerivativeMarket) -> Bool {
    if lhs.ticker != rhs.ticker {return false}
    if lhs.oracleBase != rhs.oracleBase {return false}
    if lhs.oracleQuote != rhs.oracleQuote {return false}
    if lhs.oracleType != rhs.oracleType {return false}
    if lhs.oracleScaleFactor != rhs.oracleScaleFactor {return false}
    if lhs.quoteDenom != rhs.quoteDenom {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.initialMarginRatio != rhs.initialMarginRatio {return false}
    if lhs.maintenanceMarginRatio != rhs.maintenanceMarginRatio {return false}
    if lhs.makerFeeRate != rhs.makerFeeRate {return false}
    if lhs.takerFeeRate != rhs.takerFeeRate {return false}
    if lhs.relayerFeeShareRate != rhs.relayerFeeShareRate {return false}
    if lhs.isPerpetual != rhs.isPerpetual {return false}
    if lhs.status != rhs.status {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpiryFuturesMarketInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "expiration_timestamp"),
    3: .standard(proto: "twap_start_timestamp"),
    4: .standard(proto: "expiration_twap_start_price_cumulative"),
    5: .standard(proto: "settlement_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.expirationTimestamp) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.twapStartTimestamp) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.expirationTwapStartPriceCumulative) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.settlementPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if self.expirationTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.expirationTimestamp, fieldNumber: 2)
    }
    if self.twapStartTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.twapStartTimestamp, fieldNumber: 3)
    }
    if !self.expirationTwapStartPriceCumulative.isEmpty {
      try visitor.visitSingularStringField(value: self.expirationTwapStartPriceCumulative, fieldNumber: 4)
    }
    if !self.settlementPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.settlementPrice, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo, rhs: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.expirationTimestamp != rhs.expirationTimestamp {return false}
    if lhs.twapStartTimestamp != rhs.twapStartTimestamp {return false}
    if lhs.expirationTwapStartPriceCumulative != rhs.expirationTwapStartPriceCumulative {return false}
    if lhs.settlementPrice != rhs.settlementPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_PerpetualMarketInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PerpetualMarketInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "hourly_funding_rate_cap"),
    3: .standard(proto: "hourly_interest_rate"),
    4: .standard(proto: "next_funding_timestamp"),
    5: .standard(proto: "funding_interval"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hourlyFundingRateCap) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hourlyInterestRate) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.nextFundingTimestamp) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.fundingInterval) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.hourlyFundingRateCap.isEmpty {
      try visitor.visitSingularStringField(value: self.hourlyFundingRateCap, fieldNumber: 2)
    }
    if !self.hourlyInterestRate.isEmpty {
      try visitor.visitSingularStringField(value: self.hourlyInterestRate, fieldNumber: 3)
    }
    if self.nextFundingTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.nextFundingTimestamp, fieldNumber: 4)
    }
    if self.fundingInterval != 0 {
      try visitor.visitSingularInt64Field(value: self.fundingInterval, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_PerpetualMarketInfo, rhs: Injective_Exchange_V1beta1_PerpetualMarketInfo) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.hourlyFundingRateCap != rhs.hourlyFundingRateCap {return false}
    if lhs.hourlyInterestRate != rhs.hourlyInterestRate {return false}
    if lhs.nextFundingTimestamp != rhs.nextFundingTimestamp {return false}
    if lhs.fundingInterval != rhs.fundingInterval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_PerpetualMarketFunding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PerpetualMarketFunding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cumulative_funding"),
    2: .standard(proto: "cumulative_price"),
    3: .standard(proto: "last_timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cumulativeFunding) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cumulativePrice) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.lastTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cumulativeFunding.isEmpty {
      try visitor.visitSingularStringField(value: self.cumulativeFunding, fieldNumber: 1)
    }
    if !self.cumulativePrice.isEmpty {
      try visitor.visitSingularStringField(value: self.cumulativePrice, fieldNumber: 2)
    }
    if self.lastTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.lastTimestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_PerpetualMarketFunding, rhs: Injective_Exchange_V1beta1_PerpetualMarketFunding) -> Bool {
    if lhs.cumulativeFunding != rhs.cumulativeFunding {return false}
    if lhs.cumulativePrice != rhs.cumulativePrice {return false}
    if lhs.lastTimestamp != rhs.lastTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeMarketSettlementInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeMarketSettlementInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "settlement_price"),
    3: .standard(proto: "starting_deficit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.settlementPrice) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.startingDeficit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.settlementPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.settlementPrice, fieldNumber: 2)
    }
    if !self.startingDeficit.isEmpty {
      try visitor.visitSingularStringField(value: self.startingDeficit, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeMarketSettlementInfo, rhs: Injective_Exchange_V1beta1_DerivativeMarketSettlementInfo) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.settlementPrice != rhs.settlementPrice {return false}
    if lhs.startingDeficit != rhs.startingDeficit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_NextFundingTimestamp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NextFundingTimestamp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "next_timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.nextTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nextTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.nextTimestamp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_NextFundingTimestamp, rhs: Injective_Exchange_V1beta1_NextFundingTimestamp) -> Bool {
    if lhs.nextTimestamp != rhs.nextTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SpotMarket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpotMarket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ticker"),
    2: .standard(proto: "base_denom"),
    3: .standard(proto: "quote_denom"),
    4: .standard(proto: "maker_fee_rate"),
    5: .standard(proto: "taker_fee_rate"),
    6: .standard(proto: "relayer_fee_share_rate"),
    7: .standard(proto: "market_id"),
    8: .same(proto: "status"),
    9: .standard(proto: "min_price_tick_size"),
    10: .standard(proto: "min_quantity_tick_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.baseDenom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.quoteDenom) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.makerFeeRate) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.takerFeeRate) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.relayerFeeShareRate) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.minPriceTickSize) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.minQuantityTickSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 1)
    }
    if !self.baseDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.baseDenom, fieldNumber: 2)
    }
    if !self.quoteDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteDenom, fieldNumber: 3)
    }
    if !self.makerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerFeeRate, fieldNumber: 4)
    }
    if !self.takerFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerFeeRate, fieldNumber: 5)
    }
    if !self.relayerFeeShareRate.isEmpty {
      try visitor.visitSingularStringField(value: self.relayerFeeShareRate, fieldNumber: 6)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 7)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 8)
    }
    if !self.minPriceTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minPriceTickSize, fieldNumber: 9)
    }
    if !self.minQuantityTickSize.isEmpty {
      try visitor.visitSingularStringField(value: self.minQuantityTickSize, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SpotMarket, rhs: Injective_Exchange_V1beta1_SpotMarket) -> Bool {
    if lhs.ticker != rhs.ticker {return false}
    if lhs.baseDenom != rhs.baseDenom {return false}
    if lhs.quoteDenom != rhs.quoteDenom {return false}
    if lhs.makerFeeRate != rhs.makerFeeRate {return false}
    if lhs.takerFeeRate != rhs.takerFeeRate {return false}
    if lhs.relayerFeeShareRate != rhs.relayerFeeShareRate {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.minPriceTickSize != rhs.minPriceTickSize {return false}
    if lhs.minQuantityTickSize != rhs.minQuantityTickSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_Deposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Deposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "available_balance"),
    2: .standard(proto: "total_balance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.availableBalance) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.totalBalance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.availableBalance.isEmpty {
      try visitor.visitSingularStringField(value: self.availableBalance, fieldNumber: 1)
    }
    if !self.totalBalance.isEmpty {
      try visitor.visitSingularStringField(value: self.totalBalance, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_Deposit, rhs: Injective_Exchange_V1beta1_Deposit) -> Bool {
    if lhs.availableBalance != rhs.availableBalance {return false}
    if lhs.totalBalance != rhs.totalBalance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SubaccountTradeNonce: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubaccountTradeNonce"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nonce != 0 {
      try visitor.visitSingularUInt32Field(value: self.nonce, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SubaccountTradeNonce, rhs: Injective_Exchange_V1beta1_SubaccountTradeNonce) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_OrderInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrderInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .standard(proto: "fee_recipient"),
    3: .same(proto: "price"),
    4: .same(proto: "quantity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.feeRecipient) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.subaccountID, fieldNumber: 1)
    }
    if !self.feeRecipient.isEmpty {
      try visitor.visitSingularStringField(value: self.feeRecipient, fieldNumber: 2)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 3)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_OrderInfo, rhs: Injective_Exchange_V1beta1_OrderInfo) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.feeRecipient != rhs.feeRecipient {return false}
    if lhs.price != rhs.price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SpotOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpotOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "order_info"),
    3: .standard(proto: "order_type"),
    4: .standard(proto: "trigger_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._orderInfo) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.orderType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.triggerPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if let v = self._orderInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.orderType != .unspecified {
      try visitor.visitSingularEnumField(value: self.orderType, fieldNumber: 3)
    }
    if !self.triggerPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerPrice, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SpotOrder, rhs: Injective_Exchange_V1beta1_SpotOrder) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs._orderInfo != rhs._orderInfo {return false}
    if lhs.orderType != rhs.orderType {return false}
    if lhs.triggerPrice != rhs.triggerPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SpotLimitOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpotLimitOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_info"),
    2: .standard(proto: "order_type"),
    3: .same(proto: "fillable"),
    4: .standard(proto: "trigger_price"),
    5: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._orderInfo) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.orderType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fillable) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.triggerPrice) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._orderInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.orderType != .unspecified {
      try visitor.visitSingularEnumField(value: self.orderType, fieldNumber: 2)
    }
    if !self.fillable.isEmpty {
      try visitor.visitSingularStringField(value: self.fillable, fieldNumber: 3)
    }
    if !self.triggerPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerPrice, fieldNumber: 4)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.orderHash, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SpotLimitOrder, rhs: Injective_Exchange_V1beta1_SpotLimitOrder) -> Bool {
    if lhs._orderInfo != rhs._orderInfo {return false}
    if lhs.orderType != rhs.orderType {return false}
    if lhs.fillable != rhs.fillable {return false}
    if lhs.triggerPrice != rhs.triggerPrice {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SpotMarketOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpotMarketOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_info"),
    2: .standard(proto: "balance_hold"),
    3: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._orderInfo) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.balanceHold) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._orderInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.balanceHold.isEmpty {
      try visitor.visitSingularStringField(value: self.balanceHold, fieldNumber: 2)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.orderHash, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SpotMarketOrder, rhs: Injective_Exchange_V1beta1_SpotMarketOrder) -> Bool {
    if lhs._orderInfo != rhs._orderInfo {return false}
    if lhs.balanceHold != rhs.balanceHold {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "order_info"),
    3: .standard(proto: "order_type"),
    4: .same(proto: "margin"),
    5: .standard(proto: "trigger_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._orderInfo) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.orderType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.margin) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.triggerPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if let v = self._orderInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.orderType != .unspecified {
      try visitor.visitSingularEnumField(value: self.orderType, fieldNumber: 3)
    }
    if !self.margin.isEmpty {
      try visitor.visitSingularStringField(value: self.margin, fieldNumber: 4)
    }
    if !self.triggerPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerPrice, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeOrder, rhs: Injective_Exchange_V1beta1_DerivativeOrder) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs._orderInfo != rhs._orderInfo {return false}
    if lhs.orderType != rhs.orderType {return false}
    if lhs.margin != rhs.margin {return false}
    if lhs.triggerPrice != rhs.triggerPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SubaccountOrderbookMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubaccountOrderbookMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vanilla_limit_order_count"),
    2: .standard(proto: "reduce_only_limit_order_count"),
    3: .standard(proto: "aggregate_reduce_only_quantity"),
    4: .standard(proto: "aggregate_vanilla_quantity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.vanillaLimitOrderCount) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.reduceOnlyLimitOrderCount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.aggregateReduceOnlyQuantity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.aggregateVanillaQuantity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.vanillaLimitOrderCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.vanillaLimitOrderCount, fieldNumber: 1)
    }
    if self.reduceOnlyLimitOrderCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.reduceOnlyLimitOrderCount, fieldNumber: 2)
    }
    if !self.aggregateReduceOnlyQuantity.isEmpty {
      try visitor.visitSingularStringField(value: self.aggregateReduceOnlyQuantity, fieldNumber: 3)
    }
    if !self.aggregateVanillaQuantity.isEmpty {
      try visitor.visitSingularStringField(value: self.aggregateVanillaQuantity, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SubaccountOrderbookMetadata, rhs: Injective_Exchange_V1beta1_SubaccountOrderbookMetadata) -> Bool {
    if lhs.vanillaLimitOrderCount != rhs.vanillaLimitOrderCount {return false}
    if lhs.reduceOnlyLimitOrderCount != rhs.reduceOnlyLimitOrderCount {return false}
    if lhs.aggregateReduceOnlyQuantity != rhs.aggregateReduceOnlyQuantity {return false}
    if lhs.aggregateVanillaQuantity != rhs.aggregateVanillaQuantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SubaccountOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubaccountOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .same(proto: "quantity"),
    3: .same(proto: "isReduceOnly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isReduceOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 1)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 2)
    }
    if self.isReduceOnly != false {
      try visitor.visitSingularBoolField(value: self.isReduceOnly, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SubaccountOrder, rhs: Injective_Exchange_V1beta1_SubaccountOrder) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.isReduceOnly != rhs.isReduceOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeLimitOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeLimitOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_info"),
    2: .standard(proto: "order_type"),
    3: .same(proto: "margin"),
    4: .same(proto: "fillable"),
    5: .standard(proto: "trigger_price"),
    6: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._orderInfo) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.orderType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.margin) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fillable) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.triggerPrice) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._orderInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.orderType != .unspecified {
      try visitor.visitSingularEnumField(value: self.orderType, fieldNumber: 2)
    }
    if !self.margin.isEmpty {
      try visitor.visitSingularStringField(value: self.margin, fieldNumber: 3)
    }
    if !self.fillable.isEmpty {
      try visitor.visitSingularStringField(value: self.fillable, fieldNumber: 4)
    }
    if !self.triggerPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerPrice, fieldNumber: 5)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.orderHash, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeLimitOrder, rhs: Injective_Exchange_V1beta1_DerivativeLimitOrder) -> Bool {
    if lhs._orderInfo != rhs._orderInfo {return false}
    if lhs.orderType != rhs.orderType {return false}
    if lhs.margin != rhs.margin {return false}
    if lhs.fillable != rhs.fillable {return false}
    if lhs.triggerPrice != rhs.triggerPrice {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeMarketOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeMarketOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_info"),
    2: .standard(proto: "order_type"),
    3: .same(proto: "margin"),
    4: .standard(proto: "margin_hold"),
    5: .standard(proto: "trigger_price"),
    6: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._orderInfo) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.orderType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.margin) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.marginHold) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.triggerPrice) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._orderInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.orderType != .unspecified {
      try visitor.visitSingularEnumField(value: self.orderType, fieldNumber: 2)
    }
    if !self.margin.isEmpty {
      try visitor.visitSingularStringField(value: self.margin, fieldNumber: 3)
    }
    if !self.marginHold.isEmpty {
      try visitor.visitSingularStringField(value: self.marginHold, fieldNumber: 4)
    }
    if !self.triggerPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerPrice, fieldNumber: 5)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.orderHash, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeMarketOrder, rhs: Injective_Exchange_V1beta1_DerivativeMarketOrder) -> Bool {
    if lhs._orderInfo != rhs._orderInfo {return false}
    if lhs.orderType != rhs.orderType {return false}
    if lhs.margin != rhs.margin {return false}
    if lhs.marginHold != rhs.marginHold {return false}
    if lhs.triggerPrice != rhs.triggerPrice {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Position"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isLong"),
    2: .same(proto: "quantity"),
    3: .standard(proto: "entry_price"),
    4: .same(proto: "margin"),
    5: .standard(proto: "cumulative_funding_entry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isLong) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.entryPrice) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.margin) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.cumulativeFundingEntry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isLong != false {
      try visitor.visitSingularBoolField(value: self.isLong, fieldNumber: 1)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 2)
    }
    if !self.entryPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.entryPrice, fieldNumber: 3)
    }
    if !self.margin.isEmpty {
      try visitor.visitSingularStringField(value: self.margin, fieldNumber: 4)
    }
    if !self.cumulativeFundingEntry.isEmpty {
      try visitor.visitSingularStringField(value: self.cumulativeFundingEntry, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_Position, rhs: Injective_Exchange_V1beta1_Position) -> Bool {
    if lhs.isLong != rhs.isLong {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.entryPrice != rhs.entryPrice {return false}
    if lhs.margin != rhs.margin {return false}
    if lhs.cumulativeFundingEntry != rhs.cumulativeFundingEntry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_MarketOrderIndicator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MarketOrderIndicator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "isBuy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isBuy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if self.isBuy != false {
      try visitor.visitSingularBoolField(value: self.isBuy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_MarketOrderIndicator, rhs: Injective_Exchange_V1beta1_MarketOrderIndicator) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.isBuy != rhs.isBuy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TradeLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradeLog"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quantity"),
    2: .same(proto: "price"),
    3: .standard(proto: "subaccount_id"),
    4: .same(proto: "fee"),
    5: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.quantity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.subaccountID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fee) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 1)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 2)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularBytesField(value: self.subaccountID, fieldNumber: 3)
    }
    if !self.fee.isEmpty {
      try visitor.visitSingularStringField(value: self.fee, fieldNumber: 4)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.orderHash, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TradeLog, rhs: Injective_Exchange_V1beta1_TradeLog) -> Bool {
    if lhs.quantity != rhs.quantity {return false}
    if lhs.price != rhs.price {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_PositionDelta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionDelta"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_long"),
    2: .standard(proto: "execution_quantity"),
    3: .standard(proto: "execution_margin"),
    4: .standard(proto: "execution_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isLong) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.executionQuantity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.executionMargin) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.executionPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isLong != false {
      try visitor.visitSingularBoolField(value: self.isLong, fieldNumber: 1)
    }
    if !self.executionQuantity.isEmpty {
      try visitor.visitSingularStringField(value: self.executionQuantity, fieldNumber: 2)
    }
    if !self.executionMargin.isEmpty {
      try visitor.visitSingularStringField(value: self.executionMargin, fieldNumber: 3)
    }
    if !self.executionPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.executionPrice, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_PositionDelta, rhs: Injective_Exchange_V1beta1_PositionDelta) -> Bool {
    if lhs.isLong != rhs.isLong {return false}
    if lhs.executionQuantity != rhs.executionQuantity {return false}
    if lhs.executionMargin != rhs.executionMargin {return false}
    if lhs.executionPrice != rhs.executionPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeTradeLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeTradeLog"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .standard(proto: "position_delta"),
    3: .same(proto: "payout"),
    4: .same(proto: "fee"),
    5: .standard(proto: "order_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._positionDelta) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.payout) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fee) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.orderHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularBytesField(value: self.subaccountID, fieldNumber: 1)
    }
    if let v = self._positionDelta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.payout.isEmpty {
      try visitor.visitSingularStringField(value: self.payout, fieldNumber: 3)
    }
    if !self.fee.isEmpty {
      try visitor.visitSingularStringField(value: self.fee, fieldNumber: 4)
    }
    if !self.orderHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.orderHash, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeTradeLog, rhs: Injective_Exchange_V1beta1_DerivativeTradeLog) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs._positionDelta != rhs._positionDelta {return false}
    if lhs.payout != rhs.payout {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.orderHash != rhs.orderHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventBatchSpotExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventBatchSpotExecution"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "is_buy"),
    3: .same(proto: "executionType"),
    4: .same(proto: "trades"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isBuy) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.executionType) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.trades) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if self.isBuy != false {
      try visitor.visitSingularBoolField(value: self.isBuy, fieldNumber: 2)
    }
    if self.executionType != .unspecifiedExecutionType {
      try visitor.visitSingularEnumField(value: self.executionType, fieldNumber: 3)
    }
    if !self.trades.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trades, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventBatchSpotExecution, rhs: Injective_Exchange_V1beta1_EventBatchSpotExecution) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.isBuy != rhs.isBuy {return false}
    if lhs.executionType != rhs.executionType {return false}
    if lhs.trades != rhs.trades {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventBatchDerivativeExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventBatchDerivativeExecution"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "is_buy"),
    3: .standard(proto: "is_liquidation"),
    4: .standard(proto: "cumulative_funding"),
    5: .same(proto: "executionType"),
    6: .same(proto: "trades"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isBuy) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isLiquidation) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cumulativeFunding) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.executionType) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.trades) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if self.isBuy != false {
      try visitor.visitSingularBoolField(value: self.isBuy, fieldNumber: 2)
    }
    if self.isLiquidation != false {
      try visitor.visitSingularBoolField(value: self.isLiquidation, fieldNumber: 3)
    }
    if !self.cumulativeFunding.isEmpty {
      try visitor.visitSingularStringField(value: self.cumulativeFunding, fieldNumber: 4)
    }
    if self.executionType != .unspecifiedExecutionType {
      try visitor.visitSingularEnumField(value: self.executionType, fieldNumber: 5)
    }
    if !self.trades.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trades, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventBatchDerivativeExecution, rhs: Injective_Exchange_V1beta1_EventBatchDerivativeExecution) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.isBuy != rhs.isBuy {return false}
    if lhs.isLiquidation != rhs.isLiquidation {return false}
    if lhs.cumulativeFunding != rhs.cumulativeFunding {return false}
    if lhs.executionType != rhs.executionType {return false}
    if lhs.trades != rhs.trades {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SubaccountPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubaccountPosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .standard(proto: "subaccount_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.subaccountID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularBytesField(value: self.subaccountID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SubaccountPosition, rhs: Injective_Exchange_V1beta1_SubaccountPosition) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventBatchDerivativePosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventBatchDerivativePosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "positions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.positions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.positions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.positions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventBatchDerivativePosition, rhs: Injective_Exchange_V1beta1_EventBatchDerivativePosition) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.positions != rhs.positions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventDerivativeMarketPaused: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventDerivativeMarketPaused"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "settle_price"),
    3: .standard(proto: "total_missing_funds"),
    4: .standard(proto: "missing_funds_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.settlePrice) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.totalMissingFunds) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.missingFundsRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.settlePrice.isEmpty {
      try visitor.visitSingularStringField(value: self.settlePrice, fieldNumber: 2)
    }
    if !self.totalMissingFunds.isEmpty {
      try visitor.visitSingularStringField(value: self.totalMissingFunds, fieldNumber: 3)
    }
    if !self.missingFundsRate.isEmpty {
      try visitor.visitSingularStringField(value: self.missingFundsRate, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventDerivativeMarketPaused, rhs: Injective_Exchange_V1beta1_EventDerivativeMarketPaused) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.settlePrice != rhs.settlePrice {return false}
    if lhs.totalMissingFunds != rhs.totalMissingFunds {return false}
    if lhs.missingFundsRate != rhs.missingFundsRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventNewSpotOrders: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventNewSpotOrders"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "buy_orders"),
    3: .standard(proto: "sell_orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.buyOrders) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sellOrders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.buyOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buyOrders, fieldNumber: 2)
    }
    if !self.sellOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sellOrders, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventNewSpotOrders, rhs: Injective_Exchange_V1beta1_EventNewSpotOrders) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.buyOrders != rhs.buyOrders {return false}
    if lhs.sellOrders != rhs.sellOrders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventNewDerivativeOrders: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventNewDerivativeOrders"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .standard(proto: "buy_orders"),
    3: .standard(proto: "sell_orders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.buyOrders) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sellOrders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if !self.buyOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buyOrders, fieldNumber: 2)
    }
    if !self.sellOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sellOrders, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventNewDerivativeOrders, rhs: Injective_Exchange_V1beta1_EventNewDerivativeOrders) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs.buyOrders != rhs.buyOrders {return false}
    if lhs.sellOrders != rhs.sellOrders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventCancelSpotOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventCancelSpotOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if let v = self._order {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventCancelSpotOrder, rhs: Injective_Exchange_V1beta1_EventCancelSpotOrder) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs._order != rhs._order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventSpotMarketUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSpotMarketUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "market"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._market) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._market {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventSpotMarketUpdate, rhs: Injective_Exchange_V1beta1_EventSpotMarketUpdate) -> Bool {
    if lhs._market != rhs._market {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventPerpetualMarketUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventPerpetualMarketUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "market"),
    2: .standard(proto: "perpetual_market_info"),
    3: .same(proto: "funding"),
  ]

  fileprivate class _StorageClass {
    var _market: Injective_Exchange_V1beta1_DerivativeMarket? = nil
    var _perpetualMarketInfo: Injective_Exchange_V1beta1_PerpetualMarketInfo? = nil
    var _funding: Injective_Exchange_V1beta1_PerpetualMarketFunding? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _market = source._market
      _perpetualMarketInfo = source._perpetualMarketInfo
      _funding = source._funding
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._market) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._perpetualMarketInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._funding) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._market {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._perpetualMarketInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._funding {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventPerpetualMarketUpdate, rhs: Injective_Exchange_V1beta1_EventPerpetualMarketUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._market != rhs_storage._market {return false}
        if _storage._perpetualMarketInfo != rhs_storage._perpetualMarketInfo {return false}
        if _storage._funding != rhs_storage._funding {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventExpiryFuturesMarketUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventExpiryFuturesMarketUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "market"),
    3: .standard(proto: "expiry_futures_market_info"),
  ]

  fileprivate class _StorageClass {
    var _market: Injective_Exchange_V1beta1_DerivativeMarket? = nil
    var _expiryFuturesMarketInfo: Injective_Exchange_V1beta1_ExpiryFuturesMarketInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _market = source._market
      _expiryFuturesMarketInfo = source._expiryFuturesMarketInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._market) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._expiryFuturesMarketInfo) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._market {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._expiryFuturesMarketInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventExpiryFuturesMarketUpdate, rhs: Injective_Exchange_V1beta1_EventExpiryFuturesMarketUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._market != rhs_storage._market {return false}
        if _storage._expiryFuturesMarketInfo != rhs_storage._expiryFuturesMarketInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventPerpetualMarketFundingUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventPerpetualMarketFundingUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "funding"),
    3: .standard(proto: "is_hourly_funding"),
    4: .standard(proto: "funding_rate"),
    5: .standard(proto: "mark_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._funding) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isHourlyFunding) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fundingRate) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.markPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 1)
    }
    if let v = self._funding {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.isHourlyFunding != false {
      try visitor.visitSingularBoolField(value: self.isHourlyFunding, fieldNumber: 3)
    }
    if !self.fundingRate.isEmpty {
      try visitor.visitSingularStringField(value: self.fundingRate, fieldNumber: 4)
    }
    if !self.markPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.markPrice, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventPerpetualMarketFundingUpdate, rhs: Injective_Exchange_V1beta1_EventPerpetualMarketFundingUpdate) -> Bool {
    if lhs.marketID != rhs.marketID {return false}
    if lhs._funding != rhs._funding {return false}
    if lhs.isHourlyFunding != rhs.isHourlyFunding {return false}
    if lhs.fundingRate != rhs.fundingRate {return false}
    if lhs.markPrice != rhs.markPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventSubaccountDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSubaccountDeposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "src_address"),
    2: .standard(proto: "subaccount_id"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.srcAddress) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.subaccountID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.srcAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.srcAddress, fieldNumber: 1)
    }
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularBytesField(value: self.subaccountID, fieldNumber: 2)
    }
    if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventSubaccountDeposit, rhs: Injective_Exchange_V1beta1_EventSubaccountDeposit) -> Bool {
    if lhs.srcAddress != rhs.srcAddress {return false}
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventSubaccountWithdraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSubaccountWithdraw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .standard(proto: "dst_address"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dstAddress) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularBytesField(value: self.subaccountID, fieldNumber: 1)
    }
    if !self.dstAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.dstAddress, fieldNumber: 2)
    }
    if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventSubaccountWithdraw, rhs: Injective_Exchange_V1beta1_EventSubaccountWithdraw) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs.dstAddress != rhs.dstAddress {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventSubaccountBalanceTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSubaccountBalanceTransfer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "src_subaccount_id"),
    2: .standard(proto: "dst_subaccount_id"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.srcSubaccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dstSubaccountID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.srcSubaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.srcSubaccountID, fieldNumber: 1)
    }
    if !self.dstSubaccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.dstSubaccountID, fieldNumber: 2)
    }
    if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventSubaccountBalanceTransfer, rhs: Injective_Exchange_V1beta1_EventSubaccountBalanceTransfer) -> Bool {
    if lhs.srcSubaccountID != rhs.srcSubaccountID {return false}
    if lhs.dstSubaccountID != rhs.dstSubaccountID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_SubaccountDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubaccountDeposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subaccount_id"),
    2: .same(proto: "deposit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.subaccountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deposit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subaccountID.isEmpty {
      try visitor.visitSingularBytesField(value: self.subaccountID, fieldNumber: 1)
    }
    if let v = self._deposit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_SubaccountDeposit, rhs: Injective_Exchange_V1beta1_SubaccountDeposit) -> Bool {
    if lhs.subaccountID != rhs.subaccountID {return false}
    if lhs._deposit != rhs._deposit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DepositUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DepositUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "deposits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.deposits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if !self.deposits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deposits, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DepositUpdate, rhs: Injective_Exchange_V1beta1_DepositUpdate) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.deposits != rhs.deposits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventBatchDepositUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventBatchDepositUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deposit_updates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.depositUpdates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.depositUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.depositUpdates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventBatchDepositUpdate, rhs: Injective_Exchange_V1beta1_EventBatchDepositUpdate) -> Bool {
    if lhs.depositUpdates != rhs.depositUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_DerivativeMarketOrderCancel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DerivativeMarketOrderCancel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_order"),
    2: .standard(proto: "cancel_quantity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._marketOrder) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cancelQuantity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._marketOrder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.cancelQuantity.isEmpty {
      try visitor.visitSingularStringField(value: self.cancelQuantity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_DerivativeMarketOrderCancel, rhs: Injective_Exchange_V1beta1_DerivativeMarketOrderCancel) -> Bool {
    if lhs._marketOrder != rhs._marketOrder {return false}
    if lhs.cancelQuantity != rhs.cancelQuantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventCancelDerivativeOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventCancelDerivativeOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "market_id"),
    2: .same(proto: "isLimitCancel"),
    3: .standard(proto: "limit_order"),
    4: .standard(proto: "market_order_cancel"),
  ]

  fileprivate class _StorageClass {
    var _marketID: String = String()
    var _isLimitCancel: Bool = false
    var _limitOrder: Injective_Exchange_V1beta1_DerivativeLimitOrder? = nil
    var _marketOrderCancel: Injective_Exchange_V1beta1_DerivativeMarketOrderCancel? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _marketID = source._marketID
      _isLimitCancel = source._isLimitCancel
      _limitOrder = source._limitOrder
      _marketOrderCancel = source._marketOrderCancel
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._marketID) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._isLimitCancel) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._limitOrder) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._marketOrderCancel) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._marketID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._marketID, fieldNumber: 1)
      }
      if _storage._isLimitCancel != false {
        try visitor.visitSingularBoolField(value: _storage._isLimitCancel, fieldNumber: 2)
      }
      if let v = _storage._limitOrder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._marketOrderCancel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventCancelDerivativeOrder, rhs: Injective_Exchange_V1beta1_EventCancelDerivativeOrder) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._marketID != rhs_storage._marketID {return false}
        if _storage._isLimitCancel != rhs_storage._isLimitCancel {return false}
        if _storage._limitOrder != rhs_storage._limitOrder {return false}
        if _storage._marketOrderCancel != rhs_storage._marketOrderCancel {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_PointsMultiplier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PointsMultiplier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "maker_points_multiplier"),
    2: .standard(proto: "taker_points_multiplier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.makerPointsMultiplier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.takerPointsMultiplier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.makerPointsMultiplier.isEmpty {
      try visitor.visitSingularStringField(value: self.makerPointsMultiplier, fieldNumber: 1)
    }
    if !self.takerPointsMultiplier.isEmpty {
      try visitor.visitSingularStringField(value: self.takerPointsMultiplier, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_PointsMultiplier, rhs: Injective_Exchange_V1beta1_PointsMultiplier) -> Bool {
    if lhs.makerPointsMultiplier != rhs.makerPointsMultiplier {return false}
    if lhs.takerPointsMultiplier != rhs.takerPointsMultiplier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TradingRewardCampaignBoostInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradingRewardCampaignBoostInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "boosted_spot_market_ids"),
    2: .standard(proto: "spot_market_multipliers"),
    3: .standard(proto: "boosted_derivative_market_ids"),
    4: .standard(proto: "derivative_market_multipliers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.boostedSpotMarketIds) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.spotMarketMultipliers) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.boostedDerivativeMarketIds) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.derivativeMarketMultipliers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.boostedSpotMarketIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.boostedSpotMarketIds, fieldNumber: 1)
    }
    if !self.spotMarketMultipliers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spotMarketMultipliers, fieldNumber: 2)
    }
    if !self.boostedDerivativeMarketIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.boostedDerivativeMarketIds, fieldNumber: 3)
    }
    if !self.derivativeMarketMultipliers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.derivativeMarketMultipliers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TradingRewardCampaignBoostInfo, rhs: Injective_Exchange_V1beta1_TradingRewardCampaignBoostInfo) -> Bool {
    if lhs.boostedSpotMarketIds != rhs.boostedSpotMarketIds {return false}
    if lhs.spotMarketMultipliers != rhs.spotMarketMultipliers {return false}
    if lhs.boostedDerivativeMarketIds != rhs.boostedDerivativeMarketIds {return false}
    if lhs.derivativeMarketMultipliers != rhs.derivativeMarketMultipliers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_CampaignRewardPool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CampaignRewardPool"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_timestamp"),
    2: .standard(proto: "max_campaign_rewards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.startTimestamp) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.maxCampaignRewards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.startTimestamp, fieldNumber: 1)
    }
    if !self.maxCampaignRewards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.maxCampaignRewards, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_CampaignRewardPool, rhs: Injective_Exchange_V1beta1_CampaignRewardPool) -> Bool {
    if lhs.startTimestamp != rhs.startTimestamp {return false}
    if lhs.maxCampaignRewards != rhs.maxCampaignRewards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_TradingRewardCampaignInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TradingRewardCampaignInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "campaign_duration_seconds"),
    2: .standard(proto: "quote_denoms"),
    3: .standard(proto: "trading_reward_boost_info"),
    4: .standard(proto: "disqualified_market_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.campaignDurationSeconds) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.quoteDenoms) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tradingRewardBoostInfo) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.disqualifiedMarketIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.campaignDurationSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.campaignDurationSeconds, fieldNumber: 1)
    }
    if !self.quoteDenoms.isEmpty {
      try visitor.visitRepeatedStringField(value: self.quoteDenoms, fieldNumber: 2)
    }
    if let v = self._tradingRewardBoostInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.disqualifiedMarketIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.disqualifiedMarketIds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_TradingRewardCampaignInfo, rhs: Injective_Exchange_V1beta1_TradingRewardCampaignInfo) -> Bool {
    if lhs.campaignDurationSeconds != rhs.campaignDurationSeconds {return false}
    if lhs.quoteDenoms != rhs.quoteDenoms {return false}
    if lhs._tradingRewardBoostInfo != rhs._tradingRewardBoostInfo {return false}
    if lhs.disqualifiedMarketIds != rhs.disqualifiedMarketIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_FeeDiscountTierInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeDiscountTierInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "maker_discount_rate"),
    2: .standard(proto: "taker_discount_rate"),
    3: .standard(proto: "staked_amount"),
    4: .standard(proto: "fee_paid_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.makerDiscountRate) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.takerDiscountRate) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.stakedAmount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.feePaidAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.makerDiscountRate.isEmpty {
      try visitor.visitSingularStringField(value: self.makerDiscountRate, fieldNumber: 1)
    }
    if !self.takerDiscountRate.isEmpty {
      try visitor.visitSingularStringField(value: self.takerDiscountRate, fieldNumber: 2)
    }
    if !self.stakedAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.stakedAmount, fieldNumber: 3)
    }
    if !self.feePaidAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.feePaidAmount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_FeeDiscountTierInfo, rhs: Injective_Exchange_V1beta1_FeeDiscountTierInfo) -> Bool {
    if lhs.makerDiscountRate != rhs.makerDiscountRate {return false}
    if lhs.takerDiscountRate != rhs.takerDiscountRate {return false}
    if lhs.stakedAmount != rhs.stakedAmount {return false}
    if lhs.feePaidAmount != rhs.feePaidAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_FeeDiscountSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeDiscountSchedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bucket_count"),
    2: .standard(proto: "bucket_duration"),
    3: .standard(proto: "quote_denoms"),
    4: .standard(proto: "tier_infos"),
    5: .standard(proto: "disqualified_market_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.bucketCount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.bucketDuration) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.quoteDenoms) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.tierInfos) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.disqualifiedMarketIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bucketCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.bucketCount, fieldNumber: 1)
    }
    if self.bucketDuration != 0 {
      try visitor.visitSingularInt64Field(value: self.bucketDuration, fieldNumber: 2)
    }
    if !self.quoteDenoms.isEmpty {
      try visitor.visitRepeatedStringField(value: self.quoteDenoms, fieldNumber: 3)
    }
    if !self.tierInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tierInfos, fieldNumber: 4)
    }
    if !self.disqualifiedMarketIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.disqualifiedMarketIds, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_FeeDiscountSchedule, rhs: Injective_Exchange_V1beta1_FeeDiscountSchedule) -> Bool {
    if lhs.bucketCount != rhs.bucketCount {return false}
    if lhs.bucketDuration != rhs.bucketDuration {return false}
    if lhs.quoteDenoms != rhs.quoteDenoms {return false}
    if lhs.tierInfos != rhs.tierInfos {return false}
    if lhs.disqualifiedMarketIds != rhs.disqualifiedMarketIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_FeeDiscountTierTTL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeDiscountTierTTL"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tier"),
    2: .standard(proto: "ttl_timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.tier) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.ttlTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tier != 0 {
      try visitor.visitSingularUInt64Field(value: self.tier, fieldNumber: 1)
    }
    if self.ttlTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.ttlTimestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_FeeDiscountTierTTL, rhs: Injective_Exchange_V1beta1_FeeDiscountTierTTL) -> Bool {
    if lhs.tier != rhs.tier {return false}
    if lhs.ttlTimestamp != rhs.ttlTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventFeeDiscountSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventFeeDiscountSchedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "schedule"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._schedule) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._schedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventFeeDiscountSchedule, rhs: Injective_Exchange_V1beta1_EventFeeDiscountSchedule) -> Bool {
    if lhs._schedule != rhs._schedule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventTradingRewardCampaignUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventTradingRewardCampaignUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "campaign_info"),
    2: .standard(proto: "campaign_reward_pools"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._campaignInfo) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.campaignRewardPools) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._campaignInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.campaignRewardPools.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.campaignRewardPools, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventTradingRewardCampaignUpdate, rhs: Injective_Exchange_V1beta1_EventTradingRewardCampaignUpdate) -> Bool {
    if lhs._campaignInfo != rhs._campaignInfo {return false}
    if lhs.campaignRewardPools != rhs.campaignRewardPools {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_AccountRewards: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountRewards"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "rewards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rewards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if !self.rewards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rewards, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_AccountRewards, rhs: Injective_Exchange_V1beta1_AccountRewards) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.rewards != rhs.rewards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Exchange_V1beta1_EventTradingRewardDistribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventTradingRewardDistribution"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_rewards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accountRewards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountRewards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accountRewards, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Exchange_V1beta1_EventTradingRewardDistribution, rhs: Injective_Exchange_V1beta1_EventTradingRewardDistribution) -> Bool {
    if lhs.accountRewards != rhs.accountRewards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
