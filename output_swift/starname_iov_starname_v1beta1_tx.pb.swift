// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: starname/iov/starname/v1beta1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MsgAddAccountCertificate is the message used when a user wants to add new certificates to his account
struct Starnamed_X_Starname_V1beta1_MsgAddAccountCertificate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Domain is the domain of the account
  var domain: String = String()

  /// Name is the name of the account
  var name: String = String()

  /// Owner is the owner of the account
  var owner: String = String()

  /// Payer is the address of the entity that pays the product and transaction fees
  var payer: String = String()

  /// NewCertificate is the new certificate to add
  var newCertificate: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddAccountCertificateResponse returns an empty response.
struct Starnamed_X_Starname_V1beta1_MsgAddAccountCertificateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteAccountCertificate is the request model used to remove certificates from an account
struct Starnamed_X_Starname_V1beta1_MsgDeleteAccountCertificate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Domain is the domain of the account
  var domain: String = String()

  /// Name is the name of the account
  var name: String = String()

  /// Owner is the owner of the account
  var owner: String = String()

  /// Payer is the address of the entity that pays the product and transaction fees
  var payer: String = String()

  /// DeleteCertificate is the certificate to delete
  var deleteCertificate: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteAccountCertificateResponse returns an empty response.
struct Starnamed_X_Starname_V1beta1_MsgDeleteAccountCertificateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteAccount is the request model used to delete an account
struct Starnamed_X_Starname_V1beta1_MsgDeleteAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Domain is the domain of the account
  var domain: String = String()

  /// Name is the name of the account
  var name: String = String()

  /// Owner is the owner of the account
  var owner: String = String()

  /// Payer is the address of the entity that pays the product and transaction fees
  var payer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteAccountResponse returns an empty response.
struct Starnamed_X_Starname_V1beta1_MsgDeleteAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteDomain is the request model to delete a domain
struct Starnamed_X_Starname_V1beta1_MsgDeleteDomain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Domain is the domain of the account
  var domain: String = String()

  /// Owner is the owner of the account
  var owner: String = String()

  /// Payer is the address of the entity that pays the product and transaction fees
  var payer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDeleteDomainResponse returns an empty response.
struct Starnamed_X_Starname_V1beta1_MsgDeleteDomainResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRegisterAccount is the request model used to register new accounts
struct Starnamed_X_Starname_V1beta1_MsgRegisterAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Domain is the domain of the account
  var domain: String = String()

  /// Name is the name of the account
  var name: String = String()

  /// Owner is the owner of the account
  var owner: String = String()

  /// Payer is the address of the entity that pays the product and transaction fees
  var payer: String = String()

  /// Broker is the account that facilitated the transaction
  var broker: String = String()

  /// Registerer is the user who registers this account
  var registerer: String = String()

  /// Resources are the blockchain addresses of the account
  var resources: [Starnamed_X_Starname_V1beta1_Resource] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRegisterAccountResponse returns an empty response.
struct Starnamed_X_Starname_V1beta1_MsgRegisterAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRegisterDomain is the request used to register new domains
struct Starnamed_X_Starname_V1beta1_MsgRegisterDomain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var admin: String = String()

  /// Payer is the address of the entity that pays the product and transaction fees
  var payer: String = String()

  /// Broker is the account that facilitated the transaction
  var broker: String = String()

  /// DomainType defines the type of the domain
  var domainType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRegisterDomainResponse returns an empty response.
struct Starnamed_X_Starname_V1beta1_MsgRegisterDomainResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRenewAccount is the request model used to renew accounts
struct Starnamed_X_Starname_V1beta1_MsgRenewAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Domain is the domain of the account
  var domain: String = String()

  /// Name is the name of the account
  var name: String = String()

  /// Signer is the signer of the request
  var signer: String = String()

  /// Payer is the address of the entity that pays the product and transaction fees
  var payer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRenewAccountResponse returns an empty response.
struct Starnamed_X_Starname_V1beta1_MsgRenewAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRenewDomain is the request model used to renew a domain
struct Starnamed_X_Starname_V1beta1_MsgRenewDomain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Domain is the domain of the account
  var domain: String = String()

  /// Signer is the signer of the request
  var signer: String = String()

  /// Payer is the address of the entity that pays the product and transaction fees
  var payer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRegisterDomain returns an empty response.
struct Starnamed_X_Starname_V1beta1_MsgRenewDomainResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgReplaceAccountResources is the request model used to renew resources associated with an account
struct Starnamed_X_Starname_V1beta1_MsgReplaceAccountResources {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Domain is the domain of the account
  var domain: String = String()

  /// Name is the name of the account
  var name: String = String()

  /// Owner is the owner of the account
  var owner: String = String()

  /// Payer is the address of the entity that pays the product and transaction fees
  var payer: String = String()

  /// NewResources are the new resources
  var newResources: [Starnamed_X_Starname_V1beta1_Resource] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgReplaceAccountResourcesResponse
struct Starnamed_X_Starname_V1beta1_MsgReplaceAccountResourcesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgReplaceAccountMetadata is the function used to set accounts metadata
struct Starnamed_X_Starname_V1beta1_MsgReplaceAccountMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Domain is the domain of the account
  var domain: String = String()

  /// Name is the name of the account
  var name: String = String()

  /// Owner is the owner of the account
  var owner: String = String()

  /// Payer is the address of the entity that pays the product and transaction fees
  var payer: String = String()

  /// NewMetadataURI is the metadata URI of the account
  /// we want to update or insert
  var newMetadataUri: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgReplaceAccountMetadataResponse returns an empty response.
struct Starnamed_X_Starname_V1beta1_MsgReplaceAccountMetadataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgTransferAccount is the request model used to transfer accounts
struct Starnamed_X_Starname_V1beta1_MsgTransferAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Domain is the domain of the account
  var domain: String = String()

  /// Name is the name of the account
  var name: String = String()

  /// Owner is the owner of the account
  var owner: String = String()

  /// Payer is the address of the entity that pays the product and transaction fees
  var payer: String = String()

  /// NewOwner is the new owner of the account
  var newOwner: String = String()

  /// ToReset if true, removes all old data from account
  var reset: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgTransferAccountResponse returns an empty response.
struct Starnamed_X_Starname_V1beta1_MsgTransferAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgTransferDomain is the request model used to transfer a domain
struct Starnamed_X_Starname_V1beta1_MsgTransferDomain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Domain is the name of the domain
  var domain: String = String()

  /// Owner is the owner of the domain
  var owner: String = String()

  /// Payer is the address of the entity that pays the product and transaction fees
  var payer: String = String()

  /// NewAdmin is the  new owner of the domain
  var newAdmin: String = String()

  /// TransferFlag controls the operations that occurs on a domain's accounts
  var transferFlag: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgTransferDomainResponse returns an empty response.
struct Starnamed_X_Starname_V1beta1_MsgTransferDomainResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "starnamed.x.starname.v1beta1"

extension Starnamed_X_Starname_V1beta1_MsgAddAccountCertificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddAccountCertificate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "name"),
    3: .same(proto: "owner"),
    4: .same(proto: "payer"),
    5: .standard(proto: "new_certificate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.payer) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.newCertificate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 3)
    }
    if !self.payer.isEmpty {
      try visitor.visitSingularStringField(value: self.payer, fieldNumber: 4)
    }
    if !self.newCertificate.isEmpty {
      try visitor.visitSingularBytesField(value: self.newCertificate, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgAddAccountCertificate, rhs: Starnamed_X_Starname_V1beta1_MsgAddAccountCertificate) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.name != rhs.name {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.payer != rhs.payer {return false}
    if lhs.newCertificate != rhs.newCertificate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgAddAccountCertificateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddAccountCertificateResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgAddAccountCertificateResponse, rhs: Starnamed_X_Starname_V1beta1_MsgAddAccountCertificateResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgDeleteAccountCertificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteAccountCertificate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "name"),
    3: .same(proto: "owner"),
    4: .same(proto: "payer"),
    5: .standard(proto: "delete_certificate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.payer) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.deleteCertificate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 3)
    }
    if !self.payer.isEmpty {
      try visitor.visitSingularStringField(value: self.payer, fieldNumber: 4)
    }
    if !self.deleteCertificate.isEmpty {
      try visitor.visitSingularBytesField(value: self.deleteCertificate, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgDeleteAccountCertificate, rhs: Starnamed_X_Starname_V1beta1_MsgDeleteAccountCertificate) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.name != rhs.name {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.payer != rhs.payer {return false}
    if lhs.deleteCertificate != rhs.deleteCertificate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgDeleteAccountCertificateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteAccountCertificateResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgDeleteAccountCertificateResponse, rhs: Starnamed_X_Starname_V1beta1_MsgDeleteAccountCertificateResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgDeleteAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteAccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "name"),
    3: .same(proto: "owner"),
    4: .same(proto: "payer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.payer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 3)
    }
    if !self.payer.isEmpty {
      try visitor.visitSingularStringField(value: self.payer, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgDeleteAccount, rhs: Starnamed_X_Starname_V1beta1_MsgDeleteAccount) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.name != rhs.name {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.payer != rhs.payer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgDeleteAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteAccountResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgDeleteAccountResponse, rhs: Starnamed_X_Starname_V1beta1_MsgDeleteAccountResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgDeleteDomain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteDomain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "owner"),
    3: .same(proto: "payer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.payer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 2)
    }
    if !self.payer.isEmpty {
      try visitor.visitSingularStringField(value: self.payer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgDeleteDomain, rhs: Starnamed_X_Starname_V1beta1_MsgDeleteDomain) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.payer != rhs.payer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgDeleteDomainResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDeleteDomainResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgDeleteDomainResponse, rhs: Starnamed_X_Starname_V1beta1_MsgDeleteDomainResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgRegisterAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRegisterAccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "name"),
    3: .same(proto: "owner"),
    4: .same(proto: "payer"),
    5: .same(proto: "broker"),
    6: .same(proto: "registerer"),
    7: .same(proto: "resources"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.payer) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.broker) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.registerer) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.resources) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 3)
    }
    if !self.payer.isEmpty {
      try visitor.visitSingularStringField(value: self.payer, fieldNumber: 4)
    }
    if !self.broker.isEmpty {
      try visitor.visitSingularStringField(value: self.broker, fieldNumber: 5)
    }
    if !self.registerer.isEmpty {
      try visitor.visitSingularStringField(value: self.registerer, fieldNumber: 6)
    }
    if !self.resources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resources, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgRegisterAccount, rhs: Starnamed_X_Starname_V1beta1_MsgRegisterAccount) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.name != rhs.name {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.payer != rhs.payer {return false}
    if lhs.broker != rhs.broker {return false}
    if lhs.registerer != rhs.registerer {return false}
    if lhs.resources != rhs.resources {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgRegisterAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRegisterAccountResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgRegisterAccountResponse, rhs: Starnamed_X_Starname_V1beta1_MsgRegisterAccountResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgRegisterDomain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRegisterDomain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "admin"),
    3: .same(proto: "payer"),
    4: .same(proto: "broker"),
    5: .standard(proto: "domain_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.admin) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.payer) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.broker) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.domainType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.admin.isEmpty {
      try visitor.visitSingularStringField(value: self.admin, fieldNumber: 2)
    }
    if !self.payer.isEmpty {
      try visitor.visitSingularStringField(value: self.payer, fieldNumber: 3)
    }
    if !self.broker.isEmpty {
      try visitor.visitSingularStringField(value: self.broker, fieldNumber: 4)
    }
    if !self.domainType.isEmpty {
      try visitor.visitSingularStringField(value: self.domainType, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgRegisterDomain, rhs: Starnamed_X_Starname_V1beta1_MsgRegisterDomain) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.admin != rhs.admin {return false}
    if lhs.payer != rhs.payer {return false}
    if lhs.broker != rhs.broker {return false}
    if lhs.domainType != rhs.domainType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgRegisterDomainResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRegisterDomainResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgRegisterDomainResponse, rhs: Starnamed_X_Starname_V1beta1_MsgRegisterDomainResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgRenewAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRenewAccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "name"),
    3: .same(proto: "signer"),
    4: .same(proto: "payer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.payer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 3)
    }
    if !self.payer.isEmpty {
      try visitor.visitSingularStringField(value: self.payer, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgRenewAccount, rhs: Starnamed_X_Starname_V1beta1_MsgRenewAccount) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.name != rhs.name {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.payer != rhs.payer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgRenewAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRenewAccountResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgRenewAccountResponse, rhs: Starnamed_X_Starname_V1beta1_MsgRenewAccountResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgRenewDomain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRenewDomain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "signer"),
    3: .same(proto: "payer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.payer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 2)
    }
    if !self.payer.isEmpty {
      try visitor.visitSingularStringField(value: self.payer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgRenewDomain, rhs: Starnamed_X_Starname_V1beta1_MsgRenewDomain) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.payer != rhs.payer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgRenewDomainResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRenewDomainResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgRenewDomainResponse, rhs: Starnamed_X_Starname_V1beta1_MsgRenewDomainResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgReplaceAccountResources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgReplaceAccountResources"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "name"),
    3: .same(proto: "owner"),
    4: .same(proto: "payer"),
    5: .standard(proto: "new_resources"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.payer) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.newResources) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 3)
    }
    if !self.payer.isEmpty {
      try visitor.visitSingularStringField(value: self.payer, fieldNumber: 4)
    }
    if !self.newResources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.newResources, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgReplaceAccountResources, rhs: Starnamed_X_Starname_V1beta1_MsgReplaceAccountResources) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.name != rhs.name {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.payer != rhs.payer {return false}
    if lhs.newResources != rhs.newResources {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgReplaceAccountResourcesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgReplaceAccountResourcesResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgReplaceAccountResourcesResponse, rhs: Starnamed_X_Starname_V1beta1_MsgReplaceAccountResourcesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgReplaceAccountMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgReplaceAccountMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "name"),
    3: .same(proto: "owner"),
    4: .same(proto: "payer"),
    5: .standard(proto: "new_metadata_uri"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.payer) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.newMetadataUri) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 3)
    }
    if !self.payer.isEmpty {
      try visitor.visitSingularStringField(value: self.payer, fieldNumber: 4)
    }
    if !self.newMetadataUri.isEmpty {
      try visitor.visitSingularStringField(value: self.newMetadataUri, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgReplaceAccountMetadata, rhs: Starnamed_X_Starname_V1beta1_MsgReplaceAccountMetadata) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.name != rhs.name {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.payer != rhs.payer {return false}
    if lhs.newMetadataUri != rhs.newMetadataUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgReplaceAccountMetadataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgReplaceAccountMetadataResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgReplaceAccountMetadataResponse, rhs: Starnamed_X_Starname_V1beta1_MsgReplaceAccountMetadataResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgTransferAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgTransferAccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "name"),
    3: .same(proto: "owner"),
    4: .same(proto: "payer"),
    5: .standard(proto: "new_owner"),
    6: .same(proto: "reset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.payer) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.newOwner) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.reset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 3)
    }
    if !self.payer.isEmpty {
      try visitor.visitSingularStringField(value: self.payer, fieldNumber: 4)
    }
    if !self.newOwner.isEmpty {
      try visitor.visitSingularStringField(value: self.newOwner, fieldNumber: 5)
    }
    if self.reset != false {
      try visitor.visitSingularBoolField(value: self.reset, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgTransferAccount, rhs: Starnamed_X_Starname_V1beta1_MsgTransferAccount) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.name != rhs.name {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.payer != rhs.payer {return false}
    if lhs.newOwner != rhs.newOwner {return false}
    if lhs.reset != rhs.reset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgTransferAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgTransferAccountResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgTransferAccountResponse, rhs: Starnamed_X_Starname_V1beta1_MsgTransferAccountResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgTransferDomain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgTransferDomain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "owner"),
    3: .same(proto: "payer"),
    4: .standard(proto: "new_admin"),
    5: .standard(proto: "transfer_flag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.payer) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.newAdmin) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.transferFlag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 2)
    }
    if !self.payer.isEmpty {
      try visitor.visitSingularStringField(value: self.payer, fieldNumber: 3)
    }
    if !self.newAdmin.isEmpty {
      try visitor.visitSingularStringField(value: self.newAdmin, fieldNumber: 4)
    }
    if self.transferFlag != 0 {
      try visitor.visitSingularInt64Field(value: self.transferFlag, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgTransferDomain, rhs: Starnamed_X_Starname_V1beta1_MsgTransferDomain) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.payer != rhs.payer {return false}
    if lhs.newAdmin != rhs.newAdmin {return false}
    if lhs.transferFlag != rhs.transferFlag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Starnamed_X_Starname_V1beta1_MsgTransferDomainResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgTransferDomainResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Starnamed_X_Starname_V1beta1_MsgTransferDomainResponse, rhs: Starnamed_X_Starname_V1beta1_MsgTransferDomainResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
