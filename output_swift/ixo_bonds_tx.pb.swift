// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ixo/bonds/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MsgCreateBond defines a message for creating a new bond.
struct Bonds_MsgCreateBond {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String {
    get {return _storage._bondDid}
    set {_uniqueStorage()._bondDid = newValue}
  }

  var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var functionType: String {
    get {return _storage._functionType}
    set {_uniqueStorage()._functionType = newValue}
  }

  var functionParameters: [Bonds_FunctionParam] {
    get {return _storage._functionParameters}
    set {_uniqueStorage()._functionParameters = newValue}
  }

  var creatorDid: String {
    get {return _storage._creatorDid}
    set {_uniqueStorage()._creatorDid = newValue}
  }

  var controllerDid: String {
    get {return _storage._controllerDid}
    set {_uniqueStorage()._controllerDid = newValue}
  }

  var reserveTokens: [String] {
    get {return _storage._reserveTokens}
    set {_uniqueStorage()._reserveTokens = newValue}
  }

  var txFeePercentage: String {
    get {return _storage._txFeePercentage}
    set {_uniqueStorage()._txFeePercentage = newValue}
  }

  var exitFeePercentage: String {
    get {return _storage._exitFeePercentage}
    set {_uniqueStorage()._exitFeePercentage = newValue}
  }

  var feeAddress: String {
    get {return _storage._feeAddress}
    set {_uniqueStorage()._feeAddress = newValue}
  }

  var reserveWithdrawalAddress: String {
    get {return _storage._reserveWithdrawalAddress}
    set {_uniqueStorage()._reserveWithdrawalAddress = newValue}
  }

  var maxSupply: Cosmos_Base_V1beta1_Coin {
    get {return _storage._maxSupply ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._maxSupply = newValue}
  }
  /// Returns true if `maxSupply` has been explicitly set.
  var hasMaxSupply: Bool {return _storage._maxSupply != nil}
  /// Clears the value of `maxSupply`. Subsequent reads from it will return its default value.
  mutating func clearMaxSupply() {_uniqueStorage()._maxSupply = nil}

  var orderQuantityLimits: [Cosmos_Base_V1beta1_Coin] {
    get {return _storage._orderQuantityLimits}
    set {_uniqueStorage()._orderQuantityLimits = newValue}
  }

  var sanityRate: String {
    get {return _storage._sanityRate}
    set {_uniqueStorage()._sanityRate = newValue}
  }

  var sanityMarginPercentage: String {
    get {return _storage._sanityMarginPercentage}
    set {_uniqueStorage()._sanityMarginPercentage = newValue}
  }

  var allowSells: Bool {
    get {return _storage._allowSells}
    set {_uniqueStorage()._allowSells = newValue}
  }

  var allowReserveWithdrawals: Bool {
    get {return _storage._allowReserveWithdrawals}
    set {_uniqueStorage()._allowReserveWithdrawals = newValue}
  }

  var alphaBond: Bool {
    get {return _storage._alphaBond}
    set {_uniqueStorage()._alphaBond = newValue}
  }

  var batchBlocks: String {
    get {return _storage._batchBlocks}
    set {_uniqueStorage()._batchBlocks = newValue}
  }

  var outcomePayment: String {
    get {return _storage._outcomePayment}
    set {_uniqueStorage()._outcomePayment = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MsgCreateBondResponse defines the Msg/CreateBond response type.
struct Bonds_MsgCreateBondResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgEditBond defines a message for editing an existing bond.
struct Bonds_MsgEditBond {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var name: String = String()

  var description_p: String = String()

  var orderQuantityLimits: String = String()

  var sanityRate: String = String()

  var sanityMarginPercentage: String = String()

  var editorDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgEditBondResponse defines the Msg/EditBond response type.
struct Bonds_MsgEditBondResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgSetNextAlpha defines a message for editing a bond's alpha parameter.
struct Bonds_MsgSetNextAlpha {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var alpha: String = String()

  var editorDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Bonds_MsgSetNextAlphaResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateBondState defines a message for updating a bond's current state.
struct Bonds_MsgUpdateBondState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var state: String = String()

  var editorDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgUpdateBondStateResponse defines the Msg/UpdateBondState response type.
struct Bonds_MsgUpdateBondStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgBuy defines a message for buying from a bond.
struct Bonds_MsgBuy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var buyerDid: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var maxPrices: [Cosmos_Base_V1beta1_Coin] = []

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgBuyResponse defines the Msg/Buy response type.
struct Bonds_MsgBuyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgSell defines a message for selling from a bond.
struct Bonds_MsgSell {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sellerDid: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgSellResponse defines the Msg/Sell response type.
struct Bonds_MsgSellResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgSwap defines a message for swapping from one reserve bond token to another.
struct Bonds_MsgSwap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var swapperDid: String = String()

  var bondDid: String = String()

  var from: Cosmos_Base_V1beta1_Coin {
    get {return _from ?? Cosmos_Base_V1beta1_Coin()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  mutating func clearFrom() {self._from = nil}

  var toToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _from: Cosmos_Base_V1beta1_Coin? = nil
}

/// MsgSwapResponse defines the Msg/Swap response type.
struct Bonds_MsgSwapResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgMakeOutcomePayment defines a message for making an outcome payment to a bond.
struct Bonds_MsgMakeOutcomePayment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var senderDid: String = String()

  var amount: String = String()

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgMakeOutcomePaymentResponse defines the Msg/MakeOutcomePayment response type.
struct Bonds_MsgMakeOutcomePaymentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgWithdrawShare defines a message for withdrawing a share from a bond that is in the SETTLE stage.
struct Bonds_MsgWithdrawShare {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var recipientDid: String = String()

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgWithdrawShareResponse defines the Msg/WithdrawShare response type.
struct Bonds_MsgWithdrawShareResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgWithdrawReserve defines a message for withdrawing reserve from a bond.
struct Bonds_MsgWithdrawReserve {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var withdrawerDid: String = String()

  var amount: [Cosmos_Base_V1beta1_Coin] = []

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgWithdrawReserveResponse defines the Msg/WithdrawReserve response type.
struct Bonds_MsgWithdrawReserveResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bonds"

extension Bonds_MsgCreateBond: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateBond"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
    2: .same(proto: "token"),
    3: .same(proto: "name"),
    4: .same(proto: "description"),
    5: .standard(proto: "function_type"),
    6: .standard(proto: "function_parameters"),
    7: .standard(proto: "creator_did"),
    8: .standard(proto: "controller_did"),
    9: .standard(proto: "reserve_tokens"),
    10: .standard(proto: "tx_fee_percentage"),
    11: .standard(proto: "exit_fee_percentage"),
    12: .standard(proto: "fee_address"),
    13: .standard(proto: "reserve_withdrawal_address"),
    14: .standard(proto: "max_supply"),
    15: .standard(proto: "order_quantity_limits"),
    16: .standard(proto: "sanity_rate"),
    17: .standard(proto: "sanity_margin_percentage"),
    18: .standard(proto: "allow_sells"),
    19: .standard(proto: "allow_reserve_withdrawals"),
    20: .standard(proto: "alpha_bond"),
    21: .standard(proto: "batch_blocks"),
    22: .standard(proto: "outcome_payment"),
  ]

  fileprivate class _StorageClass {
    var _bondDid: String = String()
    var _token: String = String()
    var _name: String = String()
    var _description_p: String = String()
    var _functionType: String = String()
    var _functionParameters: [Bonds_FunctionParam] = []
    var _creatorDid: String = String()
    var _controllerDid: String = String()
    var _reserveTokens: [String] = []
    var _txFeePercentage: String = String()
    var _exitFeePercentage: String = String()
    var _feeAddress: String = String()
    var _reserveWithdrawalAddress: String = String()
    var _maxSupply: Cosmos_Base_V1beta1_Coin? = nil
    var _orderQuantityLimits: [Cosmos_Base_V1beta1_Coin] = []
    var _sanityRate: String = String()
    var _sanityMarginPercentage: String = String()
    var _allowSells: Bool = false
    var _allowReserveWithdrawals: Bool = false
    var _alphaBond: Bool = false
    var _batchBlocks: String = String()
    var _outcomePayment: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _bondDid = source._bondDid
      _token = source._token
      _name = source._name
      _description_p = source._description_p
      _functionType = source._functionType
      _functionParameters = source._functionParameters
      _creatorDid = source._creatorDid
      _controllerDid = source._controllerDid
      _reserveTokens = source._reserveTokens
      _txFeePercentage = source._txFeePercentage
      _exitFeePercentage = source._exitFeePercentage
      _feeAddress = source._feeAddress
      _reserveWithdrawalAddress = source._reserveWithdrawalAddress
      _maxSupply = source._maxSupply
      _orderQuantityLimits = source._orderQuantityLimits
      _sanityRate = source._sanityRate
      _sanityMarginPercentage = source._sanityMarginPercentage
      _allowSells = source._allowSells
      _allowReserveWithdrawals = source._allowReserveWithdrawals
      _alphaBond = source._alphaBond
      _batchBlocks = source._batchBlocks
      _outcomePayment = source._outcomePayment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._bondDid) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._token) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._functionType) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._functionParameters) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._creatorDid) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._controllerDid) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._reserveTokens) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._txFeePercentage) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._exitFeePercentage) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._feeAddress) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._reserveWithdrawalAddress) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._maxSupply) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._orderQuantityLimits) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._sanityRate) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._sanityMarginPercentage) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._allowSells) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._allowReserveWithdrawals) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._alphaBond) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._batchBlocks) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._outcomePayment) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._bondDid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bondDid, fieldNumber: 1)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 4)
      }
      if !_storage._functionType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._functionType, fieldNumber: 5)
      }
      if !_storage._functionParameters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._functionParameters, fieldNumber: 6)
      }
      if !_storage._creatorDid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._creatorDid, fieldNumber: 7)
      }
      if !_storage._controllerDid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._controllerDid, fieldNumber: 8)
      }
      if !_storage._reserveTokens.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._reserveTokens, fieldNumber: 9)
      }
      if !_storage._txFeePercentage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._txFeePercentage, fieldNumber: 10)
      }
      if !_storage._exitFeePercentage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exitFeePercentage, fieldNumber: 11)
      }
      if !_storage._feeAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._feeAddress, fieldNumber: 12)
      }
      if !_storage._reserveWithdrawalAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reserveWithdrawalAddress, fieldNumber: 13)
      }
      if let v = _storage._maxSupply {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if !_storage._orderQuantityLimits.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._orderQuantityLimits, fieldNumber: 15)
      }
      if !_storage._sanityRate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sanityRate, fieldNumber: 16)
      }
      if !_storage._sanityMarginPercentage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sanityMarginPercentage, fieldNumber: 17)
      }
      if _storage._allowSells != false {
        try visitor.visitSingularBoolField(value: _storage._allowSells, fieldNumber: 18)
      }
      if _storage._allowReserveWithdrawals != false {
        try visitor.visitSingularBoolField(value: _storage._allowReserveWithdrawals, fieldNumber: 19)
      }
      if _storage._alphaBond != false {
        try visitor.visitSingularBoolField(value: _storage._alphaBond, fieldNumber: 20)
      }
      if !_storage._batchBlocks.isEmpty {
        try visitor.visitSingularStringField(value: _storage._batchBlocks, fieldNumber: 21)
      }
      if !_storage._outcomePayment.isEmpty {
        try visitor.visitSingularStringField(value: _storage._outcomePayment, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgCreateBond, rhs: Bonds_MsgCreateBond) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._bondDid != rhs_storage._bondDid {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._functionType != rhs_storage._functionType {return false}
        if _storage._functionParameters != rhs_storage._functionParameters {return false}
        if _storage._creatorDid != rhs_storage._creatorDid {return false}
        if _storage._controllerDid != rhs_storage._controllerDid {return false}
        if _storage._reserveTokens != rhs_storage._reserveTokens {return false}
        if _storage._txFeePercentage != rhs_storage._txFeePercentage {return false}
        if _storage._exitFeePercentage != rhs_storage._exitFeePercentage {return false}
        if _storage._feeAddress != rhs_storage._feeAddress {return false}
        if _storage._reserveWithdrawalAddress != rhs_storage._reserveWithdrawalAddress {return false}
        if _storage._maxSupply != rhs_storage._maxSupply {return false}
        if _storage._orderQuantityLimits != rhs_storage._orderQuantityLimits {return false}
        if _storage._sanityRate != rhs_storage._sanityRate {return false}
        if _storage._sanityMarginPercentage != rhs_storage._sanityMarginPercentage {return false}
        if _storage._allowSells != rhs_storage._allowSells {return false}
        if _storage._allowReserveWithdrawals != rhs_storage._allowReserveWithdrawals {return false}
        if _storage._alphaBond != rhs_storage._alphaBond {return false}
        if _storage._batchBlocks != rhs_storage._batchBlocks {return false}
        if _storage._outcomePayment != rhs_storage._outcomePayment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgCreateBondResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateBondResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgCreateBondResponse, rhs: Bonds_MsgCreateBondResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgEditBond: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgEditBond"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .standard(proto: "order_quantity_limits"),
    5: .standard(proto: "sanity_rate"),
    6: .standard(proto: "sanity_margin_percentage"),
    7: .standard(proto: "editor_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.orderQuantityLimits) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.sanityRate) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.sanityMarginPercentage) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.editorDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.orderQuantityLimits.isEmpty {
      try visitor.visitSingularStringField(value: self.orderQuantityLimits, fieldNumber: 4)
    }
    if !self.sanityRate.isEmpty {
      try visitor.visitSingularStringField(value: self.sanityRate, fieldNumber: 5)
    }
    if !self.sanityMarginPercentage.isEmpty {
      try visitor.visitSingularStringField(value: self.sanityMarginPercentage, fieldNumber: 6)
    }
    if !self.editorDid.isEmpty {
      try visitor.visitSingularStringField(value: self.editorDid, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgEditBond, rhs: Bonds_MsgEditBond) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.orderQuantityLimits != rhs.orderQuantityLimits {return false}
    if lhs.sanityRate != rhs.sanityRate {return false}
    if lhs.sanityMarginPercentage != rhs.sanityMarginPercentage {return false}
    if lhs.editorDid != rhs.editorDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgEditBondResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgEditBondResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgEditBondResponse, rhs: Bonds_MsgEditBondResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgSetNextAlpha: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSetNextAlpha"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
    2: .same(proto: "alpha"),
    3: .standard(proto: "editor_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.alpha) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.editorDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    if !self.alpha.isEmpty {
      try visitor.visitSingularStringField(value: self.alpha, fieldNumber: 2)
    }
    if !self.editorDid.isEmpty {
      try visitor.visitSingularStringField(value: self.editorDid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgSetNextAlpha, rhs: Bonds_MsgSetNextAlpha) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.alpha != rhs.alpha {return false}
    if lhs.editorDid != rhs.editorDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgSetNextAlphaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSetNextAlphaResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgSetNextAlphaResponse, rhs: Bonds_MsgSetNextAlphaResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgUpdateBondState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateBondState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
    2: .same(proto: "state"),
    3: .standard(proto: "editor_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.editorDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 2)
    }
    if !self.editorDid.isEmpty {
      try visitor.visitSingularStringField(value: self.editorDid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgUpdateBondState, rhs: Bonds_MsgUpdateBondState) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.state != rhs.state {return false}
    if lhs.editorDid != rhs.editorDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgUpdateBondStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgUpdateBondStateResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgUpdateBondStateResponse, rhs: Bonds_MsgUpdateBondStateResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgBuy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBuy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "buyer_did"),
    2: .same(proto: "amount"),
    3: .standard(proto: "max_prices"),
    4: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.buyerDid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.maxPrices) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buyerDid.isEmpty {
      try visitor.visitSingularStringField(value: self.buyerDid, fieldNumber: 1)
    }
    if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.maxPrices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.maxPrices, fieldNumber: 3)
    }
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgBuy, rhs: Bonds_MsgBuy) -> Bool {
    if lhs.buyerDid != rhs.buyerDid {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.maxPrices != rhs.maxPrices {return false}
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgBuyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgBuyResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgBuyResponse, rhs: Bonds_MsgBuyResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgSell: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSell"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "seller_did"),
    2: .same(proto: "amount"),
    3: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sellerDid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sellerDid.isEmpty {
      try visitor.visitSingularStringField(value: self.sellerDid, fieldNumber: 1)
    }
    if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgSell, rhs: Bonds_MsgSell) -> Bool {
    if lhs.sellerDid != rhs.sellerDid {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgSellResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSellResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgSellResponse, rhs: Bonds_MsgSellResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgSwap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSwap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "swapper_did"),
    2: .standard(proto: "bond_did"),
    3: .same(proto: "from"),
    4: .standard(proto: "to_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.swapperDid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.toToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.swapperDid.isEmpty {
      try visitor.visitSingularStringField(value: self.swapperDid, fieldNumber: 1)
    }
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 2)
    }
    if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.toToken.isEmpty {
      try visitor.visitSingularStringField(value: self.toToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgSwap, rhs: Bonds_MsgSwap) -> Bool {
    if lhs.swapperDid != rhs.swapperDid {return false}
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs._from != rhs._from {return false}
    if lhs.toToken != rhs.toToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgSwapResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSwapResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgSwapResponse, rhs: Bonds_MsgSwapResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgMakeOutcomePayment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgMakeOutcomePayment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sender_did"),
    2: .same(proto: "amount"),
    3: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.senderDid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.senderDid.isEmpty {
      try visitor.visitSingularStringField(value: self.senderDid, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgMakeOutcomePayment, rhs: Bonds_MsgMakeOutcomePayment) -> Bool {
    if lhs.senderDid != rhs.senderDid {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgMakeOutcomePaymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgMakeOutcomePaymentResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgMakeOutcomePaymentResponse, rhs: Bonds_MsgMakeOutcomePaymentResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgWithdrawShare: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawShare"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "recipient_did"),
    2: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recipientDid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recipientDid.isEmpty {
      try visitor.visitSingularStringField(value: self.recipientDid, fieldNumber: 1)
    }
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgWithdrawShare, rhs: Bonds_MsgWithdrawShare) -> Bool {
    if lhs.recipientDid != rhs.recipientDid {return false}
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgWithdrawShareResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawShareResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgWithdrawShareResponse, rhs: Bonds_MsgWithdrawShareResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgWithdrawReserve: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawReserve"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "withdrawer_did"),
    2: .same(proto: "amount"),
    3: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.withdrawerDid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.withdrawerDid.isEmpty {
      try visitor.visitSingularStringField(value: self.withdrawerDid, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amount, fieldNumber: 2)
    }
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgWithdrawReserve, rhs: Bonds_MsgWithdrawReserve) -> Bool {
    if lhs.withdrawerDid != rhs.withdrawerDid {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_MsgWithdrawReserveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawReserveResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_MsgWithdrawReserveResponse, rhs: Bonds_MsgWithdrawReserveResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
