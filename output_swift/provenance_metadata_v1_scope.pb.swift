// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: provenance/metadata/v1/scope.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A set of types for inputs on a record (of fact)
enum Provenance_Metadata_V1_RecordInputStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type
  case unspecified // = 0

  /// RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed
  case proposed // = 1

  /// RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain
  case record // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .proposed
    case 2: self = .record
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .proposed: return 1
    case .record: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Provenance_Metadata_V1_RecordInputStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Provenance_Metadata_V1_RecordInputStatus] = [
    .unspecified,
    .proposed,
    .record,
  ]
}

#endif  // swift(>=4.2)

/// ResultStatus indicates the various states of execution of a record
enum Provenance_Metadata_V1_ResultStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// RESULT_STATUS_UNSPECIFIED indicates an unset condition
  case unspecified // = 0

  /// RESULT_STATUS_PASS indicates the execution was successfult
  case pass // = 1

  /// RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution
  case skip // = 2

  /// RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed.
  case fail // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .pass
    case 2: self = .skip
    case 3: self = .fail
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .pass: return 1
    case .skip: return 2
    case .fail: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Provenance_Metadata_V1_ResultStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Provenance_Metadata_V1_ResultStatus] = [
    .unspecified,
    .pass,
    .skip,
    .fail,
  ]
}

#endif  // swift(>=4.2)

/// Scope defines a root reference for a collection of records owned by one or more parties.
struct Provenance_Metadata_V1_Scope {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos
  var scopeID: Data = Data()

  /// the scope specification that contains the specifications for data elements allowed within this scope
  var specificationID: Data = Data()

  /// These parties represent top level owners of the records within.  These parties must sign any requests that modify
  /// the data within the scope.  These addresses are in union with parties listed on the sessions.
  var owners: [Provenance_Metadata_V1_Party] = []

  /// Addessses in this list are authorized to recieve off-chain data associated with this scope.
  var dataAccess: [String] = []

  /// An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts
  /// are supported for this value.  This attribute may only be changed by the entity indicated once it is set.
  var valueOwnerAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
///A Session is created for an execution context against a specific specification instance
///
///The context will have a specification and set of parties involved.  The Session may be updated several
///times so long as the parties listed are signers on the transaction.  NOTE: When there are no Records within a Scope
///that reference a Session it is removed.
struct Provenance_Metadata_V1_Session {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionID: Data = Data()

  /// unique id of the contract specification that was used to create this session.
  var specificationID: Data = Data()

  /// parties is the set of identities that signed this contract
  var parties: [Provenance_Metadata_V1_Party] = []

  /// name to associate with this session execution context, typically classname
  var name: String = String()

  /// context is a field for storing client specific data associated with a session.
  var context: Data = Data()

  /// Created by, updated by, timestamps, version number, and related info.
  var audit: Provenance_Metadata_V1_AuditFields {
    get {return _audit ?? Provenance_Metadata_V1_AuditFields()}
    set {_audit = newValue}
  }
  /// Returns true if `audit` has been explicitly set.
  var hasAudit: Bool {return self._audit != nil}
  /// Clears the value of `audit`. Subsequent reads from it will return its default value.
  mutating func clearAudit() {self._audit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _audit: Provenance_Metadata_V1_AuditFields? = nil
}

/// A record (of fact) is attached to a session or each consideration output from a contract
struct Provenance_Metadata_V1_Record {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name
  var name: String = String()

  /// id of the session context that was used to create this record (use with filtered kvprefix iterator)
  var sessionID: Data = Data()

  /// process contain information used to uniquely identify an execution on or off chain that generated this record
  var process: Provenance_Metadata_V1_Process {
    get {return _process ?? Provenance_Metadata_V1_Process()}
    set {_process = newValue}
  }
  /// Returns true if `process` has been explicitly set.
  var hasProcess: Bool {return self._process != nil}
  /// Clears the value of `process`. Subsequent reads from it will return its default value.
  mutating func clearProcess() {self._process = nil}

  /// inputs used with the process to achieve the output on this record
  var inputs: [Provenance_Metadata_V1_RecordInput] = []

  /// output(s) is the results of executing the process on the given process indicated in this record
  var outputs: [Provenance_Metadata_V1_RecordOutput] = []

  /// specification_id is the id of the record specification that was used to create this record.
  var specificationID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _process: Provenance_Metadata_V1_Process? = nil
}

/// Process contains information used to uniquely identify what was used to generate this record
struct Provenance_Metadata_V1_Process {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unique identifier for this process
  var processID: Provenance_Metadata_V1_Process.OneOf_ProcessID? = nil

  /// the address of a smart contract used for this process
  var address: String {
    get {
      if case .address(let v)? = processID {return v}
      return String()
    }
    set {processID = .address(newValue)}
  }

  /// the hash of an off-chain process used
  var hash: String {
    get {
      if case .hash(let v)? = processID {return v}
      return String()
    }
    set {processID = .hash(newValue)}
  }

  /// a name associated with the process (type_name, classname or smart contract common name)
  var name: String = String()

  /// method is a name or reference to a specific operation (method) within a class/contract that was invoked
  var method: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// unique identifier for this process
  enum OneOf_ProcessID: Equatable {
    /// the address of a smart contract used for this process
    case address(String)
    /// the hash of an off-chain process used
    case hash(String)

  #if !swift(>=4.1)
    static func ==(lhs: Provenance_Metadata_V1_Process.OneOf_ProcessID, rhs: Provenance_Metadata_V1_Process.OneOf_ProcessID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.address, .address): return {
        guard case .address(let l) = lhs, case .address(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hash, .hash): return {
        guard case .hash(let l) = lhs, case .hash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Tracks the inputs used to establish this record
struct Provenance_Metadata_V1_RecordInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name value included to link back to the definition spec.
  var name: String = String()

  /// data source
  var source: Provenance_Metadata_V1_RecordInput.OneOf_Source? = nil

  /// the address of a record on chain (For Established Records)
  var recordID: Data {
    get {
      if case .recordID(let v)? = source {return v}
      return Data()
    }
    set {source = .recordID(newValue)}
  }

  /// the hash of an off-chain piece of information (For Proposed Records)
  var hash: String {
    get {
      if case .hash(let v)? = source {return v}
      return String()
    }
    set {source = .hash(newValue)}
  }

  /// from proposed fact structure to unmarshal
  var typeName: String = String()

  /// Indicates if this input was a recorded fact on chain or just a given hashed input
  var status: Provenance_Metadata_V1_RecordInputStatus = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// data source
  enum OneOf_Source: Equatable {
    /// the address of a record on chain (For Established Records)
    case recordID(Data)
    /// the hash of an off-chain piece of information (For Proposed Records)
    case hash(String)

  #if !swift(>=4.1)
    static func ==(lhs: Provenance_Metadata_V1_RecordInput.OneOf_Source, rhs: Provenance_Metadata_V1_RecordInput.OneOf_Source) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.recordID, .recordID): return {
        guard case .recordID(let l) = lhs, case .recordID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hash, .hash): return {
        guard case .hash(let l) = lhs, case .hash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// RecordOutput encapsulates the output of a process recorded on chain
struct Provenance_Metadata_V1_RecordOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Hash of the data output that was output/generated for this record
  var hash: String = String()

  /// Status of the process execution associated with this output indicating success,failure, or pending
  var status: Provenance_Metadata_V1_ResultStatus = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Party is an address with/in a given role associated with a contract
struct Provenance_Metadata_V1_Party {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address of the account (on chain)
  var address: String = String()

  /// a role for this account within the context of the processes used
  var role: Provenance_Metadata_V1_PartyType = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AuditFields capture information about the last account to make modifications and when they were made
struct Provenance_Metadata_V1_AuditFields {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the date/time when this entry was created
  var createdDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdDate = newValue}
  }
  /// Returns true if `createdDate` has been explicitly set.
  var hasCreatedDate: Bool {return self._createdDate != nil}
  /// Clears the value of `createdDate`. Subsequent reads from it will return its default value.
  mutating func clearCreatedDate() {self._createdDate = nil}

  /// the address of the account that created this record
  var createdBy: String = String()

  /// the date/time when this entry was last updated
  var updatedDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedDate = newValue}
  }
  /// Returns true if `updatedDate` has been explicitly set.
  var hasUpdatedDate: Bool {return self._updatedDate != nil}
  /// Clears the value of `updatedDate`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedDate() {self._updatedDate = nil}

  /// the address of the account that modified this record
  var updatedBy: String = String()

  /// an optional version number that is incremented with each update
  var version: UInt32 = 0

  /// an optional message associated with the creation/update event
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "provenance.metadata.v1"

extension Provenance_Metadata_V1_RecordInputStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RECORD_INPUT_STATUS_UNSPECIFIED"),
    1: .same(proto: "RECORD_INPUT_STATUS_PROPOSED"),
    2: .same(proto: "RECORD_INPUT_STATUS_RECORD"),
  ]
}

extension Provenance_Metadata_V1_ResultStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_STATUS_UNSPECIFIED"),
    1: .same(proto: "RESULT_STATUS_PASS"),
    2: .same(proto: "RESULT_STATUS_SKIP"),
    3: .same(proto: "RESULT_STATUS_FAIL"),
  ]
}

extension Provenance_Metadata_V1_Scope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Scope"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scope_id"),
    2: .standard(proto: "specification_id"),
    3: .same(proto: "owners"),
    4: .standard(proto: "data_access"),
    5: .standard(proto: "value_owner_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.scopeID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.specificationID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.owners) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.dataAccess) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.valueOwnerAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopeID.isEmpty {
      try visitor.visitSingularBytesField(value: self.scopeID, fieldNumber: 1)
    }
    if !self.specificationID.isEmpty {
      try visitor.visitSingularBytesField(value: self.specificationID, fieldNumber: 2)
    }
    if !self.owners.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.owners, fieldNumber: 3)
    }
    if !self.dataAccess.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dataAccess, fieldNumber: 4)
    }
    if !self.valueOwnerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.valueOwnerAddress, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_Scope, rhs: Provenance_Metadata_V1_Scope) -> Bool {
    if lhs.scopeID != rhs.scopeID {return false}
    if lhs.specificationID != rhs.specificationID {return false}
    if lhs.owners != rhs.owners {return false}
    if lhs.dataAccess != rhs.dataAccess {return false}
    if lhs.valueOwnerAddress != rhs.valueOwnerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_Session: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Session"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .standard(proto: "specification_id"),
    3: .same(proto: "parties"),
    4: .same(proto: "name"),
    5: .same(proto: "context"),
    99: .same(proto: "audit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.specificationID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.parties) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.context) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._audit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularBytesField(value: self.sessionID, fieldNumber: 1)
    }
    if !self.specificationID.isEmpty {
      try visitor.visitSingularBytesField(value: self.specificationID, fieldNumber: 2)
    }
    if !self.parties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parties, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.context.isEmpty {
      try visitor.visitSingularBytesField(value: self.context, fieldNumber: 5)
    }
    if let v = self._audit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_Session, rhs: Provenance_Metadata_V1_Session) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.specificationID != rhs.specificationID {return false}
    if lhs.parties != rhs.parties {return false}
    if lhs.name != rhs.name {return false}
    if lhs.context != rhs.context {return false}
    if lhs._audit != rhs._audit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_Record: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Record"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "session_id"),
    3: .same(proto: "process"),
    4: .same(proto: "inputs"),
    5: .same(proto: "outputs"),
    6: .standard(proto: "specification_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.sessionID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._process) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.specificationID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularBytesField(value: self.sessionID, fieldNumber: 2)
    }
    if let v = self._process {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 4)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 5)
    }
    if !self.specificationID.isEmpty {
      try visitor.visitSingularBytesField(value: self.specificationID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_Record, rhs: Provenance_Metadata_V1_Record) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs._process != rhs._process {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.specificationID != rhs.specificationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_Process: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Process"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "hash"),
    3: .same(proto: "name"),
    4: .same(proto: "method"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.processID != nil {try decoder.handleConflictingOneOf()}
          self.processID = .address(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.processID != nil {try decoder.handleConflictingOneOf()}
          self.processID = .hash(v)
        }
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.method) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.processID {
    case .address?: try {
      guard case .address(let v)? = self.processID else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .hash?: try {
      guard case .hash(let v)? = self.processID else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.method.isEmpty {
      try visitor.visitSingularStringField(value: self.method, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_Process, rhs: Provenance_Metadata_V1_Process) -> Bool {
    if lhs.processID != rhs.processID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.method != rhs.method {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_RecordInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "record_id"),
    3: .same(proto: "hash"),
    4: .standard(proto: "type_name"),
    5: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.source != nil {try decoder.handleConflictingOneOf()}
          self.source = .recordID(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.source != nil {try decoder.handleConflictingOneOf()}
          self.source = .hash(v)
        }
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.typeName) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.source {
    case .recordID?: try {
      guard case .recordID(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .hash?: try {
      guard case .hash(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.typeName.isEmpty {
      try visitor.visitSingularStringField(value: self.typeName, fieldNumber: 4)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_RecordInput, rhs: Provenance_Metadata_V1_RecordInput) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.source != rhs.source {return false}
    if lhs.typeName != rhs.typeName {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_RecordOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordOutput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_RecordOutput, rhs: Provenance_Metadata_V1_RecordOutput) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_Party: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Party"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "role"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.role != .unspecified {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_Party, rhs: Provenance_Metadata_V1_Party) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Metadata_V1_AuditFields: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuditFields"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "created_date"),
    2: .standard(proto: "created_by"),
    3: .standard(proto: "updated_date"),
    4: .standard(proto: "updated_by"),
    5: .same(proto: "version"),
    6: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createdDate) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.createdBy) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updatedDate) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.updatedBy) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._createdDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.createdBy.isEmpty {
      try visitor.visitSingularStringField(value: self.createdBy, fieldNumber: 2)
    }
    if let v = self._updatedDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.updatedBy.isEmpty {
      try visitor.visitSingularStringField(value: self.updatedBy, fieldNumber: 4)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 5)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provenance_Metadata_V1_AuditFields, rhs: Provenance_Metadata_V1_AuditFields) -> Bool {
    if lhs._createdDate != rhs._createdDate {return false}
    if lhs.createdBy != rhs.createdBy {return false}
    if lhs._updatedDate != rhs._updatedDate {return false}
    if lhs.updatedBy != rhs.updatedBy {return false}
    if lhs.version != rhs.version {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
