// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: axelar/tss/tofnd/v1beta1/tofnd.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// File copied from golang tofnd with minor tweaks

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Axelar_Tss_Tofnd_V1beta1_RecoverRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keygenInit: Axelar_Tss_Tofnd_V1beta1_KeygenInit {
    get {return _keygenInit ?? Axelar_Tss_Tofnd_V1beta1_KeygenInit()}
    set {_keygenInit = newValue}
  }
  /// Returns true if `keygenInit` has been explicitly set.
  var hasKeygenInit: Bool {return self._keygenInit != nil}
  /// Clears the value of `keygenInit`. Subsequent reads from it will return its default value.
  mutating func clearKeygenInit() {self._keygenInit = nil}

  var keygenOutput: Axelar_Tss_Tofnd_V1beta1_KeygenOutput {
    get {return _keygenOutput ?? Axelar_Tss_Tofnd_V1beta1_KeygenOutput()}
    set {_keygenOutput = newValue}
  }
  /// Returns true if `keygenOutput` has been explicitly set.
  var hasKeygenOutput: Bool {return self._keygenOutput != nil}
  /// Clears the value of `keygenOutput`. Subsequent reads from it will return its default value.
  mutating func clearKeygenOutput() {self._keygenOutput = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keygenInit: Axelar_Tss_Tofnd_V1beta1_KeygenInit? = nil
  fileprivate var _keygenOutput: Axelar_Tss_Tofnd_V1beta1_KeygenOutput? = nil
}

struct Axelar_Tss_Tofnd_V1beta1_RecoverResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: Axelar_Tss_Tofnd_V1beta1_RecoverResponse.Response = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Response: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0
    case success // = 1
    case fail // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .success
      case 2: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .success: return 1
      case .fail: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Axelar_Tss_Tofnd_V1beta1_RecoverResponse.Response: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Axelar_Tss_Tofnd_V1beta1_RecoverResponse.Response] = [
    .unspecified,
    .success,
    .fail,
  ]
}

#endif  // swift(>=4.2)

/// Keygen's success response
struct Axelar_Tss_Tofnd_V1beta1_KeygenOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pub_key; common for all parties
  var pubKey: Data = Data()

  /// recover info of all parties' shares; common for all parties
  var groupRecoverInfo: Data = Data()

  /// private recover info of this party's shares; unique for each party
  var privateRecoverInfo: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Tss_Tofnd_V1beta1_MessageIn {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO don't reuse `data`
  var data: Axelar_Tss_Tofnd_V1beta1_MessageIn.OneOf_Data? = nil

  /// first message only, Keygen
  var keygenInit: Axelar_Tss_Tofnd_V1beta1_KeygenInit {
    get {
      if case .keygenInit(let v)? = data {return v}
      return Axelar_Tss_Tofnd_V1beta1_KeygenInit()
    }
    set {data = .keygenInit(newValue)}
  }

  /// first message only, Sign
  var signInit: Axelar_Tss_Tofnd_V1beta1_SignInit {
    get {
      if case .signInit(let v)? = data {return v}
      return Axelar_Tss_Tofnd_V1beta1_SignInit()
    }
    set {data = .signInit(newValue)}
  }

  /// all subsequent messages
  var traffic: Axelar_Tss_Tofnd_V1beta1_TrafficIn {
    get {
      if case .traffic(let v)? = data {return v}
      return Axelar_Tss_Tofnd_V1beta1_TrafficIn()
    }
    set {data = .traffic(newValue)}
  }

  /// abort the protocol, ignore the bool value
  var abort: Bool {
    get {
      if case .abort(let v)? = data {return v}
      return false
    }
    set {data = .abort(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// TODO don't reuse `data`
  enum OneOf_Data: Equatable {
    /// first message only, Keygen
    case keygenInit(Axelar_Tss_Tofnd_V1beta1_KeygenInit)
    /// first message only, Sign
    case signInit(Axelar_Tss_Tofnd_V1beta1_SignInit)
    /// all subsequent messages
    case traffic(Axelar_Tss_Tofnd_V1beta1_TrafficIn)
    /// abort the protocol, ignore the bool value
    case abort(Bool)

  #if !swift(>=4.1)
    static func ==(lhs: Axelar_Tss_Tofnd_V1beta1_MessageIn.OneOf_Data, rhs: Axelar_Tss_Tofnd_V1beta1_MessageIn.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.keygenInit, .keygenInit): return {
        guard case .keygenInit(let l) = lhs, case .keygenInit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.signInit, .signInit): return {
        guard case .signInit(let l) = lhs, case .signInit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.traffic, .traffic): return {
        guard case .traffic(let l) = lhs, case .traffic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.abort, .abort): return {
        guard case .abort(let l) = lhs, case .abort(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Axelar_Tss_Tofnd_V1beta1_MessageOut {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO don't reuse `data`
  var data: Axelar_Tss_Tofnd_V1beta1_MessageOut.OneOf_Data? = nil

  /// all but final message
  var traffic: Axelar_Tss_Tofnd_V1beta1_TrafficOut {
    get {
      if case .traffic(let v)? = data {return v}
      return Axelar_Tss_Tofnd_V1beta1_TrafficOut()
    }
    set {data = .traffic(newValue)}
  }

  /// final message only, Keygen
  var keygenResult: Axelar_Tss_Tofnd_V1beta1_MessageOut.KeygenResult {
    get {
      if case .keygenResult(let v)? = data {return v}
      return Axelar_Tss_Tofnd_V1beta1_MessageOut.KeygenResult()
    }
    set {data = .keygenResult(newValue)}
  }

  /// final message only, Sign
  var signResult: Axelar_Tss_Tofnd_V1beta1_MessageOut.SignResult {
    get {
      if case .signResult(let v)? = data {return v}
      return Axelar_Tss_Tofnd_V1beta1_MessageOut.SignResult()
    }
    set {data = .signResult(newValue)}
  }

  /// issue recover from client
  var needRecover: Bool {
    get {
      if case .needRecover(let v)? = data {return v}
      return false
    }
    set {data = .needRecover(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// TODO don't reuse `data`
  enum OneOf_Data: Equatable {
    /// all but final message
    case traffic(Axelar_Tss_Tofnd_V1beta1_TrafficOut)
    /// final message only, Keygen
    case keygenResult(Axelar_Tss_Tofnd_V1beta1_MessageOut.KeygenResult)
    /// final message only, Sign
    case signResult(Axelar_Tss_Tofnd_V1beta1_MessageOut.SignResult)
    /// issue recover from client
    case needRecover(Bool)

  #if !swift(>=4.1)
    static func ==(lhs: Axelar_Tss_Tofnd_V1beta1_MessageOut.OneOf_Data, rhs: Axelar_Tss_Tofnd_V1beta1_MessageOut.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.traffic, .traffic): return {
        guard case .traffic(let l) = lhs, case .traffic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.keygenResult, .keygenResult): return {
        guard case .keygenResult(let l) = lhs, case .keygenResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.signResult, .signResult): return {
        guard case .signResult(let l) = lhs, case .signResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.needRecover, .needRecover): return {
        guard case .needRecover(let l) = lhs, case .needRecover(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Keygen's response types
  struct KeygenResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var keygenResultData: Axelar_Tss_Tofnd_V1beta1_MessageOut.KeygenResult.OneOf_KeygenResultData? = nil

    /// Success response
    var data: Axelar_Tss_Tofnd_V1beta1_KeygenOutput {
      get {
        if case .data(let v)? = keygenResultData {return v}
        return Axelar_Tss_Tofnd_V1beta1_KeygenOutput()
      }
      set {keygenResultData = .data(newValue)}
    }

    /// Faiilure response
    var criminals: Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList {
      get {
        if case .criminals(let v)? = keygenResultData {return v}
        return Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList()
      }
      set {keygenResultData = .criminals(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_KeygenResultData: Equatable {
      /// Success response
      case data(Axelar_Tss_Tofnd_V1beta1_KeygenOutput)
      /// Faiilure response
      case criminals(Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList)

    #if !swift(>=4.1)
      static func ==(lhs: Axelar_Tss_Tofnd_V1beta1_MessageOut.KeygenResult.OneOf_KeygenResultData, rhs: Axelar_Tss_Tofnd_V1beta1_MessageOut.KeygenResult.OneOf_KeygenResultData) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.data, .data): return {
          guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.criminals, .criminals): return {
          guard case .criminals(let l) = lhs, case .criminals(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  /// Sign's response types
  struct SignResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var signResultData: Axelar_Tss_Tofnd_V1beta1_MessageOut.SignResult.OneOf_SignResultData? = nil

    /// Success response
    var signature: Data {
      get {
        if case .signature(let v)? = signResultData {return v}
        return Data()
      }
      set {signResultData = .signature(newValue)}
    }

    /// Failure response
    var criminals: Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList {
      get {
        if case .criminals(let v)? = signResultData {return v}
        return Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList()
      }
      set {signResultData = .criminals(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_SignResultData: Equatable {
      /// Success response
      case signature(Data)
      /// Failure response
      case criminals(Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList)

    #if !swift(>=4.1)
      static func ==(lhs: Axelar_Tss_Tofnd_V1beta1_MessageOut.SignResult.OneOf_SignResultData, rhs: Axelar_Tss_Tofnd_V1beta1_MessageOut.SignResult.OneOf_SignResultData) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.signature, .signature): return {
          guard case .signature(let l) = lhs, case .signature(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.criminals, .criminals): return {
          guard case .criminals(let l) = lhs, case .criminals(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  /// Keygen/Sign failure response message
  struct CriminalList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var criminals: [Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList.Criminal] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Criminal {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var partyUid: String = String()

      var crimeType: Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList.Criminal.CrimeType = .unspecified

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum CrimeType: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case unspecified // = 0
        case nonMalicious // = 1
        case malicious // = 2
        case UNRECOGNIZED(Int)

        init() {
          self = .unspecified
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unspecified
          case 1: self = .nonMalicious
          case 2: self = .malicious
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unspecified: return 0
          case .nonMalicious: return 1
          case .malicious: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      init() {}
    }

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList.Criminal.CrimeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList.Criminal.CrimeType] = [
    .unspecified,
    .nonMalicious,
    .malicious,
  ]
}

#endif  // swift(>=4.2)

struct Axelar_Tss_Tofnd_V1beta1_TrafficIn {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fromPartyUid: String = String()

  var payload: Data = Data()

  var isBroadcast: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Tss_Tofnd_V1beta1_TrafficOut {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var toPartyUid: String = String()

  var payload: Data = Data()

  var isBroadcast: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Tss_Tofnd_V1beta1_KeygenInit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var newKeyUid: String = String()

  var partyUids: [String] = []

  var partyShareCounts: [UInt32] = []

  /// parties[my_party_index] belongs to the server
  var myPartyIndex: UInt32 = 0

  var threshold: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Axelar_Tss_Tofnd_V1beta1_SignInit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var newSigUid: String = String()

  var keyUid: String = String()

  /// TODO replace this with a subset of indices?
  var partyUids: [String] = []

  var messageToSign: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "axelar.tss.tofnd.v1beta1"

extension Axelar_Tss_Tofnd_V1beta1_RecoverRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecoverRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "keygen_init"),
    2: .standard(proto: "keygen_output"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keygenInit) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._keygenOutput) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._keygenInit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._keygenOutput {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_Tofnd_V1beta1_RecoverRequest, rhs: Axelar_Tss_Tofnd_V1beta1_RecoverRequest) -> Bool {
    if lhs._keygenInit != rhs._keygenInit {return false}
    if lhs._keygenOutput != rhs._keygenOutput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_Tofnd_V1beta1_RecoverResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecoverResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.response) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.response != .unspecified {
      try visitor.visitSingularEnumField(value: self.response, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_Tofnd_V1beta1_RecoverResponse, rhs: Axelar_Tss_Tofnd_V1beta1_RecoverResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_Tofnd_V1beta1_RecoverResponse.Response: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESPONSE_UNSPECIFIED"),
    1: .same(proto: "RESPONSE_SUCCESS"),
    2: .same(proto: "RESPONSE_FAIL"),
  ]
}

extension Axelar_Tss_Tofnd_V1beta1_KeygenOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeygenOutput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .standard(proto: "group_recover_info"),
    3: .standard(proto: "private_recover_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.pubKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.groupRecoverInfo) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.privateRecoverInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubKey, fieldNumber: 1)
    }
    if !self.groupRecoverInfo.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupRecoverInfo, fieldNumber: 2)
    }
    if !self.privateRecoverInfo.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateRecoverInfo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_Tofnd_V1beta1_KeygenOutput, rhs: Axelar_Tss_Tofnd_V1beta1_KeygenOutput) -> Bool {
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.groupRecoverInfo != rhs.groupRecoverInfo {return false}
    if lhs.privateRecoverInfo != rhs.privateRecoverInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_Tofnd_V1beta1_MessageIn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageIn"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "keygen_init"),
    2: .standard(proto: "sign_init"),
    3: .same(proto: "traffic"),
    4: .same(proto: "abort"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Axelar_Tss_Tofnd_V1beta1_KeygenInit?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .keygenInit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .keygenInit(v)
        }
      }()
      case 2: try {
        var v: Axelar_Tss_Tofnd_V1beta1_SignInit?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .signInit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .signInit(v)
        }
      }()
      case 3: try {
        var v: Axelar_Tss_Tofnd_V1beta1_TrafficIn?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .traffic(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .traffic(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.data != nil {try decoder.handleConflictingOneOf()}
          self.data = .abort(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.data {
    case .keygenInit?: try {
      guard case .keygenInit(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .signInit?: try {
      guard case .signInit(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .traffic?: try {
      guard case .traffic(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .abort?: try {
      guard case .abort(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_Tofnd_V1beta1_MessageIn, rhs: Axelar_Tss_Tofnd_V1beta1_MessageIn) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_Tofnd_V1beta1_MessageOut: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageOut"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "traffic"),
    2: .standard(proto: "keygen_result"),
    3: .standard(proto: "sign_result"),
    4: .standard(proto: "need_recover"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Axelar_Tss_Tofnd_V1beta1_TrafficOut?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .traffic(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .traffic(v)
        }
      }()
      case 2: try {
        var v: Axelar_Tss_Tofnd_V1beta1_MessageOut.KeygenResult?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .keygenResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .keygenResult(v)
        }
      }()
      case 3: try {
        var v: Axelar_Tss_Tofnd_V1beta1_MessageOut.SignResult?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .signResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .signResult(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.data != nil {try decoder.handleConflictingOneOf()}
          self.data = .needRecover(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.data {
    case .traffic?: try {
      guard case .traffic(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .keygenResult?: try {
      guard case .keygenResult(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .signResult?: try {
      guard case .signResult(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .needRecover?: try {
      guard case .needRecover(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_Tofnd_V1beta1_MessageOut, rhs: Axelar_Tss_Tofnd_V1beta1_MessageOut) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_Tofnd_V1beta1_MessageOut.KeygenResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Axelar_Tss_Tofnd_V1beta1_MessageOut.protoMessageName + ".KeygenResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "criminals"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Axelar_Tss_Tofnd_V1beta1_KeygenOutput?
        var hadOneofValue = false
        if let current = self.keygenResultData {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.keygenResultData = .data(v)
        }
      }()
      case 2: try {
        var v: Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList?
        var hadOneofValue = false
        if let current = self.keygenResultData {
          hadOneofValue = true
          if case .criminals(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.keygenResultData = .criminals(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.keygenResultData {
    case .data?: try {
      guard case .data(let v)? = self.keygenResultData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .criminals?: try {
      guard case .criminals(let v)? = self.keygenResultData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_Tofnd_V1beta1_MessageOut.KeygenResult, rhs: Axelar_Tss_Tofnd_V1beta1_MessageOut.KeygenResult) -> Bool {
    if lhs.keygenResultData != rhs.keygenResultData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_Tofnd_V1beta1_MessageOut.SignResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Axelar_Tss_Tofnd_V1beta1_MessageOut.protoMessageName + ".SignResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
    2: .same(proto: "criminals"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signResultData != nil {try decoder.handleConflictingOneOf()}
          self.signResultData = .signature(v)
        }
      }()
      case 2: try {
        var v: Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList?
        var hadOneofValue = false
        if let current = self.signResultData {
          hadOneofValue = true
          if case .criminals(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signResultData = .criminals(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.signResultData {
    case .signature?: try {
      guard case .signature(let v)? = self.signResultData else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .criminals?: try {
      guard case .criminals(let v)? = self.signResultData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_Tofnd_V1beta1_MessageOut.SignResult, rhs: Axelar_Tss_Tofnd_V1beta1_MessageOut.SignResult) -> Bool {
    if lhs.signResultData != rhs.signResultData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Axelar_Tss_Tofnd_V1beta1_MessageOut.protoMessageName + ".CriminalList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "criminals"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.criminals) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.criminals.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.criminals, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList, rhs: Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList) -> Bool {
    if lhs.criminals != rhs.criminals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList.Criminal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList.protoMessageName + ".Criminal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "party_uid"),
    2: .standard(proto: "crime_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.partyUid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.crimeType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.partyUid.isEmpty {
      try visitor.visitSingularStringField(value: self.partyUid, fieldNumber: 1)
    }
    if self.crimeType != .unspecified {
      try visitor.visitSingularEnumField(value: self.crimeType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList.Criminal, rhs: Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList.Criminal) -> Bool {
    if lhs.partyUid != rhs.partyUid {return false}
    if lhs.crimeType != rhs.crimeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_Tofnd_V1beta1_MessageOut.CriminalList.Criminal.CrimeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CRIME_TYPE_UNSPECIFIED"),
    1: .same(proto: "CRIME_TYPE_NON_MALICIOUS"),
    2: .same(proto: "CRIME_TYPE_MALICIOUS"),
  ]
}

extension Axelar_Tss_Tofnd_V1beta1_TrafficIn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrafficIn"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_party_uid"),
    2: .same(proto: "payload"),
    3: .standard(proto: "is_broadcast"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fromPartyUid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isBroadcast) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fromPartyUid.isEmpty {
      try visitor.visitSingularStringField(value: self.fromPartyUid, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    if self.isBroadcast != false {
      try visitor.visitSingularBoolField(value: self.isBroadcast, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_Tofnd_V1beta1_TrafficIn, rhs: Axelar_Tss_Tofnd_V1beta1_TrafficIn) -> Bool {
    if lhs.fromPartyUid != rhs.fromPartyUid {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.isBroadcast != rhs.isBroadcast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_Tofnd_V1beta1_TrafficOut: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrafficOut"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "to_party_uid"),
    2: .same(proto: "payload"),
    3: .standard(proto: "is_broadcast"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.toPartyUid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isBroadcast) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.toPartyUid.isEmpty {
      try visitor.visitSingularStringField(value: self.toPartyUid, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    if self.isBroadcast != false {
      try visitor.visitSingularBoolField(value: self.isBroadcast, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_Tofnd_V1beta1_TrafficOut, rhs: Axelar_Tss_Tofnd_V1beta1_TrafficOut) -> Bool {
    if lhs.toPartyUid != rhs.toPartyUid {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.isBroadcast != rhs.isBroadcast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_Tofnd_V1beta1_KeygenInit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeygenInit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_key_uid"),
    2: .standard(proto: "party_uids"),
    5: .standard(proto: "party_share_counts"),
    3: .standard(proto: "my_party_index"),
    4: .same(proto: "threshold"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.newKeyUid) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.partyUids) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.myPartyIndex) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.threshold) }()
      case 5: try { try decoder.decodeRepeatedUInt32Field(value: &self.partyShareCounts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.newKeyUid.isEmpty {
      try visitor.visitSingularStringField(value: self.newKeyUid, fieldNumber: 1)
    }
    if !self.partyUids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.partyUids, fieldNumber: 2)
    }
    if self.myPartyIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.myPartyIndex, fieldNumber: 3)
    }
    if self.threshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.threshold, fieldNumber: 4)
    }
    if !self.partyShareCounts.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.partyShareCounts, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_Tofnd_V1beta1_KeygenInit, rhs: Axelar_Tss_Tofnd_V1beta1_KeygenInit) -> Bool {
    if lhs.newKeyUid != rhs.newKeyUid {return false}
    if lhs.partyUids != rhs.partyUids {return false}
    if lhs.partyShareCounts != rhs.partyShareCounts {return false}
    if lhs.myPartyIndex != rhs.myPartyIndex {return false}
    if lhs.threshold != rhs.threshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Axelar_Tss_Tofnd_V1beta1_SignInit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignInit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_sig_uid"),
    2: .standard(proto: "key_uid"),
    3: .standard(proto: "party_uids"),
    4: .standard(proto: "message_to_sign"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.newSigUid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyUid) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.partyUids) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.messageToSign) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.newSigUid.isEmpty {
      try visitor.visitSingularStringField(value: self.newSigUid, fieldNumber: 1)
    }
    if !self.keyUid.isEmpty {
      try visitor.visitSingularStringField(value: self.keyUid, fieldNumber: 2)
    }
    if !self.partyUids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.partyUids, fieldNumber: 3)
    }
    if !self.messageToSign.isEmpty {
      try visitor.visitSingularBytesField(value: self.messageToSign, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Axelar_Tss_Tofnd_V1beta1_SignInit, rhs: Axelar_Tss_Tofnd_V1beta1_SignInit) -> Bool {
    if lhs.newSigUid != rhs.newSigUid {return false}
    if lhs.keyUid != rhs.keyUid {return false}
    if lhs.partyUids != rhs.partyUids {return false}
    if lhs.messageToSign != rhs.messageToSign {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
