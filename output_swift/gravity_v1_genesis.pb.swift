// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: gravity/v1/genesis.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Params represent the Gravity genesis and store parameters
/// gravity_id:
/// a random 32 byte value to prevent signature reuse, for example if the
/// cosmos validators decided to use the same Ethereum keys for another chain
/// also running Gravity we would not want it to be possible to play a deposit
/// from chain A back on chain B's Gravity. This value IS USED ON ETHEREUM so
/// it must be set in your genesis.json before launch and not changed after
/// deploying Gravity
///
/// contract_hash:
/// the code hash of a known good version of the Gravity contract
/// solidity code. This can be used to verify the correct version
/// of the contract has been deployed. This is a reference value for
/// goernance action only it is never read by any Gravity code
///
/// bridge_ethereum_address:
/// is address of the bridge contract on the Ethereum side, this is a
/// reference value for governance only and is not actually used by any
/// Gravity code
///
/// bridge_chain_id:
/// the unique identifier of the Ethereum chain, this is a reference value
/// only and is not actually used by any Gravity code
///
/// These reference values may be used by future Gravity client implemetnations
/// to allow for saftey features or convenience features like the Gravity address
/// in your relayer. A relayer would require a configured Gravity address if
/// governance had not set the address on the chain it was relaying for.
///
/// signed_signer_set_txs_window
/// signed_batches_window
/// signed_ethereum_signatures_window
///
/// These values represent the time in blocks that a validator has to submit
/// a signature for a batch or valset, or to submit a ethereum_signature for a
/// particular attestation nonce. In the case of attestations this clock starts
/// when the attestation is created, but only allows for slashing once the event
/// has passed
///
/// target_eth_tx_timeout:
///
/// This is the 'target' value for when ethereum transactions time out, this is a target
/// because Ethereum is a probabilistic chain and you can't say for sure what the
/// block frequency is ahead of time.
///
/// average_block_time
/// average_ethereum_block_time
///
/// These values are the average Cosmos block time and Ethereum block time
/// respectively and they are used to compute what the target batch timeout is. It
/// is important that governance updates these in case of any major, prolonged
/// change in the time it takes to produce a block
///
/// slash_fraction_signer_set_tx
/// slash_fraction_batch
/// slash_fraction_ethereum_signature
/// slash_fraction_conflicting_ethereum_signature
///
/// The slashing fractions for the various gravity related slashing conditions.
/// The first three refer to not submitting a particular message, the third for
/// submitting a different ethereum_signature for the same Ethereum event
struct Gravity_V1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gravityID: String = String()

  var contractSourceHash: String = String()

  var bridgeEthereumAddress: String = String()

  var bridgeChainID: UInt64 = 0

  var signedSignerSetTxsWindow: UInt64 = 0

  var signedBatchesWindow: UInt64 = 0

  var ethereumSignaturesWindow: UInt64 = 0

  var targetEthTxTimeout: UInt64 = 0

  var averageBlockTime: UInt64 = 0

  var averageEthereumBlockTime: UInt64 = 0

  /// TODO: slash fraction for contract call txs too
  var slashFractionSignerSetTx: Data = Data()

  var slashFractionBatch: Data = Data()

  var slashFractionEthereumSignature: Data = Data()

  var slashFractionConflictingEthereumSignature: Data = Data()

  var unbondSlashingSignerSetTxsWindow: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GenesisState struct
/// TODO: this need to be audited and potentially simplified using the new
/// interfaces
struct Gravity_V1_GenesisState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: Gravity_V1_Params {
    get {return _storage._params ?? Gravity_V1_Params()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {_uniqueStorage()._params = nil}

  var lastObservedEventNonce: UInt64 {
    get {return _storage._lastObservedEventNonce}
    set {_uniqueStorage()._lastObservedEventNonce = newValue}
  }

  var outgoingTxs: [Google_Protobuf_Any] {
    get {return _storage._outgoingTxs}
    set {_uniqueStorage()._outgoingTxs = newValue}
  }

  var confirmations: [Google_Protobuf_Any] {
    get {return _storage._confirmations}
    set {_uniqueStorage()._confirmations = newValue}
  }

  var ethereumEventVoteRecords: [Gravity_V1_EthereumEventVoteRecord] {
    get {return _storage._ethereumEventVoteRecords}
    set {_uniqueStorage()._ethereumEventVoteRecords = newValue}
  }

  var delegateKeys: [Gravity_V1_MsgDelegateKeys] {
    get {return _storage._delegateKeys}
    set {_uniqueStorage()._delegateKeys = newValue}
  }

  var erc20ToDenoms: [Gravity_V1_ERC20ToDenom] {
    get {return _storage._erc20ToDenoms}
    set {_uniqueStorage()._erc20ToDenoms = newValue}
  }

  var unbatchedSendToEthereumTxs: [Gravity_V1_SendToEthereum] {
    get {return _storage._unbatchedSendToEthereumTxs}
    set {_uniqueStorage()._unbatchedSendToEthereumTxs = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// This records the relationship between an ERC20 token and the denom
/// of the corresponding Cosmos originated asset
struct Gravity_V1_ERC20ToDenom {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var erc20: String = String()

  var denom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "gravity.v1"

extension Gravity_V1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gravity_id"),
    2: .standard(proto: "contract_source_hash"),
    4: .standard(proto: "bridge_ethereum_address"),
    5: .standard(proto: "bridge_chain_id"),
    6: .standard(proto: "signed_signer_set_txs_window"),
    7: .standard(proto: "signed_batches_window"),
    8: .standard(proto: "ethereum_signatures_window"),
    10: .standard(proto: "target_eth_tx_timeout"),
    11: .standard(proto: "average_block_time"),
    12: .standard(proto: "average_ethereum_block_time"),
    13: .standard(proto: "slash_fraction_signer_set_tx"),
    14: .standard(proto: "slash_fraction_batch"),
    15: .standard(proto: "slash_fraction_ethereum_signature"),
    16: .standard(proto: "slash_fraction_conflicting_ethereum_signature"),
    17: .standard(proto: "unbond_slashing_signer_set_txs_window"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gravityID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contractSourceHash) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.bridgeEthereumAddress) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.bridgeChainID) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.signedSignerSetTxsWindow) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.signedBatchesWindow) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.ethereumSignaturesWindow) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.targetEthTxTimeout) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.averageBlockTime) }()
      case 12: try { try decoder.decodeSingularUInt64Field(value: &self.averageEthereumBlockTime) }()
      case 13: try { try decoder.decodeSingularBytesField(value: &self.slashFractionSignerSetTx) }()
      case 14: try { try decoder.decodeSingularBytesField(value: &self.slashFractionBatch) }()
      case 15: try { try decoder.decodeSingularBytesField(value: &self.slashFractionEthereumSignature) }()
      case 16: try { try decoder.decodeSingularBytesField(value: &self.slashFractionConflictingEthereumSignature) }()
      case 17: try { try decoder.decodeSingularUInt64Field(value: &self.unbondSlashingSignerSetTxsWindow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gravityID.isEmpty {
      try visitor.visitSingularStringField(value: self.gravityID, fieldNumber: 1)
    }
    if !self.contractSourceHash.isEmpty {
      try visitor.visitSingularStringField(value: self.contractSourceHash, fieldNumber: 2)
    }
    if !self.bridgeEthereumAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.bridgeEthereumAddress, fieldNumber: 4)
    }
    if self.bridgeChainID != 0 {
      try visitor.visitSingularUInt64Field(value: self.bridgeChainID, fieldNumber: 5)
    }
    if self.signedSignerSetTxsWindow != 0 {
      try visitor.visitSingularUInt64Field(value: self.signedSignerSetTxsWindow, fieldNumber: 6)
    }
    if self.signedBatchesWindow != 0 {
      try visitor.visitSingularUInt64Field(value: self.signedBatchesWindow, fieldNumber: 7)
    }
    if self.ethereumSignaturesWindow != 0 {
      try visitor.visitSingularUInt64Field(value: self.ethereumSignaturesWindow, fieldNumber: 8)
    }
    if self.targetEthTxTimeout != 0 {
      try visitor.visitSingularUInt64Field(value: self.targetEthTxTimeout, fieldNumber: 10)
    }
    if self.averageBlockTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.averageBlockTime, fieldNumber: 11)
    }
    if self.averageEthereumBlockTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.averageEthereumBlockTime, fieldNumber: 12)
    }
    if !self.slashFractionSignerSetTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.slashFractionSignerSetTx, fieldNumber: 13)
    }
    if !self.slashFractionBatch.isEmpty {
      try visitor.visitSingularBytesField(value: self.slashFractionBatch, fieldNumber: 14)
    }
    if !self.slashFractionEthereumSignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.slashFractionEthereumSignature, fieldNumber: 15)
    }
    if !self.slashFractionConflictingEthereumSignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.slashFractionConflictingEthereumSignature, fieldNumber: 16)
    }
    if self.unbondSlashingSignerSetTxsWindow != 0 {
      try visitor.visitSingularUInt64Field(value: self.unbondSlashingSignerSetTxsWindow, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_Params, rhs: Gravity_V1_Params) -> Bool {
    if lhs.gravityID != rhs.gravityID {return false}
    if lhs.contractSourceHash != rhs.contractSourceHash {return false}
    if lhs.bridgeEthereumAddress != rhs.bridgeEthereumAddress {return false}
    if lhs.bridgeChainID != rhs.bridgeChainID {return false}
    if lhs.signedSignerSetTxsWindow != rhs.signedSignerSetTxsWindow {return false}
    if lhs.signedBatchesWindow != rhs.signedBatchesWindow {return false}
    if lhs.ethereumSignaturesWindow != rhs.ethereumSignaturesWindow {return false}
    if lhs.targetEthTxTimeout != rhs.targetEthTxTimeout {return false}
    if lhs.averageBlockTime != rhs.averageBlockTime {return false}
    if lhs.averageEthereumBlockTime != rhs.averageEthereumBlockTime {return false}
    if lhs.slashFractionSignerSetTx != rhs.slashFractionSignerSetTx {return false}
    if lhs.slashFractionBatch != rhs.slashFractionBatch {return false}
    if lhs.slashFractionEthereumSignature != rhs.slashFractionEthereumSignature {return false}
    if lhs.slashFractionConflictingEthereumSignature != rhs.slashFractionConflictingEthereumSignature {return false}
    if lhs.unbondSlashingSignerSetTxsWindow != rhs.unbondSlashingSignerSetTxsWindow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_GenesisState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenesisState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
    2: .standard(proto: "last_observed_event_nonce"),
    3: .standard(proto: "outgoing_txs"),
    4: .same(proto: "confirmations"),
    9: .standard(proto: "ethereum_event_vote_records"),
    10: .standard(proto: "delegate_keys"),
    11: .standard(proto: "erc20_to_denoms"),
    12: .standard(proto: "unbatched_send_to_ethereum_txs"),
  ]

  fileprivate class _StorageClass {
    var _params: Gravity_V1_Params? = nil
    var _lastObservedEventNonce: UInt64 = 0
    var _outgoingTxs: [Google_Protobuf_Any] = []
    var _confirmations: [Google_Protobuf_Any] = []
    var _ethereumEventVoteRecords: [Gravity_V1_EthereumEventVoteRecord] = []
    var _delegateKeys: [Gravity_V1_MsgDelegateKeys] = []
    var _erc20ToDenoms: [Gravity_V1_ERC20ToDenom] = []
    var _unbatchedSendToEthereumTxs: [Gravity_V1_SendToEthereum] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _params = source._params
      _lastObservedEventNonce = source._lastObservedEventNonce
      _outgoingTxs = source._outgoingTxs
      _confirmations = source._confirmations
      _ethereumEventVoteRecords = source._ethereumEventVoteRecords
      _delegateKeys = source._delegateKeys
      _erc20ToDenoms = source._erc20ToDenoms
      _unbatchedSendToEthereumTxs = source._unbatchedSendToEthereumTxs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._lastObservedEventNonce) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._outgoingTxs) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._confirmations) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._ethereumEventVoteRecords) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._delegateKeys) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._erc20ToDenoms) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._unbatchedSendToEthereumTxs) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._lastObservedEventNonce != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._lastObservedEventNonce, fieldNumber: 2)
      }
      if !_storage._outgoingTxs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._outgoingTxs, fieldNumber: 3)
      }
      if !_storage._confirmations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._confirmations, fieldNumber: 4)
      }
      if !_storage._ethereumEventVoteRecords.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ethereumEventVoteRecords, fieldNumber: 9)
      }
      if !_storage._delegateKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._delegateKeys, fieldNumber: 10)
      }
      if !_storage._erc20ToDenoms.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._erc20ToDenoms, fieldNumber: 11)
      }
      if !_storage._unbatchedSendToEthereumTxs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._unbatchedSendToEthereumTxs, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_GenesisState, rhs: Gravity_V1_GenesisState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._params != rhs_storage._params {return false}
        if _storage._lastObservedEventNonce != rhs_storage._lastObservedEventNonce {return false}
        if _storage._outgoingTxs != rhs_storage._outgoingTxs {return false}
        if _storage._confirmations != rhs_storage._confirmations {return false}
        if _storage._ethereumEventVoteRecords != rhs_storage._ethereumEventVoteRecords {return false}
        if _storage._delegateKeys != rhs_storage._delegateKeys {return false}
        if _storage._erc20ToDenoms != rhs_storage._erc20ToDenoms {return false}
        if _storage._unbatchedSendToEthereumTxs != rhs_storage._unbatchedSendToEthereumTxs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_ERC20ToDenom: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ERC20ToDenom"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "erc20"),
    2: .same(proto: "denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.erc20) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.erc20.isEmpty {
      try visitor.visitSingularStringField(value: self.erc20, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_ERC20ToDenom, rhs: Gravity_V1_ERC20ToDenom) -> Bool {
    if lhs.erc20 != rhs.erc20 {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
