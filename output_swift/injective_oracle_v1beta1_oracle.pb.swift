// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: injective/oracle/v1beta1/oracle.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Injective_Oracle_V1beta1_OracleType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case band // = 1
  case priceFeed // = 2
  case coinbase // = 3
  case chainlink // = 4
  case razor // = 5
  case dia // = 6
  case api3 // = 7
  case uma // = 8
  case pyth // = 9
  case bandIbc // = 10
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .band
    case 2: self = .priceFeed
    case 3: self = .coinbase
    case 4: self = .chainlink
    case 5: self = .razor
    case 6: self = .dia
    case 7: self = .api3
    case 8: self = .uma
    case 9: self = .pyth
    case 10: self = .bandIbc
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .band: return 1
    case .priceFeed: return 2
    case .coinbase: return 3
    case .chainlink: return 4
    case .razor: return 5
    case .dia: return 6
    case .api3: return 7
    case .uma: return 8
    case .pyth: return 9
    case .bandIbc: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Injective_Oracle_V1beta1_OracleType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Injective_Oracle_V1beta1_OracleType] = [
    .unspecified,
    .band,
    .priceFeed,
    .coinbase,
    .chainlink,
    .razor,
    .dia,
    .api3,
    .uma,
    .pyth,
    .bandIbc,
  ]
}

#endif  // swift(>=4.2)

struct Injective_Oracle_V1beta1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_ChainlinkPriceState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var feedID: String = String()

  var answer: String = String()

  var timestamp: UInt64 = 0

  var priceState: Injective_Oracle_V1beta1_PriceState {
    get {return _priceState ?? Injective_Oracle_V1beta1_PriceState()}
    set {_priceState = newValue}
  }
  /// Returns true if `priceState` has been explicitly set.
  var hasPriceState: Bool {return self._priceState != nil}
  /// Clears the value of `priceState`. Subsequent reads from it will return its default value.
  mutating func clearPriceState() {self._priceState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _priceState: Injective_Oracle_V1beta1_PriceState? = nil
}

struct Injective_Oracle_V1beta1_BandPriceState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var symbol: String = String()

  var rate: String = String()

  var resolveTime: UInt64 = 0

  var requestID: UInt64 = 0

  var priceState: Injective_Oracle_V1beta1_PriceState {
    get {return _priceState ?? Injective_Oracle_V1beta1_PriceState()}
    set {_priceState = newValue}
  }
  /// Returns true if `priceState` has been explicitly set.
  var hasPriceState: Bool {return self._priceState != nil}
  /// Clears the value of `priceState`. Subsequent reads from it will return its default value.
  mutating func clearPriceState() {self._priceState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _priceState: Injective_Oracle_V1beta1_PriceState? = nil
}

/// Event type upon set ref
struct Injective_Oracle_V1beta1_SetBandPriceEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var relayer: String = String()

  var symbol: String = String()

  var price: String = String()

  var resolveTime: UInt64 = 0

  var requestID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_SetBandIBCPriceEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var relayer: String = String()

  var symbols: [String] = []

  var prices: [String] = []

  var resolveTime: UInt64 = 0

  var requestID: UInt64 = 0

  var clientID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_EventBandIBCAckSuccess {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ackResult: String = String()

  var clientID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_EventBandIBCAckError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ackError: String = String()

  var clientID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_EventBandIBCResponseTimeout {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var clientID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Event type for getting reference data
struct Injective_Oracle_V1beta1_GetReferenceData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseQuoteSymbol: String = String()

  var baseQuoteRate: String = String()

  var lastUpdateBase: String = String()

  var lastUpdateQuote: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_GrantBandOraclePrivilegeProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var relayers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_RevokeBandOraclePrivilegeProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var relayers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_GrantPriceFeederPrivilegeProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var base: String = String()

  var quote: String = String()

  var relayers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_RevokePriceFeederPrivilegeProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var base: String = String()

  var quote: String = String()

  var relayers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_PriceFeedState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var base: String = String()

  var quote: String = String()

  var priceState: Injective_Oracle_V1beta1_PriceState {
    get {return _priceState ?? Injective_Oracle_V1beta1_PriceState()}
    set {_priceState = newValue}
  }
  /// Returns true if `priceState` has been explicitly set.
  var hasPriceState: Bool {return self._priceState != nil}
  /// Clears the value of `priceState`. Subsequent reads from it will return its default value.
  mutating func clearPriceState() {self._priceState = nil}

  var relayers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _priceState: Injective_Oracle_V1beta1_PriceState? = nil
}

struct Injective_Oracle_V1beta1_PriceFeedInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var base: String = String()

  var quote: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_PriceFeedPrice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var price: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_SetPriceFeedPriceEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var relayer: String = String()

  var base: String = String()

  var quote: String = String()

  /// price defines the price of the oracle base and quote
  var price: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_CoinbasePriceState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// kind should always be "prices"
  var kind: String = String()

  /// timestamp of the when the price was signed by coinbase
  var timestamp: UInt64 = 0

  /// the symbol of the price, e.g. BTC
  var key: String = String()

  /// the value of the price scaled by 1e6
  var value: UInt64 = 0

  /// the price state
  var priceState: Injective_Oracle_V1beta1_PriceState {
    get {return _priceState ?? Injective_Oracle_V1beta1_PriceState()}
    set {_priceState = newValue}
  }
  /// Returns true if `priceState` has been explicitly set.
  var hasPriceState: Bool {return self._priceState != nil}
  /// Clears the value of `priceState`. Subsequent reads from it will return its default value.
  mutating func clearPriceState() {self._priceState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _priceState: Injective_Oracle_V1beta1_PriceState? = nil
}

struct Injective_Oracle_V1beta1_SetCoinbasePriceEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var symbol: String = String()

  var price: String = String()

  var timestamp: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_PriceState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var price: String = String()

  var cumulativePrice: String = String()

  var timestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_AuthorizeBandOracleRequestProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var request: Injective_Oracle_V1beta1_BandOracleRequest {
    get {return _request ?? Injective_Oracle_V1beta1_BandOracleRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _request: Injective_Oracle_V1beta1_BandOracleRequest? = nil
}

struct Injective_Oracle_V1beta1_UpdateBandOracleRequestProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var deleteRequestID: UInt64 = 0

  var updateOracleRequest: Injective_Oracle_V1beta1_BandOracleRequest {
    get {return _updateOracleRequest ?? Injective_Oracle_V1beta1_BandOracleRequest()}
    set {_updateOracleRequest = newValue}
  }
  /// Returns true if `updateOracleRequest` has been explicitly set.
  var hasUpdateOracleRequest: Bool {return self._updateOracleRequest != nil}
  /// Clears the value of `updateOracleRequest`. Subsequent reads from it will return its default value.
  mutating func clearUpdateOracleRequest() {self._updateOracleRequest = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updateOracleRequest: Injective_Oracle_V1beta1_BandOracleRequest? = nil
}

struct Injective_Oracle_V1beta1_EnableBandIBCProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var description_p: String = String()

  var bandIbcParams: Injective_Oracle_V1beta1_BandIBCParams {
    get {return _bandIbcParams ?? Injective_Oracle_V1beta1_BandIBCParams()}
    set {_bandIbcParams = newValue}
  }
  /// Returns true if `bandIbcParams` has been explicitly set.
  var hasBandIbcParams: Bool {return self._bandIbcParams != nil}
  /// Clears the value of `bandIbcParams`. Subsequent reads from it will return its default value.
  mutating func clearBandIbcParams() {self._bandIbcParams = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bandIbcParams: Injective_Oracle_V1beta1_BandIBCParams? = nil
}

struct Injective_Oracle_V1beta1_BandOracleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique Identifier for band ibc oracle request
  var requestID: UInt64 = 0

  /// OracleScriptID is the unique identifier of the oracle script to be executed.
  var oracleScriptID: Int64 = 0

  /// Symbols is the list of symbols to prepare in the calldata
  var symbols: [String] = []

  /// AskCount is the number of validators that are requested to respond to this
  /// oracle request. Higher value means more security, at a higher gas cost.
  var askCount: UInt64 = 0

  /// MinCount is the minimum number of validators necessary for the request to
  /// proceed to the execution phase. Higher value means more security, at the
  /// cost of liveness.
  var minCount: UInt64 = 0

  /// FeeLimit is the maximum tokens that will be paid to all data source providers.
  var feeLimit: [Cosmos_Base_V1beta1_Coin] = []

  /// PrepareGas is amount of gas to pay to prepare raw requests
  var prepareGas: UInt64 = 0

  /// ExecuteGas is amount of gas to reserve for executing
  var executeGas: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Injective_Oracle_V1beta1_BandIBCParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// true if Band IBC should be enabled
  var bandIbcEnabled: Bool = false

  /// block request interval to send Band IBC prices
  var ibcRequestInterval: Int64 = 0

  /// band IBC source channel
  var ibcSourceChannel: String = String()

  /// band IBC version
  var ibcVersion: String = String()

  /// band IBC portID
  var ibcPortID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "injective.oracle.v1beta1"

extension Injective_Oracle_V1beta1_OracleType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unspecified"),
    1: .same(proto: "Band"),
    2: .same(proto: "PriceFeed"),
    3: .same(proto: "Coinbase"),
    4: .same(proto: "Chainlink"),
    5: .same(proto: "Razor"),
    6: .same(proto: "Dia"),
    7: .same(proto: "API3"),
    8: .same(proto: "Uma"),
    9: .same(proto: "Pyth"),
    10: .same(proto: "BandIBC"),
  ]
}

extension Injective_Oracle_V1beta1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_Params, rhs: Injective_Oracle_V1beta1_Params) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_ChainlinkPriceState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChainlinkPriceState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "feed_id"),
    2: .same(proto: "answer"),
    3: .same(proto: "timestamp"),
    4: .standard(proto: "price_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.feedID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.answer) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._priceState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.feedID.isEmpty {
      try visitor.visitSingularStringField(value: self.feedID, fieldNumber: 1)
    }
    if !self.answer.isEmpty {
      try visitor.visitSingularStringField(value: self.answer, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    if let v = self._priceState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_ChainlinkPriceState, rhs: Injective_Oracle_V1beta1_ChainlinkPriceState) -> Bool {
    if lhs.feedID != rhs.feedID {return false}
    if lhs.answer != rhs.answer {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._priceState != rhs._priceState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_BandPriceState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BandPriceState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "symbol"),
    2: .same(proto: "rate"),
    3: .standard(proto: "resolve_time"),
    4: .standard(proto: "request_ID"),
    5: .standard(proto: "price_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.rate) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.resolveTime) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.requestID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._priceState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 1)
    }
    if !self.rate.isEmpty {
      try visitor.visitSingularStringField(value: self.rate, fieldNumber: 2)
    }
    if self.resolveTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.resolveTime, fieldNumber: 3)
    }
    if self.requestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestID, fieldNumber: 4)
    }
    if let v = self._priceState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_BandPriceState, rhs: Injective_Oracle_V1beta1_BandPriceState) -> Bool {
    if lhs.symbol != rhs.symbol {return false}
    if lhs.rate != rhs.rate {return false}
    if lhs.resolveTime != rhs.resolveTime {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs._priceState != rhs._priceState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_SetBandPriceEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetBandPriceEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "relayer"),
    2: .same(proto: "symbol"),
    3: .same(proto: "price"),
    4: .standard(proto: "resolve_time"),
    5: .standard(proto: "request_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.relayer) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.resolveTime) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.requestID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.relayer.isEmpty {
      try visitor.visitSingularStringField(value: self.relayer, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 3)
    }
    if self.resolveTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.resolveTime, fieldNumber: 4)
    }
    if self.requestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_SetBandPriceEvent, rhs: Injective_Oracle_V1beta1_SetBandPriceEvent) -> Bool {
    if lhs.relayer != rhs.relayer {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.price != rhs.price {return false}
    if lhs.resolveTime != rhs.resolveTime {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_SetBandIBCPriceEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetBandIBCPriceEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "relayer"),
    2: .same(proto: "symbols"),
    3: .same(proto: "prices"),
    4: .standard(proto: "resolve_time"),
    5: .standard(proto: "request_id"),
    6: .standard(proto: "client_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.relayer) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.symbols) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.prices) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.resolveTime) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.requestID) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.clientID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.relayer.isEmpty {
      try visitor.visitSingularStringField(value: self.relayer, fieldNumber: 1)
    }
    if !self.symbols.isEmpty {
      try visitor.visitRepeatedStringField(value: self.symbols, fieldNumber: 2)
    }
    if !self.prices.isEmpty {
      try visitor.visitRepeatedStringField(value: self.prices, fieldNumber: 3)
    }
    if self.resolveTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.resolveTime, fieldNumber: 4)
    }
    if self.requestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestID, fieldNumber: 5)
    }
    if self.clientID != 0 {
      try visitor.visitSingularInt64Field(value: self.clientID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_SetBandIBCPriceEvent, rhs: Injective_Oracle_V1beta1_SetBandIBCPriceEvent) -> Bool {
    if lhs.relayer != rhs.relayer {return false}
    if lhs.symbols != rhs.symbols {return false}
    if lhs.prices != rhs.prices {return false}
    if lhs.resolveTime != rhs.resolveTime {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.clientID != rhs.clientID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_EventBandIBCAckSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventBandIBCAckSuccess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ack_result"),
    2: .standard(proto: "client_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ackResult) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.clientID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ackResult.isEmpty {
      try visitor.visitSingularStringField(value: self.ackResult, fieldNumber: 1)
    }
    if self.clientID != 0 {
      try visitor.visitSingularInt64Field(value: self.clientID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_EventBandIBCAckSuccess, rhs: Injective_Oracle_V1beta1_EventBandIBCAckSuccess) -> Bool {
    if lhs.ackResult != rhs.ackResult {return false}
    if lhs.clientID != rhs.clientID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_EventBandIBCAckError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventBandIBCAckError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ack_error"),
    2: .standard(proto: "client_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ackError) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.clientID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ackError.isEmpty {
      try visitor.visitSingularStringField(value: self.ackError, fieldNumber: 1)
    }
    if self.clientID != 0 {
      try visitor.visitSingularInt64Field(value: self.clientID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_EventBandIBCAckError, rhs: Injective_Oracle_V1beta1_EventBandIBCAckError) -> Bool {
    if lhs.ackError != rhs.ackError {return false}
    if lhs.clientID != rhs.clientID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_EventBandIBCResponseTimeout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventBandIBCResponseTimeout"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.clientID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clientID != 0 {
      try visitor.visitSingularInt64Field(value: self.clientID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_EventBandIBCResponseTimeout, rhs: Injective_Oracle_V1beta1_EventBandIBCResponseTimeout) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_GetReferenceData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetReferenceData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_quote_symbol"),
    2: .standard(proto: "base_quote_rate"),
    3: .standard(proto: "last_update_base"),
    4: .standard(proto: "last_update_quote"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.baseQuoteSymbol) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.baseQuoteRate) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.lastUpdateBase) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.lastUpdateQuote) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.baseQuoteSymbol.isEmpty {
      try visitor.visitSingularStringField(value: self.baseQuoteSymbol, fieldNumber: 1)
    }
    if !self.baseQuoteRate.isEmpty {
      try visitor.visitSingularStringField(value: self.baseQuoteRate, fieldNumber: 2)
    }
    if !self.lastUpdateBase.isEmpty {
      try visitor.visitSingularStringField(value: self.lastUpdateBase, fieldNumber: 3)
    }
    if !self.lastUpdateQuote.isEmpty {
      try visitor.visitSingularStringField(value: self.lastUpdateQuote, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_GetReferenceData, rhs: Injective_Oracle_V1beta1_GetReferenceData) -> Bool {
    if lhs.baseQuoteSymbol != rhs.baseQuoteSymbol {return false}
    if lhs.baseQuoteRate != rhs.baseQuoteRate {return false}
    if lhs.lastUpdateBase != rhs.lastUpdateBase {return false}
    if lhs.lastUpdateQuote != rhs.lastUpdateQuote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_GrantBandOraclePrivilegeProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GrantBandOraclePrivilegeProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "relayers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.relayers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.relayers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.relayers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_GrantBandOraclePrivilegeProposal, rhs: Injective_Oracle_V1beta1_GrantBandOraclePrivilegeProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.relayers != rhs.relayers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_RevokeBandOraclePrivilegeProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RevokeBandOraclePrivilegeProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "relayers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.relayers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.relayers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.relayers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_RevokeBandOraclePrivilegeProposal, rhs: Injective_Oracle_V1beta1_RevokeBandOraclePrivilegeProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.relayers != rhs.relayers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_GrantPriceFeederPrivilegeProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GrantPriceFeederPrivilegeProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "base"),
    4: .same(proto: "quote"),
    5: .same(proto: "relayers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.base) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.quote) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.relayers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.base.isEmpty {
      try visitor.visitSingularStringField(value: self.base, fieldNumber: 3)
    }
    if !self.quote.isEmpty {
      try visitor.visitSingularStringField(value: self.quote, fieldNumber: 4)
    }
    if !self.relayers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.relayers, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_GrantPriceFeederPrivilegeProposal, rhs: Injective_Oracle_V1beta1_GrantPriceFeederPrivilegeProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.base != rhs.base {return false}
    if lhs.quote != rhs.quote {return false}
    if lhs.relayers != rhs.relayers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_RevokePriceFeederPrivilegeProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RevokePriceFeederPrivilegeProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "base"),
    4: .same(proto: "quote"),
    5: .same(proto: "relayers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.base) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.quote) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.relayers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.base.isEmpty {
      try visitor.visitSingularStringField(value: self.base, fieldNumber: 3)
    }
    if !self.quote.isEmpty {
      try visitor.visitSingularStringField(value: self.quote, fieldNumber: 4)
    }
    if !self.relayers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.relayers, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_RevokePriceFeederPrivilegeProposal, rhs: Injective_Oracle_V1beta1_RevokePriceFeederPrivilegeProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.base != rhs.base {return false}
    if lhs.quote != rhs.quote {return false}
    if lhs.relayers != rhs.relayers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_PriceFeedState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceFeedState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
    2: .same(proto: "quote"),
    3: .standard(proto: "price_state"),
    4: .same(proto: "relayers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.base) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.quote) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._priceState) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.relayers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.base.isEmpty {
      try visitor.visitSingularStringField(value: self.base, fieldNumber: 1)
    }
    if !self.quote.isEmpty {
      try visitor.visitSingularStringField(value: self.quote, fieldNumber: 2)
    }
    if let v = self._priceState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.relayers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.relayers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_PriceFeedState, rhs: Injective_Oracle_V1beta1_PriceFeedState) -> Bool {
    if lhs.base != rhs.base {return false}
    if lhs.quote != rhs.quote {return false}
    if lhs._priceState != rhs._priceState {return false}
    if lhs.relayers != rhs.relayers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_PriceFeedInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceFeedInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
    2: .same(proto: "quote"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.base) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.quote) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.base.isEmpty {
      try visitor.visitSingularStringField(value: self.base, fieldNumber: 1)
    }
    if !self.quote.isEmpty {
      try visitor.visitSingularStringField(value: self.quote, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_PriceFeedInfo, rhs: Injective_Oracle_V1beta1_PriceFeedInfo) -> Bool {
    if lhs.base != rhs.base {return false}
    if lhs.quote != rhs.quote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_PriceFeedPrice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceFeedPrice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.price) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_PriceFeedPrice, rhs: Injective_Oracle_V1beta1_PriceFeedPrice) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_SetPriceFeedPriceEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetPriceFeedPriceEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "relayer"),
    2: .same(proto: "base"),
    3: .same(proto: "quote"),
    4: .same(proto: "price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.relayer) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.base) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.quote) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.price) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.relayer.isEmpty {
      try visitor.visitSingularStringField(value: self.relayer, fieldNumber: 1)
    }
    if !self.base.isEmpty {
      try visitor.visitSingularStringField(value: self.base, fieldNumber: 2)
    }
    if !self.quote.isEmpty {
      try visitor.visitSingularStringField(value: self.quote, fieldNumber: 3)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_SetPriceFeedPriceEvent, rhs: Injective_Oracle_V1beta1_SetPriceFeedPriceEvent) -> Bool {
    if lhs.relayer != rhs.relayer {return false}
    if lhs.base != rhs.base {return false}
    if lhs.quote != rhs.quote {return false}
    if lhs.price != rhs.price {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_CoinbasePriceState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CoinbasePriceState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "key"),
    4: .same(proto: "value"),
    5: .standard(proto: "price_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._priceState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 4)
    }
    if let v = self._priceState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_CoinbasePriceState, rhs: Injective_Oracle_V1beta1_CoinbasePriceState) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs._priceState != rhs._priceState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_SetCoinbasePriceEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetCoinbasePriceEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "symbol"),
    2: .same(proto: "price"),
    3: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 1)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_SetCoinbasePriceEvent, rhs: Injective_Oracle_V1beta1_SetCoinbasePriceEvent) -> Bool {
    if lhs.symbol != rhs.symbol {return false}
    if lhs.price != rhs.price {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_PriceState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .standard(proto: "cumulative_price"),
    3: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cumulativePrice) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 1)
    }
    if !self.cumulativePrice.isEmpty {
      try visitor.visitSingularStringField(value: self.cumulativePrice, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_PriceState, rhs: Injective_Oracle_V1beta1_PriceState) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.cumulativePrice != rhs.cumulativePrice {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_AuthorizeBandOracleRequestProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthorizeBandOracleRequestProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_AuthorizeBandOracleRequestProposal, rhs: Injective_Oracle_V1beta1_AuthorizeBandOracleRequestProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_UpdateBandOracleRequestProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateBandOracleRequestProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "delete_request_id"),
    4: .standard(proto: "update_oracle_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.deleteRequestID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateOracleRequest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if self.deleteRequestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.deleteRequestID, fieldNumber: 3)
    }
    if let v = self._updateOracleRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_UpdateBandOracleRequestProposal, rhs: Injective_Oracle_V1beta1_UpdateBandOracleRequestProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.deleteRequestID != rhs.deleteRequestID {return false}
    if lhs._updateOracleRequest != rhs._updateOracleRequest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_EnableBandIBCProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnableBandIBCProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "band_ibc_params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._bandIbcParams) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if let v = self._bandIbcParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_EnableBandIBCProposal, rhs: Injective_Oracle_V1beta1_EnableBandIBCProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._bandIbcParams != rhs._bandIbcParams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_BandOracleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BandOracleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "oracle_script_id"),
    3: .same(proto: "symbols"),
    4: .standard(proto: "ask_count"),
    5: .standard(proto: "min_count"),
    6: .standard(proto: "fee_limit"),
    7: .standard(proto: "prepare_gas"),
    8: .standard(proto: "execute_gas"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.oracleScriptID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.symbols) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.askCount) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.minCount) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.feeLimit) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.prepareGas) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.executeGas) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requestID != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestID, fieldNumber: 1)
    }
    if self.oracleScriptID != 0 {
      try visitor.visitSingularInt64Field(value: self.oracleScriptID, fieldNumber: 2)
    }
    if !self.symbols.isEmpty {
      try visitor.visitRepeatedStringField(value: self.symbols, fieldNumber: 3)
    }
    if self.askCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.askCount, fieldNumber: 4)
    }
    if self.minCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.minCount, fieldNumber: 5)
    }
    if !self.feeLimit.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.feeLimit, fieldNumber: 6)
    }
    if self.prepareGas != 0 {
      try visitor.visitSingularUInt64Field(value: self.prepareGas, fieldNumber: 7)
    }
    if self.executeGas != 0 {
      try visitor.visitSingularUInt64Field(value: self.executeGas, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_BandOracleRequest, rhs: Injective_Oracle_V1beta1_BandOracleRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.oracleScriptID != rhs.oracleScriptID {return false}
    if lhs.symbols != rhs.symbols {return false}
    if lhs.askCount != rhs.askCount {return false}
    if lhs.minCount != rhs.minCount {return false}
    if lhs.feeLimit != rhs.feeLimit {return false}
    if lhs.prepareGas != rhs.prepareGas {return false}
    if lhs.executeGas != rhs.executeGas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Oracle_V1beta1_BandIBCParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BandIBCParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "band_ibc_enabled"),
    2: .standard(proto: "ibc_request_interval"),
    3: .standard(proto: "ibc_source_channel"),
    4: .standard(proto: "ibc_version"),
    5: .standard(proto: "ibc_port_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.bandIbcEnabled) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.ibcRequestInterval) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ibcSourceChannel) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ibcVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ibcPortID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bandIbcEnabled != false {
      try visitor.visitSingularBoolField(value: self.bandIbcEnabled, fieldNumber: 1)
    }
    if self.ibcRequestInterval != 0 {
      try visitor.visitSingularInt64Field(value: self.ibcRequestInterval, fieldNumber: 2)
    }
    if !self.ibcSourceChannel.isEmpty {
      try visitor.visitSingularStringField(value: self.ibcSourceChannel, fieldNumber: 3)
    }
    if !self.ibcVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.ibcVersion, fieldNumber: 4)
    }
    if !self.ibcPortID.isEmpty {
      try visitor.visitSingularStringField(value: self.ibcPortID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Oracle_V1beta1_BandIBCParams, rhs: Injective_Oracle_V1beta1_BandIBCParams) -> Bool {
    if lhs.bandIbcEnabled != rhs.bandIbcEnabled {return false}
    if lhs.ibcRequestInterval != rhs.ibcRequestInterval {return false}
    if lhs.ibcSourceChannel != rhs.ibcSourceChannel {return false}
    if lhs.ibcVersion != rhs.ibcVersion {return false}
    if lhs.ibcPortID != rhs.ibcPortID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
