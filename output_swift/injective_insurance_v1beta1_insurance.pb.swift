// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: injective/insurance/v1beta1/insurance.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Injective_Insurance_V1beta1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// default_redemption_notice_period_duration defines the default minimum notice period duration that must pass after an underwriter sends
  /// a redemption request before the underwriter can claim his tokens
  var defaultRedemptionNoticePeriodDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _defaultRedemptionNoticePeriodDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_defaultRedemptionNoticePeriodDuration = newValue}
  }
  /// Returns true if `defaultRedemptionNoticePeriodDuration` has been explicitly set.
  var hasDefaultRedemptionNoticePeriodDuration: Bool {return self._defaultRedemptionNoticePeriodDuration != nil}
  /// Clears the value of `defaultRedemptionNoticePeriodDuration`. Subsequent reads from it will return its default value.
  mutating func clearDefaultRedemptionNoticePeriodDuration() {self._defaultRedemptionNoticePeriodDuration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _defaultRedemptionNoticePeriodDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

struct Injective_Insurance_V1beta1_InsuranceFund {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// deposit denomination for the given insurance fund
  var depositDenom: String = String()

  /// insurance fund pool token denomination for the given insurance fund
  var insurancePoolTokenDenom: String = String()

  /// redemption_notice_period_duration defines the minimum notice period duration that must pass after an underwriter sends
  /// a redemption request before the underwriter can claim his tokens
  var redemptionNoticePeriodDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _redemptionNoticePeriodDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_redemptionNoticePeriodDuration = newValue}
  }
  /// Returns true if `redemptionNoticePeriodDuration` has been explicitly set.
  var hasRedemptionNoticePeriodDuration: Bool {return self._redemptionNoticePeriodDuration != nil}
  /// Clears the value of `redemptionNoticePeriodDuration`. Subsequent reads from it will return its default value.
  mutating func clearRedemptionNoticePeriodDuration() {self._redemptionNoticePeriodDuration = nil}

  /// balance of fund
  var balance: String = String()

  /// total share tokens minted
  var totalShare: String = String()

  /// marketID of the derivative market
  var marketID: String = String()

  /// ticker of the derivative market
  var marketTicker: String = String()

  /// Oracle base currency of the derivative market
  var oracleBase: String = String()

  /// Oracle quote currency of the derivative market
  var oracleQuote: String = String()

  /// Oracle type of the derivative market
  var oracleType: Injective_Oracle_V1beta1_OracleType = .unspecified

  /// Expiration time of the derivative market. Should be -1 for perpetual markets.
  var expiry: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _redemptionNoticePeriodDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

struct Injective_Insurance_V1beta1_RedemptionSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of redemption schedule
  var id: UInt64 = 0

  /// marketId of insurance fund for the redemption
  var marketID: String = String()

  /// address of the redeemer
  var redeemer: String = String()

  /// the time after which the redemption can be claimed
  var claimableRedemptionTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _claimableRedemptionTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_claimableRedemptionTime = newValue}
  }
  /// Returns true if `claimableRedemptionTime` has been explicitly set.
  var hasClaimableRedemptionTime: Bool {return self._claimableRedemptionTime != nil}
  /// Clears the value of `claimableRedemptionTime`. Subsequent reads from it will return its default value.
  mutating func clearClaimableRedemptionTime() {self._claimableRedemptionTime = nil}

  /// the insurance_pool_token amount to redeem
  var redemptionAmount: Cosmos_Base_V1beta1_Coin {
    get {return _redemptionAmount ?? Cosmos_Base_V1beta1_Coin()}
    set {_redemptionAmount = newValue}
  }
  /// Returns true if `redemptionAmount` has been explicitly set.
  var hasRedemptionAmount: Bool {return self._redemptionAmount != nil}
  /// Clears the value of `redemptionAmount`. Subsequent reads from it will return its default value.
  mutating func clearRedemptionAmount() {self._redemptionAmount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _claimableRedemptionTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _redemptionAmount: Cosmos_Base_V1beta1_Coin? = nil
}

struct Injective_Insurance_V1beta1_EventInsuranceFundUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fund: Injective_Insurance_V1beta1_InsuranceFund {
    get {return _fund ?? Injective_Insurance_V1beta1_InsuranceFund()}
    set {_fund = newValue}
  }
  /// Returns true if `fund` has been explicitly set.
  var hasFund: Bool {return self._fund != nil}
  /// Clears the value of `fund`. Subsequent reads from it will return its default value.
  mutating func clearFund() {self._fund = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fund: Injective_Insurance_V1beta1_InsuranceFund? = nil
}

struct Injective_Insurance_V1beta1_EventRequestRedemption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var schedule: Injective_Insurance_V1beta1_RedemptionSchedule {
    get {return _schedule ?? Injective_Insurance_V1beta1_RedemptionSchedule()}
    set {_schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  var hasSchedule: Bool {return self._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  mutating func clearSchedule() {self._schedule = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _schedule: Injective_Insurance_V1beta1_RedemptionSchedule? = nil
}

struct Injective_Insurance_V1beta1_EventWithdrawRedemption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// redemption schedule triggered withdraw
  var schedule: Injective_Insurance_V1beta1_RedemptionSchedule {
    get {return _schedule ?? Injective_Insurance_V1beta1_RedemptionSchedule()}
    set {_schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  var hasSchedule: Bool {return self._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  mutating func clearSchedule() {self._schedule = nil}

  /// redeem coin amount in base_currency
  var redeemCoin: Cosmos_Base_V1beta1_Coin {
    get {return _redeemCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_redeemCoin = newValue}
  }
  /// Returns true if `redeemCoin` has been explicitly set.
  var hasRedeemCoin: Bool {return self._redeemCoin != nil}
  /// Clears the value of `redeemCoin`. Subsequent reads from it will return its default value.
  mutating func clearRedeemCoin() {self._redeemCoin = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _schedule: Injective_Insurance_V1beta1_RedemptionSchedule? = nil
  fileprivate var _redeemCoin: Cosmos_Base_V1beta1_Coin? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "injective.insurance.v1beta1"

extension Injective_Insurance_V1beta1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_redemption_notice_period_duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._defaultRedemptionNoticePeriodDuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._defaultRedemptionNoticePeriodDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Insurance_V1beta1_Params, rhs: Injective_Insurance_V1beta1_Params) -> Bool {
    if lhs._defaultRedemptionNoticePeriodDuration != rhs._defaultRedemptionNoticePeriodDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Insurance_V1beta1_InsuranceFund: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InsuranceFund"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deposit_denom"),
    2: .standard(proto: "insurance_pool_token_denom"),
    3: .standard(proto: "redemption_notice_period_duration"),
    4: .same(proto: "balance"),
    5: .standard(proto: "total_share"),
    6: .standard(proto: "market_id"),
    7: .standard(proto: "market_ticker"),
    8: .standard(proto: "oracle_base"),
    9: .standard(proto: "oracle_quote"),
    10: .standard(proto: "oracle_type"),
    11: .same(proto: "expiry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.depositDenom) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.insurancePoolTokenDenom) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._redemptionNoticePeriodDuration) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.balance) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.totalShare) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.marketTicker) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.oracleBase) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.oracleQuote) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.oracleType) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.expiry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.depositDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.depositDenom, fieldNumber: 1)
    }
    if !self.insurancePoolTokenDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.insurancePoolTokenDenom, fieldNumber: 2)
    }
    if let v = self._redemptionNoticePeriodDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.balance.isEmpty {
      try visitor.visitSingularStringField(value: self.balance, fieldNumber: 4)
    }
    if !self.totalShare.isEmpty {
      try visitor.visitSingularStringField(value: self.totalShare, fieldNumber: 5)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 6)
    }
    if !self.marketTicker.isEmpty {
      try visitor.visitSingularStringField(value: self.marketTicker, fieldNumber: 7)
    }
    if !self.oracleBase.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleBase, fieldNumber: 8)
    }
    if !self.oracleQuote.isEmpty {
      try visitor.visitSingularStringField(value: self.oracleQuote, fieldNumber: 9)
    }
    if self.oracleType != .unspecified {
      try visitor.visitSingularEnumField(value: self.oracleType, fieldNumber: 10)
    }
    if self.expiry != 0 {
      try visitor.visitSingularInt64Field(value: self.expiry, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Insurance_V1beta1_InsuranceFund, rhs: Injective_Insurance_V1beta1_InsuranceFund) -> Bool {
    if lhs.depositDenom != rhs.depositDenom {return false}
    if lhs.insurancePoolTokenDenom != rhs.insurancePoolTokenDenom {return false}
    if lhs._redemptionNoticePeriodDuration != rhs._redemptionNoticePeriodDuration {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.totalShare != rhs.totalShare {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.marketTicker != rhs.marketTicker {return false}
    if lhs.oracleBase != rhs.oracleBase {return false}
    if lhs.oracleQuote != rhs.oracleQuote {return false}
    if lhs.oracleType != rhs.oracleType {return false}
    if lhs.expiry != rhs.expiry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Insurance_V1beta1_RedemptionSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RedemptionSchedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "marketId"),
    3: .same(proto: "redeemer"),
    4: .standard(proto: "claimable_redemption_time"),
    5: .standard(proto: "redemption_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.marketID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.redeemer) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._claimableRedemptionTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._redemptionAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.marketID.isEmpty {
      try visitor.visitSingularStringField(value: self.marketID, fieldNumber: 2)
    }
    if !self.redeemer.isEmpty {
      try visitor.visitSingularStringField(value: self.redeemer, fieldNumber: 3)
    }
    if let v = self._claimableRedemptionTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._redemptionAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Insurance_V1beta1_RedemptionSchedule, rhs: Injective_Insurance_V1beta1_RedemptionSchedule) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.marketID != rhs.marketID {return false}
    if lhs.redeemer != rhs.redeemer {return false}
    if lhs._claimableRedemptionTime != rhs._claimableRedemptionTime {return false}
    if lhs._redemptionAmount != rhs._redemptionAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Insurance_V1beta1_EventInsuranceFundUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventInsuranceFundUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fund"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fund) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._fund {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Insurance_V1beta1_EventInsuranceFundUpdate, rhs: Injective_Insurance_V1beta1_EventInsuranceFundUpdate) -> Bool {
    if lhs._fund != rhs._fund {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Insurance_V1beta1_EventRequestRedemption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventRequestRedemption"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "schedule"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._schedule) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._schedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Insurance_V1beta1_EventRequestRedemption, rhs: Injective_Insurance_V1beta1_EventRequestRedemption) -> Bool {
    if lhs._schedule != rhs._schedule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Injective_Insurance_V1beta1_EventWithdrawRedemption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventWithdrawRedemption"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "schedule"),
    2: .standard(proto: "redeem_coin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._schedule) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._redeemCoin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._schedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._redeemCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Injective_Insurance_V1beta1_EventWithdrawRedemption, rhs: Injective_Insurance_V1beta1_EventWithdrawRedemption) -> Bool {
    if lhs._schedule != rhs._schedule {return false}
    if lhs._redeemCoin != rhs._redeemCoin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
