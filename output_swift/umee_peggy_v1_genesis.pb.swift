// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: umee/peggy/v1/genesis.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Params represent the peggy genesis and store parameters.
///
/// peggy_id: A random 32 byte value to prevent signature reuse, for example if
/// the cosmos validators decided to use the same Ethereum keys for another chain
/// also running Peggy we would not want it to be possible to play a deposit from
/// chain A back on chain B's peggy. This value IS USED ON ETHEREUM so it must
/// be set in your genesis.json before launch and not changed after deploying
/// Peggy.
///
/// contract_hash: The code hash of a known good version of the Peggy contract
/// solidity code. This can be used to verify the correct version of the contract
/// has been deployed. This is a reference value for governance action only it is
/// never read by any Peggy code.
///
/// bridge_ethereum_address: The address of the bridge contract on the Ethereum
/// side. The orchestator uses this address in order to know what contract to
/// relay transactions to.
///
/// bridge_chain_id: The unique identifier of the Ethereum chain, this is a
/// reference value only and is not actually used by any Peggy code.
///
/// These reference values may be used by future Peggy client implementations
/// to allow for saftey features or convenience features like the peggy address
/// in your relayer. A relayer would require a configured peggy address if
/// governance had not set the address on the chain it was relaying for.
///
/// signed_valsets_window
/// signed_batches_window
/// signed_claims_window
///
/// These values represent the time in blocks that a validator has to submit
/// a signature for a batch or valset, or to submit a claim for a particular
/// attestation nonce. In the case of attestations this clock starts when the
/// attestation is created, but only allows for slashing once the event has passed.
///
/// target_batch_timeout: This is the 'target' value for when batches time out,
/// this is a target becuase Ethereum is a probabalistic chain and you can't say
/// for sure what the block frequency is ahead of time.
///
/// average_block_time
/// average_ethereum_block_time
///
/// These values are the average Cosmos block time and Ethereum block time
/// repsectively and they are used to compute what the target batch timeout is.
/// It is important that governance updates these in case of any major, prolonged
/// change in the time it takes to produce a block.
///
/// slash_fraction_valset
/// slash_fraction_batch
/// slash_fraction_claim
/// slash_fraction_conflicting_claim
///
/// The slashing fractions for the various peggy related slashing conditions. The
/// first three refer to not submitting a particular message, the fourth for
/// submitting a different claim for the same Ethereum event.
///
/// unbond_slashing_valsets_window: The unbond slashing valsets window is used to
/// determine how many blocks after starting to unbond a validator needs to
/// continue signing blocks. The goal of this paramater is that when a validator
/// leaves the set, if their leaving creates enough change in the validator set
/// to justify an update they will sign a validator set update for the Ethereum
/// bridge that does not include themselves. Allowing us to remove them from the
/// Ethereum bridge and replace them with the new set gracefully.
///
/// valset_reward: Valset rewards are the amount of tokens this chain issues to
/// relayers of validator sets. These can be any ERC20 token in the bridge, but
/// it's strongly advised that chains use only Cosmos originated tokens, which
/// the bridge effectively mints on Ethereum. If you run out of the token you
/// are using for validator set rewards valset updates will fail and the bridge
/// will be vulnerable to highjacking. For these paramaters the zero values are
/// special and indicate not to attempt any reward. This is the default for
/// bootstrapping.
struct Umeenetwork_Umee_Peggy_V1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peggyID: String {
    get {return _storage._peggyID}
    set {_uniqueStorage()._peggyID = newValue}
  }

  var contractSourceHash: String {
    get {return _storage._contractSourceHash}
    set {_uniqueStorage()._contractSourceHash = newValue}
  }

  var bridgeEthereumAddress: String {
    get {return _storage._bridgeEthereumAddress}
    set {_uniqueStorage()._bridgeEthereumAddress = newValue}
  }

  var bridgeChainID: UInt64 {
    get {return _storage._bridgeChainID}
    set {_uniqueStorage()._bridgeChainID = newValue}
  }

  var signedValsetsWindow: UInt64 {
    get {return _storage._signedValsetsWindow}
    set {_uniqueStorage()._signedValsetsWindow = newValue}
  }

  var signedBatchesWindow: UInt64 {
    get {return _storage._signedBatchesWindow}
    set {_uniqueStorage()._signedBatchesWindow = newValue}
  }

  var signedClaimsWindow: UInt64 {
    get {return _storage._signedClaimsWindow}
    set {_uniqueStorage()._signedClaimsWindow = newValue}
  }

  var targetBatchTimeout: UInt64 {
    get {return _storage._targetBatchTimeout}
    set {_uniqueStorage()._targetBatchTimeout = newValue}
  }

  var averageBlockTime: UInt64 {
    get {return _storage._averageBlockTime}
    set {_uniqueStorage()._averageBlockTime = newValue}
  }

  var averageEthereumBlockTime: UInt64 {
    get {return _storage._averageEthereumBlockTime}
    set {_uniqueStorage()._averageEthereumBlockTime = newValue}
  }

  var slashFractionValset: Data {
    get {return _storage._slashFractionValset}
    set {_uniqueStorage()._slashFractionValset = newValue}
  }

  var slashFractionBatch: Data {
    get {return _storage._slashFractionBatch}
    set {_uniqueStorage()._slashFractionBatch = newValue}
  }

  var slashFractionClaim: Data {
    get {return _storage._slashFractionClaim}
    set {_uniqueStorage()._slashFractionClaim = newValue}
  }

  var slashFractionConflictingClaim: Data {
    get {return _storage._slashFractionConflictingClaim}
    set {_uniqueStorage()._slashFractionConflictingClaim = newValue}
  }

  var unbondSlashingValsetsWindow: UInt64 {
    get {return _storage._unbondSlashingValsetsWindow}
    set {_uniqueStorage()._unbondSlashingValsetsWindow = newValue}
  }

  var slashFractionBadEthSignature: Data {
    get {return _storage._slashFractionBadEthSignature}
    set {_uniqueStorage()._slashFractionBadEthSignature = newValue}
  }

  var claimSlashingEnabled: Bool {
    get {return _storage._claimSlashingEnabled}
    set {_uniqueStorage()._claimSlashingEnabled = newValue}
  }

  var bridgeContractStartHeight: UInt64 {
    get {return _storage._bridgeContractStartHeight}
    set {_uniqueStorage()._bridgeContractStartHeight = newValue}
  }

  var valsetReward: Cosmos_Base_V1beta1_Coin {
    get {return _storage._valsetReward ?? Cosmos_Base_V1beta1_Coin()}
    set {_uniqueStorage()._valsetReward = newValue}
  }
  /// Returns true if `valsetReward` has been explicitly set.
  var hasValsetReward: Bool {return _storage._valsetReward != nil}
  /// Clears the value of `valsetReward`. Subsequent reads from it will return its default value.
  mutating func clearValsetReward() {_uniqueStorage()._valsetReward = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// GenesisState struct
struct Umeenetwork_Umee_Peggy_V1_GenesisState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: Umeenetwork_Umee_Peggy_V1_Params {
    get {return _storage._params ?? Umeenetwork_Umee_Peggy_V1_Params()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {_uniqueStorage()._params = nil}

  var lastObservedNonce: UInt64 {
    get {return _storage._lastObservedNonce}
    set {_uniqueStorage()._lastObservedNonce = newValue}
  }

  var valsets: [Umeenetwork_Umee_Peggy_V1_Valset] {
    get {return _storage._valsets}
    set {_uniqueStorage()._valsets = newValue}
  }

  var valsetConfirms: [Umeenetwork_Umee_Peggy_V1_MsgValsetConfirm] {
    get {return _storage._valsetConfirms}
    set {_uniqueStorage()._valsetConfirms = newValue}
  }

  var batches: [Umeenetwork_Umee_Peggy_V1_OutgoingTxBatch] {
    get {return _storage._batches}
    set {_uniqueStorage()._batches = newValue}
  }

  var batchConfirms: [Umeenetwork_Umee_Peggy_V1_MsgConfirmBatch] {
    get {return _storage._batchConfirms}
    set {_uniqueStorage()._batchConfirms = newValue}
  }

  var attestations: [Umeenetwork_Umee_Peggy_V1_Attestation] {
    get {return _storage._attestations}
    set {_uniqueStorage()._attestations = newValue}
  }

  var orchestratorAddresses: [Umeenetwork_Umee_Peggy_V1_MsgSetOrchestratorAddresses] {
    get {return _storage._orchestratorAddresses}
    set {_uniqueStorage()._orchestratorAddresses = newValue}
  }

  var erc20ToDenoms: [Umeenetwork_Umee_Peggy_V1_ERC20ToDenom] {
    get {return _storage._erc20ToDenoms}
    set {_uniqueStorage()._erc20ToDenoms = newValue}
  }

  var unbatchedTransfers: [Umeenetwork_Umee_Peggy_V1_OutgoingTransferTx] {
    get {return _storage._unbatchedTransfers}
    set {_uniqueStorage()._unbatchedTransfers = newValue}
  }

  var lastObservedEthereumHeight: UInt64 {
    get {return _storage._lastObservedEthereumHeight}
    set {_uniqueStorage()._lastObservedEthereumHeight = newValue}
  }

  var lastOutgoingBatchID: UInt64 {
    get {return _storage._lastOutgoingBatchID}
    set {_uniqueStorage()._lastOutgoingBatchID = newValue}
  }

  var lastOutgoingPoolID: UInt64 {
    get {return _storage._lastOutgoingPoolID}
    set {_uniqueStorage()._lastOutgoingPoolID = newValue}
  }

  var lastObservedValset: Umeenetwork_Umee_Peggy_V1_Valset {
    get {return _storage._lastObservedValset ?? Umeenetwork_Umee_Peggy_V1_Valset()}
    set {_uniqueStorage()._lastObservedValset = newValue}
  }
  /// Returns true if `lastObservedValset` has been explicitly set.
  var hasLastObservedValset: Bool {return _storage._lastObservedValset != nil}
  /// Clears the value of `lastObservedValset`. Subsequent reads from it will return its default value.
  mutating func clearLastObservedValset() {_uniqueStorage()._lastObservedValset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "umeenetwork.umee.peggy.v1"

extension Umeenetwork_Umee_Peggy_V1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peggy_id"),
    2: .standard(proto: "contract_source_hash"),
    3: .standard(proto: "bridge_ethereum_address"),
    4: .standard(proto: "bridge_chain_id"),
    5: .standard(proto: "signed_valsets_window"),
    6: .standard(proto: "signed_batches_window"),
    7: .standard(proto: "signed_claims_window"),
    8: .standard(proto: "target_batch_timeout"),
    9: .standard(proto: "average_block_time"),
    10: .standard(proto: "average_ethereum_block_time"),
    11: .standard(proto: "slash_fraction_valset"),
    12: .standard(proto: "slash_fraction_batch"),
    13: .standard(proto: "slash_fraction_claim"),
    14: .standard(proto: "slash_fraction_conflicting_claim"),
    15: .standard(proto: "unbond_slashing_valsets_window"),
    16: .standard(proto: "slash_fraction_bad_eth_signature"),
    17: .standard(proto: "claim_slashing_enabled"),
    18: .standard(proto: "bridge_contract_start_height"),
    19: .standard(proto: "valset_reward"),
  ]

  fileprivate class _StorageClass {
    var _peggyID: String = String()
    var _contractSourceHash: String = String()
    var _bridgeEthereumAddress: String = String()
    var _bridgeChainID: UInt64 = 0
    var _signedValsetsWindow: UInt64 = 0
    var _signedBatchesWindow: UInt64 = 0
    var _signedClaimsWindow: UInt64 = 0
    var _targetBatchTimeout: UInt64 = 0
    var _averageBlockTime: UInt64 = 0
    var _averageEthereumBlockTime: UInt64 = 0
    var _slashFractionValset: Data = Data()
    var _slashFractionBatch: Data = Data()
    var _slashFractionClaim: Data = Data()
    var _slashFractionConflictingClaim: Data = Data()
    var _unbondSlashingValsetsWindow: UInt64 = 0
    var _slashFractionBadEthSignature: Data = Data()
    var _claimSlashingEnabled: Bool = false
    var _bridgeContractStartHeight: UInt64 = 0
    var _valsetReward: Cosmos_Base_V1beta1_Coin? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _peggyID = source._peggyID
      _contractSourceHash = source._contractSourceHash
      _bridgeEthereumAddress = source._bridgeEthereumAddress
      _bridgeChainID = source._bridgeChainID
      _signedValsetsWindow = source._signedValsetsWindow
      _signedBatchesWindow = source._signedBatchesWindow
      _signedClaimsWindow = source._signedClaimsWindow
      _targetBatchTimeout = source._targetBatchTimeout
      _averageBlockTime = source._averageBlockTime
      _averageEthereumBlockTime = source._averageEthereumBlockTime
      _slashFractionValset = source._slashFractionValset
      _slashFractionBatch = source._slashFractionBatch
      _slashFractionClaim = source._slashFractionClaim
      _slashFractionConflictingClaim = source._slashFractionConflictingClaim
      _unbondSlashingValsetsWindow = source._unbondSlashingValsetsWindow
      _slashFractionBadEthSignature = source._slashFractionBadEthSignature
      _claimSlashingEnabled = source._claimSlashingEnabled
      _bridgeContractStartHeight = source._bridgeContractStartHeight
      _valsetReward = source._valsetReward
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._peggyID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._contractSourceHash) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._bridgeEthereumAddress) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._bridgeChainID) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._signedValsetsWindow) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._signedBatchesWindow) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._signedClaimsWindow) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._targetBatchTimeout) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._averageBlockTime) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._averageEthereumBlockTime) }()
        case 11: try { try decoder.decodeSingularBytesField(value: &_storage._slashFractionValset) }()
        case 12: try { try decoder.decodeSingularBytesField(value: &_storage._slashFractionBatch) }()
        case 13: try { try decoder.decodeSingularBytesField(value: &_storage._slashFractionClaim) }()
        case 14: try { try decoder.decodeSingularBytesField(value: &_storage._slashFractionConflictingClaim) }()
        case 15: try { try decoder.decodeSingularUInt64Field(value: &_storage._unbondSlashingValsetsWindow) }()
        case 16: try { try decoder.decodeSingularBytesField(value: &_storage._slashFractionBadEthSignature) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._claimSlashingEnabled) }()
        case 18: try { try decoder.decodeSingularUInt64Field(value: &_storage._bridgeContractStartHeight) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._valsetReward) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._peggyID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._peggyID, fieldNumber: 1)
      }
      if !_storage._contractSourceHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contractSourceHash, fieldNumber: 2)
      }
      if !_storage._bridgeEthereumAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bridgeEthereumAddress, fieldNumber: 3)
      }
      if _storage._bridgeChainID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._bridgeChainID, fieldNumber: 4)
      }
      if _storage._signedValsetsWindow != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._signedValsetsWindow, fieldNumber: 5)
      }
      if _storage._signedBatchesWindow != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._signedBatchesWindow, fieldNumber: 6)
      }
      if _storage._signedClaimsWindow != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._signedClaimsWindow, fieldNumber: 7)
      }
      if _storage._targetBatchTimeout != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._targetBatchTimeout, fieldNumber: 8)
      }
      if _storage._averageBlockTime != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._averageBlockTime, fieldNumber: 9)
      }
      if _storage._averageEthereumBlockTime != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._averageEthereumBlockTime, fieldNumber: 10)
      }
      if !_storage._slashFractionValset.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._slashFractionValset, fieldNumber: 11)
      }
      if !_storage._slashFractionBatch.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._slashFractionBatch, fieldNumber: 12)
      }
      if !_storage._slashFractionClaim.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._slashFractionClaim, fieldNumber: 13)
      }
      if !_storage._slashFractionConflictingClaim.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._slashFractionConflictingClaim, fieldNumber: 14)
      }
      if _storage._unbondSlashingValsetsWindow != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._unbondSlashingValsetsWindow, fieldNumber: 15)
      }
      if !_storage._slashFractionBadEthSignature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._slashFractionBadEthSignature, fieldNumber: 16)
      }
      if _storage._claimSlashingEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._claimSlashingEnabled, fieldNumber: 17)
      }
      if _storage._bridgeContractStartHeight != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._bridgeContractStartHeight, fieldNumber: 18)
      }
      if let v = _storage._valsetReward {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umeenetwork_Umee_Peggy_V1_Params, rhs: Umeenetwork_Umee_Peggy_V1_Params) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._peggyID != rhs_storage._peggyID {return false}
        if _storage._contractSourceHash != rhs_storage._contractSourceHash {return false}
        if _storage._bridgeEthereumAddress != rhs_storage._bridgeEthereumAddress {return false}
        if _storage._bridgeChainID != rhs_storage._bridgeChainID {return false}
        if _storage._signedValsetsWindow != rhs_storage._signedValsetsWindow {return false}
        if _storage._signedBatchesWindow != rhs_storage._signedBatchesWindow {return false}
        if _storage._signedClaimsWindow != rhs_storage._signedClaimsWindow {return false}
        if _storage._targetBatchTimeout != rhs_storage._targetBatchTimeout {return false}
        if _storage._averageBlockTime != rhs_storage._averageBlockTime {return false}
        if _storage._averageEthereumBlockTime != rhs_storage._averageEthereumBlockTime {return false}
        if _storage._slashFractionValset != rhs_storage._slashFractionValset {return false}
        if _storage._slashFractionBatch != rhs_storage._slashFractionBatch {return false}
        if _storage._slashFractionClaim != rhs_storage._slashFractionClaim {return false}
        if _storage._slashFractionConflictingClaim != rhs_storage._slashFractionConflictingClaim {return false}
        if _storage._unbondSlashingValsetsWindow != rhs_storage._unbondSlashingValsetsWindow {return false}
        if _storage._slashFractionBadEthSignature != rhs_storage._slashFractionBadEthSignature {return false}
        if _storage._claimSlashingEnabled != rhs_storage._claimSlashingEnabled {return false}
        if _storage._bridgeContractStartHeight != rhs_storage._bridgeContractStartHeight {return false}
        if _storage._valsetReward != rhs_storage._valsetReward {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Umeenetwork_Umee_Peggy_V1_GenesisState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenesisState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
    2: .standard(proto: "last_observed_nonce"),
    3: .same(proto: "valsets"),
    4: .standard(proto: "valset_confirms"),
    5: .same(proto: "batches"),
    6: .standard(proto: "batch_confirms"),
    7: .same(proto: "attestations"),
    8: .standard(proto: "orchestrator_addresses"),
    9: .standard(proto: "erc20_to_denoms"),
    10: .standard(proto: "unbatched_transfers"),
    11: .standard(proto: "last_observed_ethereum_height"),
    12: .standard(proto: "last_outgoing_batch_id"),
    13: .standard(proto: "last_outgoing_pool_id"),
    14: .standard(proto: "last_observed_valset"),
  ]

  fileprivate class _StorageClass {
    var _params: Umeenetwork_Umee_Peggy_V1_Params? = nil
    var _lastObservedNonce: UInt64 = 0
    var _valsets: [Umeenetwork_Umee_Peggy_V1_Valset] = []
    var _valsetConfirms: [Umeenetwork_Umee_Peggy_V1_MsgValsetConfirm] = []
    var _batches: [Umeenetwork_Umee_Peggy_V1_OutgoingTxBatch] = []
    var _batchConfirms: [Umeenetwork_Umee_Peggy_V1_MsgConfirmBatch] = []
    var _attestations: [Umeenetwork_Umee_Peggy_V1_Attestation] = []
    var _orchestratorAddresses: [Umeenetwork_Umee_Peggy_V1_MsgSetOrchestratorAddresses] = []
    var _erc20ToDenoms: [Umeenetwork_Umee_Peggy_V1_ERC20ToDenom] = []
    var _unbatchedTransfers: [Umeenetwork_Umee_Peggy_V1_OutgoingTransferTx] = []
    var _lastObservedEthereumHeight: UInt64 = 0
    var _lastOutgoingBatchID: UInt64 = 0
    var _lastOutgoingPoolID: UInt64 = 0
    var _lastObservedValset: Umeenetwork_Umee_Peggy_V1_Valset? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _params = source._params
      _lastObservedNonce = source._lastObservedNonce
      _valsets = source._valsets
      _valsetConfirms = source._valsetConfirms
      _batches = source._batches
      _batchConfirms = source._batchConfirms
      _attestations = source._attestations
      _orchestratorAddresses = source._orchestratorAddresses
      _erc20ToDenoms = source._erc20ToDenoms
      _unbatchedTransfers = source._unbatchedTransfers
      _lastObservedEthereumHeight = source._lastObservedEthereumHeight
      _lastOutgoingBatchID = source._lastOutgoingBatchID
      _lastOutgoingPoolID = source._lastOutgoingPoolID
      _lastObservedValset = source._lastObservedValset
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._lastObservedNonce) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._valsets) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._valsetConfirms) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._batches) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._batchConfirms) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._attestations) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._orchestratorAddresses) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._erc20ToDenoms) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._unbatchedTransfers) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._lastObservedEthereumHeight) }()
        case 12: try { try decoder.decodeSingularUInt64Field(value: &_storage._lastOutgoingBatchID) }()
        case 13: try { try decoder.decodeSingularUInt64Field(value: &_storage._lastOutgoingPoolID) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._lastObservedValset) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._lastObservedNonce != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._lastObservedNonce, fieldNumber: 2)
      }
      if !_storage._valsets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._valsets, fieldNumber: 3)
      }
      if !_storage._valsetConfirms.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._valsetConfirms, fieldNumber: 4)
      }
      if !_storage._batches.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._batches, fieldNumber: 5)
      }
      if !_storage._batchConfirms.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._batchConfirms, fieldNumber: 6)
      }
      if !_storage._attestations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._attestations, fieldNumber: 7)
      }
      if !_storage._orchestratorAddresses.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._orchestratorAddresses, fieldNumber: 8)
      }
      if !_storage._erc20ToDenoms.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._erc20ToDenoms, fieldNumber: 9)
      }
      if !_storage._unbatchedTransfers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._unbatchedTransfers, fieldNumber: 10)
      }
      if _storage._lastObservedEthereumHeight != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._lastObservedEthereumHeight, fieldNumber: 11)
      }
      if _storage._lastOutgoingBatchID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._lastOutgoingBatchID, fieldNumber: 12)
      }
      if _storage._lastOutgoingPoolID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._lastOutgoingPoolID, fieldNumber: 13)
      }
      if let v = _storage._lastObservedValset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Umeenetwork_Umee_Peggy_V1_GenesisState, rhs: Umeenetwork_Umee_Peggy_V1_GenesisState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._params != rhs_storage._params {return false}
        if _storage._lastObservedNonce != rhs_storage._lastObservedNonce {return false}
        if _storage._valsets != rhs_storage._valsets {return false}
        if _storage._valsetConfirms != rhs_storage._valsetConfirms {return false}
        if _storage._batches != rhs_storage._batches {return false}
        if _storage._batchConfirms != rhs_storage._batchConfirms {return false}
        if _storage._attestations != rhs_storage._attestations {return false}
        if _storage._orchestratorAddresses != rhs_storage._orchestratorAddresses {return false}
        if _storage._erc20ToDenoms != rhs_storage._erc20ToDenoms {return false}
        if _storage._unbatchedTransfers != rhs_storage._unbatchedTransfers {return false}
        if _storage._lastObservedEthereumHeight != rhs_storage._lastObservedEthereumHeight {return false}
        if _storage._lastOutgoingBatchID != rhs_storage._lastOutgoingBatchID {return false}
        if _storage._lastOutgoingPoolID != rhs_storage._lastOutgoingPoolID {return false}
        if _storage._lastObservedValset != rhs_storage._lastObservedValset {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
