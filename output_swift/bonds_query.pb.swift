// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bonds/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// QueryBondsRequest is the request type for the Query/Bonds RPC method.
struct Bonds_QueryBondsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBondsResponse is the response type for the Query/Bonds RPC method.
struct Bonds_QueryBondsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bonds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBondsDetailedRequest is the request type for the Query/BondsDetailed RPC method.
struct Bonds_QueryBondsDetailedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBondsDetailedResponse is the response type for the Query/BondsDetailed RPC method.
struct Bonds_QueryBondsDetailedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondsDetailed: [Bonds_BondDetails] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBondRequest is the request type for the Query/Bond RPC method.
struct Bonds_QueryBondRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBondResponse is the response type for the Query/Bond RPC method.
struct Bonds_QueryBondResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bond: Bonds_Bond {
    get {return _bond ?? Bonds_Bond()}
    set {_bond = newValue}
  }
  /// Returns true if `bond` has been explicitly set.
  var hasBond: Bool {return self._bond != nil}
  /// Clears the value of `bond`. Subsequent reads from it will return its default value.
  mutating func clearBond() {self._bond = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bond: Bonds_Bond? = nil
}

/// QueryBatchRequest is the request type for the Query/Batch RPC method.
struct Bonds_QueryBatchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryBatchResponse is the response type for the Query/Batch RPC method.
struct Bonds_QueryBatchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var batch: Bonds_Batch {
    get {return _batch ?? Bonds_Batch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  mutating func clearBatch() {self._batch = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _batch: Bonds_Batch? = nil
}

/// QueryLastBatchRequest is the request type for the Query/LastBatch RPC method.
struct Bonds_QueryLastBatchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryLastBatchResponse is the response type for the Query/LastBatch RPC method.
struct Bonds_QueryLastBatchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastBatch: Bonds_Batch {
    get {return _lastBatch ?? Bonds_Batch()}
    set {_lastBatch = newValue}
  }
  /// Returns true if `lastBatch` has been explicitly set.
  var hasLastBatch: Bool {return self._lastBatch != nil}
  /// Clears the value of `lastBatch`. Subsequent reads from it will return its default value.
  mutating func clearLastBatch() {self._lastBatch = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastBatch: Bonds_Batch? = nil
}

/// QueryCurrentPriceRequest is the request type for the Query/CurrentPrice RPC method.
struct Bonds_QueryCurrentPriceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCurrentPriceResponse is the response type for the Query/CurrentPrice RPC method.
struct Bonds_QueryCurrentPriceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currentPrice: [Cosmos_Base_V1beta1_DecCoin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCurrentReserveRequest is the request type for the Query/CurrentReserve RPC method.
struct Bonds_QueryCurrentReserveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCurrentReserveResponse is the response type for the Query/CurrentReserve RPC method.
struct Bonds_QueryCurrentReserveResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currentReserve: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAvailableReserveRequest is the request type for the Query/AvailableReserve RPC method.
struct Bonds_QueryAvailableReserveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAvailableReserveResponse is the response type for the Query/AvailableReserve RPC method.
struct Bonds_QueryAvailableReserveResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var availableReserve: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCustomPriceRequest is the request type for the Query/CustomPrice RPC method.
struct Bonds_QueryCustomPriceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var bondAmount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCustomPriceResponse is the response type for the Query/CustomPrice RPC method.
struct Bonds_QueryCustomPriceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var price: [Cosmos_Base_V1beta1_DecCoin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCustomPriceRequest is the request type for the Query/BuyPrice RPC method.
struct Bonds_QueryBuyPriceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var bondAmount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryCustomPriceResponse is the response type for the Query/BuyPrice RPC method.
struct Bonds_QueryBuyPriceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var adjustedSupply: Cosmos_Base_V1beta1_Coin {
    get {return _adjustedSupply ?? Cosmos_Base_V1beta1_Coin()}
    set {_adjustedSupply = newValue}
  }
  /// Returns true if `adjustedSupply` has been explicitly set.
  var hasAdjustedSupply: Bool {return self._adjustedSupply != nil}
  /// Clears the value of `adjustedSupply`. Subsequent reads from it will return its default value.
  mutating func clearAdjustedSupply() {self._adjustedSupply = nil}

  var prices: [Cosmos_Base_V1beta1_Coin] = []

  var txFees: [Cosmos_Base_V1beta1_Coin] = []

  var totalPrices: [Cosmos_Base_V1beta1_Coin] = []

  var totalFees: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _adjustedSupply: Cosmos_Base_V1beta1_Coin? = nil
}

/// QuerySellReturnRequest is the request type for the Query/SellReturn RPC method.
struct Bonds_QuerySellReturnRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var bondAmount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySellReturnResponse is the response type for the Query/SellReturn RPC method.
struct Bonds_QuerySellReturnResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var adjustedSupply: Cosmos_Base_V1beta1_Coin {
    get {return _adjustedSupply ?? Cosmos_Base_V1beta1_Coin()}
    set {_adjustedSupply = newValue}
  }
  /// Returns true if `adjustedSupply` has been explicitly set.
  var hasAdjustedSupply: Bool {return self._adjustedSupply != nil}
  /// Clears the value of `adjustedSupply`. Subsequent reads from it will return its default value.
  mutating func clearAdjustedSupply() {self._adjustedSupply = nil}

  var returns: [Cosmos_Base_V1beta1_Coin] = []

  var txFees: [Cosmos_Base_V1beta1_Coin] = []

  var exitFees: [Cosmos_Base_V1beta1_Coin] = []

  var totalReturns: [Cosmos_Base_V1beta1_Coin] = []

  var totalFees: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _adjustedSupply: Cosmos_Base_V1beta1_Coin? = nil
}

/// QuerySwapReturnRequest is the request type for the Query/SwapReturn RPC method.
struct Bonds_QuerySwapReturnRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var fromTokenWithAmount: String = String()

  var toToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QuerySwapReturnResponse is the response type for the Query/SwapReturn RPC method.
struct Bonds_QuerySwapReturnResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var totalReturns: [Cosmos_Base_V1beta1_Coin] = []

  var totalFees: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAlphaMaximumsRequest is the request type for the Query/AlphaMaximums RPC method.
struct Bonds_QueryAlphaMaximumsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bondDid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryAlphaMaximumsResponse is the response type for the Query/AlphaMaximums RPC method.
struct Bonds_QueryAlphaMaximumsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var maxSystemAlphaIncrease: String = String()

  var maxSystemAlpha: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryParamsRequest is the request type for the Query/Params RPC method.
struct Bonds_QueryParamsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryParamsResponse is the response type for the Query/Params RPC method.
struct Bonds_QueryParamsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: Bonds_Params {
    get {return _params ?? Bonds_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Bonds_Params? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bonds"

extension Bonds_QueryBondsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBondsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryBondsRequest, rhs: Bonds_QueryBondsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryBondsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBondsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bonds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.bonds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bonds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.bonds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryBondsResponse, rhs: Bonds_QueryBondsResponse) -> Bool {
    if lhs.bonds != rhs.bonds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryBondsDetailedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBondsDetailedRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryBondsDetailedRequest, rhs: Bonds_QueryBondsDetailedRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryBondsDetailedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBondsDetailedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bonds_detailed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.bondsDetailed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondsDetailed.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bondsDetailed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryBondsDetailedResponse, rhs: Bonds_QueryBondsDetailedResponse) -> Bool {
    if lhs.bondsDetailed != rhs.bondsDetailed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryBondRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBondRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryBondRequest, rhs: Bonds_QueryBondRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryBondResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBondResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bond"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bond) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._bond {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryBondResponse, rhs: Bonds_QueryBondResponse) -> Bool {
    if lhs._bond != rhs._bond {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryBatchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBatchRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryBatchRequest, rhs: Bonds_QueryBatchRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryBatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBatchResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryBatchResponse, rhs: Bonds_QueryBatchResponse) -> Bool {
    if lhs._batch != rhs._batch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryLastBatchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryLastBatchRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryLastBatchRequest, rhs: Bonds_QueryLastBatchRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryLastBatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryLastBatchResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_batch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lastBatch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._lastBatch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryLastBatchResponse, rhs: Bonds_QueryLastBatchResponse) -> Bool {
    if lhs._lastBatch != rhs._lastBatch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryCurrentPriceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCurrentPriceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryCurrentPriceRequest, rhs: Bonds_QueryCurrentPriceRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryCurrentPriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCurrentPriceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.currentPrice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currentPrice.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.currentPrice, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryCurrentPriceResponse, rhs: Bonds_QueryCurrentPriceResponse) -> Bool {
    if lhs.currentPrice != rhs.currentPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryCurrentReserveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCurrentReserveRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryCurrentReserveRequest, rhs: Bonds_QueryCurrentReserveRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryCurrentReserveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCurrentReserveResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_reserve"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.currentReserve) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currentReserve.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.currentReserve, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryCurrentReserveResponse, rhs: Bonds_QueryCurrentReserveResponse) -> Bool {
    if lhs.currentReserve != rhs.currentReserve {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryAvailableReserveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAvailableReserveRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryAvailableReserveRequest, rhs: Bonds_QueryAvailableReserveRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryAvailableReserveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAvailableReserveResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "available_reserve"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.availableReserve) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.availableReserve.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.availableReserve, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryAvailableReserveResponse, rhs: Bonds_QueryAvailableReserveResponse) -> Bool {
    if lhs.availableReserve != rhs.availableReserve {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryCustomPriceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCustomPriceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
    2: .standard(proto: "bond_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bondAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    if !self.bondAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.bondAmount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryCustomPriceRequest, rhs: Bonds_QueryCustomPriceRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.bondAmount != rhs.bondAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryCustomPriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCustomPriceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.price) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.price.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.price, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryCustomPriceResponse, rhs: Bonds_QueryCustomPriceResponse) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryBuyPriceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBuyPriceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
    2: .standard(proto: "bond_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bondAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    if !self.bondAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.bondAmount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryBuyPriceRequest, rhs: Bonds_QueryBuyPriceRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.bondAmount != rhs.bondAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryBuyPriceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryBuyPriceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "adjusted_supply"),
    2: .same(proto: "prices"),
    3: .standard(proto: "tx_fees"),
    4: .standard(proto: "total_prices"),
    5: .standard(proto: "total_fees"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._adjustedSupply) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.prices) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.txFees) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.totalPrices) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.totalFees) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._adjustedSupply {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.prices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.prices, fieldNumber: 2)
    }
    if !self.txFees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.txFees, fieldNumber: 3)
    }
    if !self.totalPrices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.totalPrices, fieldNumber: 4)
    }
    if !self.totalFees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.totalFees, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryBuyPriceResponse, rhs: Bonds_QueryBuyPriceResponse) -> Bool {
    if lhs._adjustedSupply != rhs._adjustedSupply {return false}
    if lhs.prices != rhs.prices {return false}
    if lhs.txFees != rhs.txFees {return false}
    if lhs.totalPrices != rhs.totalPrices {return false}
    if lhs.totalFees != rhs.totalFees {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QuerySellReturnRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySellReturnRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
    2: .standard(proto: "bond_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bondAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    if !self.bondAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.bondAmount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QuerySellReturnRequest, rhs: Bonds_QuerySellReturnRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.bondAmount != rhs.bondAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QuerySellReturnResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySellReturnResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "adjusted_supply"),
    2: .same(proto: "returns"),
    3: .standard(proto: "tx_fees"),
    4: .standard(proto: "exit_fees"),
    5: .standard(proto: "total_returns"),
    6: .standard(proto: "total_fees"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._adjustedSupply) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.returns) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.txFees) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.exitFees) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.totalReturns) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.totalFees) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._adjustedSupply {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.returns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.returns, fieldNumber: 2)
    }
    if !self.txFees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.txFees, fieldNumber: 3)
    }
    if !self.exitFees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exitFees, fieldNumber: 4)
    }
    if !self.totalReturns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.totalReturns, fieldNumber: 5)
    }
    if !self.totalFees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.totalFees, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QuerySellReturnResponse, rhs: Bonds_QuerySellReturnResponse) -> Bool {
    if lhs._adjustedSupply != rhs._adjustedSupply {return false}
    if lhs.returns != rhs.returns {return false}
    if lhs.txFees != rhs.txFees {return false}
    if lhs.exitFees != rhs.exitFees {return false}
    if lhs.totalReturns != rhs.totalReturns {return false}
    if lhs.totalFees != rhs.totalFees {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QuerySwapReturnRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySwapReturnRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
    2: .standard(proto: "from_token_with_amount"),
    3: .standard(proto: "to_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fromTokenWithAmount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.toToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    if !self.fromTokenWithAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.fromTokenWithAmount, fieldNumber: 2)
    }
    if !self.toToken.isEmpty {
      try visitor.visitSingularStringField(value: self.toToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QuerySwapReturnRequest, rhs: Bonds_QuerySwapReturnRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.fromTokenWithAmount != rhs.fromTokenWithAmount {return false}
    if lhs.toToken != rhs.toToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QuerySwapReturnResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuerySwapReturnResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_returns"),
    2: .standard(proto: "total_fees"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.totalReturns) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.totalFees) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.totalReturns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.totalReturns, fieldNumber: 1)
    }
    if !self.totalFees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.totalFees, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QuerySwapReturnResponse, rhs: Bonds_QuerySwapReturnResponse) -> Bool {
    if lhs.totalReturns != rhs.totalReturns {return false}
    if lhs.totalFees != rhs.totalFees {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryAlphaMaximumsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAlphaMaximumsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bond_did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bondDid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bondDid.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryAlphaMaximumsRequest, rhs: Bonds_QueryAlphaMaximumsRequest) -> Bool {
    if lhs.bondDid != rhs.bondDid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryAlphaMaximumsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryAlphaMaximumsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_system_alpha_increase"),
    2: .standard(proto: "max_system_alpha"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.maxSystemAlphaIncrease) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.maxSystemAlpha) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.maxSystemAlphaIncrease.isEmpty {
      try visitor.visitSingularStringField(value: self.maxSystemAlphaIncrease, fieldNumber: 1)
    }
    if !self.maxSystemAlpha.isEmpty {
      try visitor.visitSingularStringField(value: self.maxSystemAlpha, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryAlphaMaximumsResponse, rhs: Bonds_QueryAlphaMaximumsResponse) -> Bool {
    if lhs.maxSystemAlphaIncrease != rhs.maxSystemAlphaIncrease {return false}
    if lhs.maxSystemAlpha != rhs.maxSystemAlpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryParamsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryParamsRequest, rhs: Bonds_QueryParamsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bonds_QueryParamsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryParamsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bonds_QueryParamsResponse, rhs: Bonds_QueryParamsResponse) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
